# HG changeset patch
# User Grisha Pushkov <grisha@push.org.ru>
# Parent  d1667f3f465389b4a5c75e5832756238fde49aa3
Bug 1223527 - Migrate markup-view tests to use testActor

diff --git a/devtools/.eslintrc b/devtools/.eslintrc
--- a/devtools/.eslintrc
+++ b/devtools/.eslintrc
@@ -91,17 +91,17 @@
     // Enforces spacing between keys and values in object literal properties.
     "key-spacing": [1, {"beforeColon": false, "afterColon": true}],
     // Allow mixed 'LF' and 'CRLF' as linebreaks.
     "linebreak-style": 0,
     // Don't enforce the maximum depth that blocks can be nested. The complexity
     // rule is a better rule to check this.
     "max-depth": 0,
     // Maximum length of a line.
-    "max-len": [1, 80],
+    "max-len": [1, 80, 4, {"ignorePattern": ".{100,}"}],
     // Maximum depth callbacks can be nested.
     "max-nested-callbacks": [2, 3],
     // Don't limit the number of parameters that can be used in a function.
     "max-params": 0,
     // Don't limit the maximum number of statement allowed in a function. We
     // already have the complexity rule that's a better measurement.
     "max-statements": 0,
     // Require a capital letter for constructors, only check if all new
diff --git a/devtools/.eslintrc.mochitests b/devtools/.eslintrc.mochitests
--- a/devtools/.eslintrc.mochitests
+++ b/devtools/.eslintrc.mochitests
@@ -2,43 +2,67 @@
 {
   "rules": {
     // Only disallow non-global unused vars, so that head.js does not produce
     // errors.
     "no-unused-vars": [2, {"vars": "local"}]
   },
   // All globals made available in the test environment.
   "globals": {
-    "add_task": true,
     "Assert": true,
     "BrowserTestUtils": true,
+    "ContentTask": true,
+    "EventUtils": true,
+    "Node": true,
+    "SimpleTest": true,
+    "SpecialPowers": true,
+    "TEST_URL_ROOT": true,
+    "addTab": true,
+    "add_task": true,
+    "clickContainer": true,
     "content": true,
-    "ContentTask": true,
+    "contextMenuClick": true,
+    "createTestHTTPServer": true,
     "document": true,
-    "EventUtils": true,
+    "executeInContent": true,
     "executeSoon": true,
     "export_assertions": true,
     "finish": true,
     "gBrowser": true,
     "gDevTools": true,
+    "gTestPath": true,
+    "getContainerForNodeFront": true,
+    "getContainerForSelector": true,
+    "getNodeFront": true,
+    "getNodeInfo": true,
     "getRootDirectory": true,
     "getTestFilePath": true,
-    "gTestPath": true,
     "info": true,
     "is": true,
     "isnot": true,
+    "loadHelperScript": true,
     "navigator": true,
     "ok": true,
+    "once": true,
+    "openInspector": true,
+    "openToolbox": true,
     "promise": true,
+    "promiseNextTick": true,
+    "redoChange": true,
     "registerCleanupFunction": true,
+    "registerTabActor": true,
     "requestLongerTimeout": true,
+    "selectNode": true,
     "setTimeout": true,
-    "SimpleTest": true,
-    "SpecialPowers": true,
     "todo": true,
     "todo_is": true,
     "todo_isnot": true,
+    "undoChange": true,
+    "unregisterActor": true,
+    "wait": true,
+    "waitForChildrenUpdated": true,
     "waitForClipboard": true,
     "waitForExplicitFinish": true,
     "waitForFocus": true,
+    "waitForMultipleChildrenUpdates": true,
     "window": true,
   }
 }
diff --git a/devtools/client/markupview/test/.eslintrc b/devtools/client/markupview/test/.eslintrc
--- a/devtools/client/markupview/test/.eslintrc
+++ b/devtools/client/markupview/test/.eslintrc
@@ -1,4 +1,26 @@
 {
   // Extend from the shared list of defined globals for mochitests.
-  "extends": "../../../.eslintrc.mochitests"
+  "extends": "../../../.eslintrc.mochitests",
+  "globals": {
+    "CHROME_BASE": true,
+    "addNewAttributes": true,
+    "assertAttributes": true,
+    "checkFocusedAttribute": true,
+    "collapseSelectionAndShiftTab": true,
+    "collapseSelectionAndTab": true,
+    "inplaceEditor": true,
+    "isEditingMenuDisabled": true,
+    "isEditingMenuEnabled": true,
+    "reloadPage": true,
+    "runAddAttributesTests": true,
+    "runEditAttributesTests": true,
+    "runEditOuterHTMLTests": true,
+    "runEventPopupTests": true,
+    "searchUsingSelectorSearch": true,
+    "setEditableFieldValue": true,
+    "setNodeAttribute": true,
+    "simulateNodeDrag": true,
+    "simulateNodeDragAndDrop": true,
+    "simulateNodeDrop": true,
+  }
 }
diff --git a/devtools/client/markupview/test/browser_markupview_anonymous_01.js b/devtools/client/markupview/test/browser_markupview_anonymous_01.js
--- a/devtools/client/markupview/test/browser_markupview_anonymous_01.js
+++ b/devtools/client/markupview/test/browser_markupview_anonymous_01.js
@@ -9,36 +9,36 @@ const TEST_URL = TEST_URL_ROOT + "doc_ma
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   let pseudo = yield getNodeFront("#pseudo", inspector);
 
   // Markup looks like: <div><::before /><span /><::after /></div>
   let children = yield inspector.walker.children(pseudo);
-  is (children.nodes.length, 3, "Children returned from walker");
+  is(children.nodes.length, 3, "Children returned from walker");
 
-  info ("Checking the ::before pseudo element");
+  info("Checking the ::before pseudo element");
   let before = children.nodes[0];
   yield isEditingMenuDisabled(before, inspector);
 
-  info ("Checking the normal child element");
+  info("Checking the normal child element");
   let span = children.nodes[1];
   yield isEditingMenuEnabled(span, inspector);
 
-  info ("Checking the ::after pseudo element");
+  info("Checking the ::after pseudo element");
   let after = children.nodes[2];
   yield isEditingMenuDisabled(after, inspector);
 
   let native = yield getNodeFront("#native", inspector);
 
   // Markup looks like: <div><video controls /></div>
   let nativeChildren = yield inspector.walker.children(native);
-  is (nativeChildren.nodes.length, 1, "Children returned from walker");
+  is(nativeChildren.nodes.length, 1, "Children returned from walker");
 
-  info ("Checking the video element");
+  info("Checking the video element");
   let video = nativeChildren.nodes[0];
-  ok (!video.isAnonymous, "<video> is not anonymous");
+  ok(!video.isAnonymous, "<video> is not anonymous");
 
   let videoChildren = yield inspector.walker.children(video);
-  is (videoChildren.nodes.length, 0,
+  is(videoChildren.nodes.length, 0,
     "No native children returned from walker for <video> by default");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_anonymous_02.js b/devtools/client/markupview/test/browser_markupview_anonymous_02.js
--- a/devtools/client/markupview/test/browser_markupview_anonymous_02.js
+++ b/devtools/client/markupview/test/browser_markupview_anonymous_02.js
@@ -1,29 +1,29 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test XBL anonymous content in the markupview
+// Test XBL anonymous content in the markupview.
 const TEST_URL = "chrome://devtools/content/scratchpad/scratchpad.xul";
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   let toolbarbutton = yield getNodeFront("toolbarbutton", inspector);
   let children = yield inspector.walker.children(toolbarbutton);
 
   is(toolbarbutton.numChildren, 3, "Correct number of children");
-  is (children.nodes.length, 3, "Children returned from walker");
+  is(children.nodes.length, 3, "Children returned from walker");
 
   is(toolbarbutton.isAnonymous, false, "Toolbarbutton is not anonymous");
   yield isEditingMenuEnabled(toolbarbutton, inspector);
 
   for (let node of children.nodes) {
-    ok (node.isAnonymous, "Child is anonymous");
-    ok (node._form.isXBLAnonymous, "Child is XBL anonymous");
-    ok (!node._form.isShadowAnonymous, "Child is not shadow anonymous");
-    ok (!node._form.isNativeAnonymous, "Child is not native anonymous");
+    ok(node.isAnonymous, "Child is anonymous");
+    ok(node._form.isXBLAnonymous, "Child is XBL anonymous");
+    ok(!node._form.isShadowAnonymous, "Child is not shadow anonymous");
+    ok(!node._form.isNativeAnonymous, "Child is not native anonymous");
     yield isEditingMenuDisabled(node, inspector);
   }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_anonymous_03.js b/devtools/client/markupview/test/browser_markupview_anonymous_03.js
--- a/devtools/client/markupview/test/browser_markupview_anonymous_03.js
+++ b/devtools/client/markupview/test/browser_markupview_anonymous_03.js
@@ -12,23 +12,23 @@ const TEST_URL = TEST_URL_ROOT + "doc_ma
 add_task(function*() {
   Services.prefs.setBoolPref("dom.webcomponents.enabled", true);
 
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   let shadow = yield getNodeFront("#shadow", inspector.markup);
   let children = yield inspector.walker.children(shadow);
 
-  is (shadow.numChildren, 3, "Children of the shadow root are counted");
-  is (children.nodes.length, 3, "Children returned from walker");
+  is(shadow.numChildren, 3, "Children of the shadow root are counted");
+  is(children.nodes.length, 3, "Children returned from walker");
 
-  info ("Checking the ::before pseudo element");
+  info("Checking the ::before pseudo element");
   let before = children.nodes[0];
   yield isEditingMenuDisabled(before, inspector);
 
-  info ("Checking the <h3> shadow element");
+  info("Checking the <h3> shadow element");
   let shadowChild1 = children.nodes[1];
   yield isEditingMenuDisabled(shadowChild1, inspector);
 
-  info ("Checking the <select> shadow element");
+  info("Checking the <select> shadow element");
   let shadowChild2 = children.nodes[2];
   yield isEditingMenuDisabled(shadowChild2, inspector);
 });
diff --git a/devtools/client/markupview/test/browser_markupview_anonymous_04.js b/devtools/client/markupview/test/browser_markupview_anonymous_04.js
--- a/devtools/client/markupview/test/browser_markupview_anonymous_04.js
+++ b/devtools/client/markupview/test/browser_markupview_anonymous_04.js
@@ -1,36 +1,37 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test native anonymous content in the markupview with devtools.inspector.showAllAnonymousContent
-// set to true
+// Test native anonymous content in the markupview with
+// devtools.inspector.showAllAnonymousContent set to true.
 const TEST_URL = TEST_URL_ROOT + "doc_markup_anonymous.html";
 
 add_task(function*() {
-  Services.prefs.setBoolPref("devtools.inspector.showAllAnonymousContent", true);
+  Services.prefs.setBoolPref(
+    "devtools.inspector.showAllAnonymousContent", true);
 
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   let native = yield getNodeFront("#native", inspector);
 
   // Markup looks like: <div><video controls /></div>
   let nativeChildren = yield inspector.walker.children(native);
-  is (nativeChildren.nodes.length, 1, "Children returned from walker");
+  is(nativeChildren.nodes.length, 1, "Children returned from walker");
 
-  info ("Checking the video element");
+  info("Checking the video element");
   let video = nativeChildren.nodes[0];
-  ok (!video.isAnonymous, "<video> is not anonymous");
+  ok(!video.isAnonymous, "<video> is not anonymous");
 
   let videoChildren = yield inspector.walker.children(video);
-  is (videoChildren.nodes.length, 3, "<video> has native anonymous children");
+  is(videoChildren.nodes.length, 3, "<video> has native anonymous children");
 
   for (let node of videoChildren.nodes) {
-    ok (node.isAnonymous, "Child is anonymous");
-    ok (!node._form.isXBLAnonymous, "Child is not XBL anonymous");
-    ok (!node._form.isShadowAnonymous, "Child is not shadow anonymous");
-    ok (node._form.isNativeAnonymous, "Child is native anonymous");
+    ok(node.isAnonymous, "Child is anonymous");
+    ok(!node._form.isXBLAnonymous, "Child is not XBL anonymous");
+    ok(!node._form.isShadowAnonymous, "Child is not shadow anonymous");
+    ok(node._form.isNativeAnonymous, "Child is native anonymous");
     yield isEditingMenuDisabled(node, inspector);
   }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_copy_image_data.js b/devtools/client/markupview/test/browser_markupview_copy_image_data.js
--- a/devtools/client/markupview/test/browser_markupview_copy_image_data.js
+++ b/devtools/client/markupview/test/browser_markupview_copy_image_data.js
@@ -1,73 +1,73 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Test that image nodes have the "copy data-uri" contextual menu item enabled
-// and that clicking it puts the image data into the clipboard
+// and that clicking it puts the image data into the clipboard.
 
-const PAGE_CONTENT = [
-  '<div></div>',
-  '<img class="data" src="data:image/png;base64,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" />',
-  '<canvas class="canvas" width="600" height="600"></canvas>'
-].join("\n");
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div></div>
+  <img class="data" src="data:image/png;base64,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">
+  <canvas class="canvas" width="600" height="600"></canvas>`;
 
 add_task(function*() {
-  yield addTab("data:text/html,markup view copy image as data-uri");
-  createDocument();
-  let doc = content.document;
-
-  let {inspector} = yield openInspector();
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
+  let expectedClipboard;
 
   yield selectNode("div", inspector);
   yield assertCopyImageDataNotAvailable(inspector);
 
+  expectedClipboard = yield testActor.getProperty("img", "src");
   yield selectNode("img", inspector);
   yield assertCopyImageDataAvailable(inspector);
-  yield triggerCopyImageUrlAndWaitForClipboard(doc.querySelector("img").src, inspector);
+  yield triggerCopyImageUrlAndWaitForClipboard(expectedClipboard, inspector);
 
+  yield drawOnCanvas(testActor);
+  expectedClipboard =
+    yield testActor.eval("document.querySelector('.canvas').toDataURL()");
   yield selectNode("canvas", inspector);
   yield assertCopyImageDataAvailable(inspector);
-  let canvas = doc.querySelector(".canvas");
-  yield triggerCopyImageUrlAndWaitForClipboard(canvas.toDataURL(), inspector);
+  yield triggerCopyImageUrlAndWaitForClipboard(expectedClipboard, inspector);
 
   // Check again that the menu isn't available on the DIV (to make sure our
-  // menu updating mechanism works)
+  // menu updating mechanism works).
   yield selectNode("div", inspector);
   yield assertCopyImageDataNotAvailable(inspector);
 });
 
-function createDocument() {
-  let doc = content.document;
-
-  doc.body.innerHTML = PAGE_CONTENT;
-  let context = doc.querySelector(".canvas").getContext("2d");
-  context.beginPath();
-  context.moveTo(300, 0);
-  context.lineTo(600, 600);
-  context.lineTo(0, 600);
-  context.closePath();
-  context.fillStyle = "#ffc821";
-  context.fill();
+function* drawOnCanvas(testActor) {
+  yield testActor.eval(`
+    let context = document.querySelector(".canvas").getContext("2d");
+    context.beginPath();
+    context.moveTo(300, 0);
+    context.lineTo(600, 600);
+    context.lineTo(0, 600);
+    context.closePath();
+    context.fillStyle = "#ffc821";
+    context.fill();`);
 }
 
 function assertCopyImageDataNotAvailable(inspector) {
   return openNodeMenu(inspector).then(menu => {
-    let item = menu.getElementsByAttribute("id", "node-menu-copyimagedatauri")[0];
+    let item =
+      menu.getElementsByAttribute("id", "node-menu-copyimagedatauri")[0];
     ok(item, "The menu item was found in the contextual menu");
     is(item.getAttribute("disabled"), "true", "The menu item is disabled");
   }).then(() => closeNodeMenu(inspector));
 }
 
 function assertCopyImageDataAvailable(inspector) {
   return openNodeMenu(inspector).then(menu => {
-    let item = menu.getElementsByAttribute("id", "node-menu-copyimagedatauri")[0];
+    let item =
+      menu.getElementsByAttribute("id", "node-menu-copyimagedatauri")[0];
     ok(item, "The menu item was found in the contextual menu");
     is(item.getAttribute("disabled"), "", "The menu item is enabled");
   }).then(() => closeNodeMenu(inspector));
 }
 
 function openNodeMenu(inspector) {
   let def = promise.defer();
 
@@ -93,19 +93,22 @@ function closeNodeMenu(inspector) {
 
   return def.promise;
 }
 
 function triggerCopyImageUrlAndWaitForClipboard(expected, inspector) {
   let def = promise.defer();
 
   SimpleTest.waitForClipboard(expected, () => {
-    inspector.markup.getContainer(inspector.selection.nodeFront).copyImageDataUri();
+    inspector.markup.getContainer(inspector.selection.nodeFront)
+      .copyImageDataUri();
   }, () => {
-    ok(true, "The clipboard contains the expected value " + expected.substring(0, 50) + "...");
+    ok(true, "The clipboard contains the expected value "
+      + expected.substring(0, 50) + "...");
     def.resolve();
   }, () => {
-    ok(false, "The clipboard doesn't contain the expected value " + expected.substring(0, 50) + "...");
+    ok(false, "The clipboard doesn't contain the expected value "
+      + expected.substring(0, 50) + "...");
     def.resolve();
   });
 
   return def.promise;
 }
diff --git a/devtools/client/markupview/test/browser_markupview_css_completion_style_attribute.js b/devtools/client/markupview/test/browser_markupview_css_completion_style_attribute.js
--- a/devtools/client/markupview/test/browser_markupview_css_completion_style_attribute.js
+++ b/devtools/client/markupview/test/browser_markupview_css_completion_style_attribute.js
@@ -16,16 +16,18 @@ const TEST_URL = TEST_URL_ROOT + "doc_ma
 // test data format :
 //  [
 //    what key to press,
 //    expected input box value after keypress,
 //    expected input.selectionStart,
 //    expected input.selectionEnd,
 //    is popup expected to be open ?
 //  ]
+
+/* eslint-disable quotes, max-len */
 const TEST_DATA = [
   ['s', 's', 1, 1, false],
   ['t', 'st', 2, 2, false],
   ['y', 'sty', 3, 3, false],
   ['l', 'styl', 4, 4, false],
   ['e', 'style', 5, 5, false],
   ['=', 'style=', 6, 6, false],
   ['"', 'style="', 7, 7, false],
@@ -57,31 +59,32 @@ const TEST_DATA = [
   ['c', 'style="display:  inherit; color :cadetblue ', 34, 42, true],
   ['VK_DOWN', 'style="display:  inherit; color :chartreuse ', 34, 43, true],
   ['VK_RIGHT', 'style="display:  inherit; color :chartreuse ', 43, 43, false],
   [' ', 'style="display:  inherit; color :chartreuse !important; ', 44, 55, true],
   ['!', 'style="display:  inherit; color :chartreuse !important; ', 45, 55, false],
   ['VK_RIGHT', 'style="display:  inherit; color :chartreuse !important; ', 55, 55, false],
   ['VK_RETURN', 'style="display:  inherit; color :chartreuse !important;"', -1, -1, false]
 ];
+/* eslint-enable */
 
 add_task(function*() {
   info("Opening the inspector on the test URL");
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   yield inspector.markup.expandAll();
 
   let nodeFront = yield getNodeFront("#node14", inspector);
   let container = getContainerForNodeFront(nodeFront, inspector);
   let attr = container.editor.newAttr;
   attr.focus();
   EventUtils.sendKey("return", inspector.panelWin);
   let editor = inplaceEditor(attr);
 
-  for (let i = 0; i < TEST_DATA.length; i ++) {
+  for (let i = 0; i < TEST_DATA.length; i++) {
     yield enterData(i, editor, inspector);
     yield checkData(i, editor, inspector);
   }
 
   while (inspector.markup.undo.canUndo()) {
     yield undoChange(inspector);
   }
 });
@@ -122,23 +125,26 @@ function enterData(index, editor, inspec
 }
 
 function* checkData(index, editor, inspector) {
   let [key, completion, selStart, selEnd, popupOpen] = TEST_DATA[index];
   info("Test data " + index + " entered. Checking state.");
 
   if (selEnd != -1) {
     is(editor.input.value, completion, "Completed value is correct");
-    is(editor.input.selectionStart, selStart, "Selection start position is correct");
-    is(editor.input.selectionEnd, selEnd, "Selection end position is correct");
+    is(editor.input.selectionStart, selStart,
+      "Selection start position is correct");
+    is(editor.input.selectionEnd, selEnd,
+      "Selection end position is correct");
     if (popupOpen) {
       ok(editor.popup.isOpen, "Popup is open");
     } else {
-      ok(editor.popup._panel.state != "open" && editor.popup._panel.state != "showing",
-        "Popup is closed");
+      ok(editor.popup._panel.state != "open" &&
+         editor.popup._panel.state != "showing", "Popup is closed");
     }
   } else {
     let nodeFront = yield getNodeFront("#node14", inspector);
-    let editor = getContainerForNodeFront(nodeFront, inspector).editor;
+    editor = getContainerForNodeFront(nodeFront, inspector).editor;
     let attr = editor.attrElements.get("style").querySelector(".editable");
-    is(attr.textContent, completion, "Correct value is persisted after pressing Enter");
+    is(attr.textContent, completion,
+      "Correct value is persisted after pressing Enter");
   }
 }
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_distance.js b/devtools/client/markupview/test/browser_markupview_dragdrop_distance.js
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_distance.js
+++ b/devtools/client/markupview/test/browser_markupview_dragdrop_distance.js
@@ -6,17 +6,17 @@
 
 // Test that nodes don't start dragging before the mouse has moved by at least
 // the minimum vertical distance defined in markup-view.js by
 // DRAG_DROP_MIN_INITIAL_DISTANCE.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_dragdrop.html";
 const TEST_NODE = "#test";
 
-// Keep this in sync with DRAG_DROP_MIN_INITIAL_DISTANCE in markup-view.js
+// Keep this in sync with DRAG_DROP_MIN_INITIAL_DISTANCE in markup-view.js.
 const MIN_DISTANCE = 10;
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   info("Drag the test node by half of the minimum distance");
   yield simulateNodeDrag(inspector, TEST_NODE, 0, MIN_DISTANCE / 2);
   yield checkIsDragging(inspector, TEST_NODE, false);
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js b/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js
+++ b/devtools/client/markupview/test/browser_markupview_dragdrop_reorder.js
@@ -80,22 +80,22 @@ function* dragElementToOriginalLocation(
 }
 
 function* moveElementDown(selector, next, inspector) {
   info("Switching " + selector + " with " + next);
 
   let container = yield getContainerForSelector(next, inspector);
   let height = container.tagLine.getBoundingClientRect().height;
 
-  let onMutated = inspector.once("markupmutation");
+  let onMutation = inspector.once("markupmutation");
   let uiUpdate = inspector.once("inspector-updated");
 
   yield simulateNodeDragAndDrop(inspector, selector, 0, Math.round(height) + 2);
 
-  let mutations = yield onMutated;
+  let mutations = yield onMutation;
   yield uiUpdate;
 
   is(mutations.length, 2, "2 mutations were received");
 }
 
 function* getChildrenIDsOf(parentFront, {walker}) {
   let {nodes} = yield walker.children(parentFront);
   // Filter out non-element nodes since children also returns pseudo-elements.
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_tooltip.js b/devtools/client/markupview/test/browser_markupview_dragdrop_tooltip.js
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_tooltip.js
+++ b/devtools/client/markupview/test/browser_markupview_dragdrop_tooltip.js
@@ -1,13 +1,15 @@
 "use strict";
 
 // Test that tooltips don't appear when dragging over tooltip targets.
 
-const TEST_URL = "data:text/html;charset=utf8,<img src=\"about:logo\" /><div>";
+const TEST_URL = `
+  data:text/html;charset=utf8,
+  <img src="about:logo"><div>`;
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
   let {markup} = inspector;
 
   info("Get the tooltip target element for the image's src attribute");
   let img = yield getContainerForSelector("img", inspector);
   let target = img.editor.getAttributeElement("src").querySelector(".link");
@@ -15,20 +17,20 @@ add_task(function*() {
   info("Check that the src attribute of the image is a valid tooltip target");
   let isValid = yield markup.tooltip.isValidHoverTarget(target);
   ok(isValid, "The element is a valid tooltip target");
 
   info("Start dragging the test div");
   yield simulateNodeDrag(inspector, "div");
 
   info("Now check that the src attribute of the image isn't a valid target");
-  try{
+  try {
     yield markup.tooltip.isValidHoverTarget(target);
     isValid = true;
-  } catch(e) {
+  } catch (e) {
     isValid = false;
   }
   ok(!isValid, "The element is not a valid tooltip target");
 
   info("Stop dragging the test div");
   yield simulateNodeDrop(inspector, "div");
 
   info("Check again the src attribute of the image");
diff --git a/devtools/client/markupview/test/browser_markupview_events-overflow.js b/devtools/client/markupview/test/browser_markupview_events-overflow.js
--- a/devtools/client/markupview/test/browser_markupview_events-overflow.js
+++ b/devtools/client/markupview/test/browser_markupview_events-overflow.js
@@ -1,19 +1,24 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 "use strict";
 
+// Tests that event tooltip is scrollable and inspector's viewport scrolls
+// to expanded event handler.
+
 const TEST_URL = TEST_URL_ROOT + "doc_markup_events-overflow.html";
 const TEST_DATA = [
   {
     desc: "editor overflows container",
-    initialScrollTop: -1, // scroll to bottom
-    headerToClick: 49, // last header
+    // Scroll to bottom.
+    initialScrollTop: -1,
+    // Last header.
+    headerToClick: 49,
     alignBottom: true,
     alignTop: false,
   },
   {
     desc: "header overflows the container",
     initialScrollTop: 2,
     headerToClick: 0,
     alignBottom: false,
@@ -24,24 +29,25 @@ const TEST_DATA = [
     initialScrollTop: 2,
     headerToClick: 5,
     alignBottom: false,
     alignTop: false,
   },
 ];
 
 add_task(function*() {
-  let { inspector } = yield addTab(TEST_URL).then(openInspector);
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   let markupContainer = yield getContainerForSelector("#events", inspector);
   let evHolder = markupContainer.elt.querySelector(".markupview-events");
   let tooltip = inspector.markup.tooltip;
 
   info("Clicking to open event tooltip.");
-  EventUtils.synthesizeMouseAtCenter(evHolder, {}, inspector.markup.doc.defaultView);
+  EventUtils.synthesizeMouseAtCenter(evHolder, {},
+    inspector.markup.doc.defaultView);
   yield tooltip.once("shown");
   info("EventTooltip visible.");
 
   let container = tooltip.content;
   let containerRect = container.getBoundingClientRect();
   let headers = container.querySelectorAll(".event-header");
 
   for (let data of TEST_DATA) {
@@ -70,21 +76,19 @@ add_task(function*() {
     // Wait for any scrolling to finish.
     yield promiseNextTick();
 
     if (data.alignTop) {
       let headerRect = header.getBoundingClientRect();
 
       is(Math.round(headerRect.top), Math.round(containerRect.top),
         "Clicked header is aligned with the container top.");
-
     } else if (data.alignBottom) {
       let editorRect = header.nextElementSibling.getBoundingClientRect();
 
       is(Math.round(editorRect.bottom), Math.round(containerRect.bottom),
         "Clicked event handler code is aligned with the container bottom.");
-
     } else {
       is(container.scrollTop, data.initialScrollTop,
         "Container did not scroll, as expected.");
     }
   }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_events.js b/devtools/client/markupview/test/browser_markupview_events.js
--- a/devtools/client/markupview/test/browser_markupview_events.js
+++ b/devtools/client/markupview/test/browser_markupview_events.js
@@ -31,51 +31,51 @@ const TEST_DATA = [
     expected: [
       {
         type: "mouseover",
         filename: TEST_URL + ":62",
         attributes: [
           "Capturing",
           "DOM2"
         ],
-        handler: 'function mouseoverHandler(event) {\n' +
-                 '  if (event.target.id !== "container") {\n' +
-                 '    let output = document.getElementById("output");\n' +
-                 '    output.textContent = event.target.textContent;\n' +
-                 '  }\n' +
-                 '}'
+        handler: "function mouseoverHandler(event) {\n" +
+                 "  if (event.target.id !== \"container\") {\n" +
+                 "    let output = document.getElementById(\"output\");\n" +
+                 "    output.textContent = event.target.textContent;\n" +
+                 "  }\n" +
+                 "}"
       }
     ]
   },
   {
     selector: "#multiple",
     expected: [
       {
         type: "click",
         filename: TEST_URL + ":69",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'function clickHandler(event) {\n' +
-                 '  let output = document.getElementById("output");\n' +
-                 '  output.textContent = "click";\n' +
-                 '}'
+        handler: "function clickHandler(event) {\n" +
+                 "  let output = document.getElementById(\"output\");\n" +
+                 "  output.textContent = \"click\";\n" +
+                 "}"
       },
       {
         type: "mouseup",
         filename: TEST_URL + ":78",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'function mouseupHandler(event) {\n' +
-                 '  let output = document.getElementById("output");\n' +
-                 '  output.textContent = "mouseup";\n' +
-                 '}'
+        handler: "function mouseupHandler(event) {\n" +
+                 "  let output = document.getElementById(\"output\");\n" +
+                 "  output.textContent = \"mouseup\";\n" +
+                 "}"
       }
     ]
   },
   {
     selector: "#DOM0",
     expected: [
       {
         type: "click",
@@ -93,65 +93,65 @@ const TEST_DATA = [
     expected: [
       {
         type: "click",
         filename: TEST_URL + ":89",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'handleEvent: function(blah) {\n' +
-                 '  alert("handleEvent clicked");\n' +
-                 '}'
+        handler: "handleEvent: function(blah) {\n" +
+                 "  alert(\"handleEvent clicked\");\n" +
+                 "}"
       }
     ]
   },
   {
     selector: "#fatarrow",
     expected: [
       {
         type: "click",
         filename: TEST_URL + ":57",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'event => {\n' +
-                 '  alert("Yay for the fat arrow!");\n' +
-                 '}'
+        handler: "event => {\n" +
+                 "  alert(\"Yay for the fat arrow!\");\n" +
+                 "}"
       }
     ]
   },
   {
     selector: "#boundhe",
     expected: [
       {
         type: "click",
         filename: TEST_URL + ":101",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'handleEvent: function() {\n' +
-                 '  alert("boundHandleEvent clicked");\n' +
-                 '}'
+        handler: "handleEvent: function() {\n" +
+                 "  alert(\"boundHandleEvent clicked\");\n" +
+                 "}"
       }
     ]
   },
   {
     selector: "#bound",
     expected: [
       {
         type: "click",
         filename: TEST_URL + ":74",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'function boundClickHandler(event) {\n' +
-                 '  alert("Bound event clicked");\n' +
-                 '}'
+        handler: "function boundClickHandler(event) {\n" +
+                 "  alert(\"Bound event clicked\");\n" +
+                 "}"
       }
     ]
   },
 ];
 
 add_task(runEventPopupTests);
diff --git a/devtools/client/markupview/test/browser_markupview_events_form.js b/devtools/client/markupview/test/browser_markupview_events_form.js
--- a/devtools/client/markupview/test/browser_markupview_events_form.js
+++ b/devtools/client/markupview/test/browser_markupview_events_form.js
@@ -12,17 +12,17 @@
 const TEST_PAGE_URL = TEST_URL_ROOT + "doc_markup_events_form.html";
 const TEST_ACTOR_URL = CHROME_BASE + "actor_events_form.js";
 
 var {ActorRegistryFront} = require("devtools/server/actors/actor-registry");
 var {EventsFormFront} = require(TEST_ACTOR_URL);
 
 add_task(function*() {
   info("Opening the Toolbox");
-  let {tab} = yield addTab(TEST_PAGE_URL);
+  yield addTab(TEST_PAGE_URL);
   let {toolbox} = yield openToolbox("webconsole");
 
   info("Registering test actor");
   let {registrar, front} = yield registerTestActor(toolbox);
 
   info("Selecting the Inspector panel");
   let inspector = yield toolbox.selectTool("inspector");
   let container = yield getContainerForSelector("#container", inspector);
@@ -40,20 +40,20 @@ function registerTestActor(toolbox) {
   let deferred = promise.defer();
 
   let options = {
     prefix: "eventsFormActor",
     actorClass: "EventsFormActor",
     moduleUrl: TEST_ACTOR_URL,
   };
 
-  // Register as a tab actor
+  // Register as a tab actor.
   let client = toolbox.target.client;
   registerTabActor(client, options).then(({registrar, form}) => {
-    // Attach to the registered actor
+    // Attach to the registered actor.
     let front = EventsFormFront(client, form);
     front.attach().then(() => {
       deferred.resolve({
         front: front,
         registrar: registrar,
       });
     });
   });
diff --git a/devtools/client/markupview/test/browser_markupview_html_edit_01.js b/devtools/client/markupview/test/browser_markupview_html_edit_01.js
--- a/devtools/client/markupview/test/browser_markupview_html_edit_01.js
+++ b/devtools/client/markupview/test/browser_markupview_html_edit_01.js
@@ -1,77 +1,93 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test outerHTML edition via the markup-view
+// Test outerHTML edition via the markup-view.
 
 loadHelperScript("helper_outerhtml_test_runner.js");
 
 const TEST_DATA = [
   {
     selector: "#one",
     oldHTML: '<div id="one">First <em>Div</em></div>',
     newHTML: '<div id="one">First Div</div>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront) {
-      is(pageNode.textContent, "First Div", "New div has expected text content");
-      ok(!getNode("#one em"), "No em remaining")
+    validate: function*(data, inspector, testActor) {
+      let {selector} = data;
+
+      is((yield testActor.getProperty(selector, "textContent")), "First Div",
+        "New div has expected text content");
+      ok(!(yield testActor.hasNode("#one em")), "No em remaining");
     }
   },
   {
     selector: "#removedChildren",
     oldHTML: '<div id="removedChildren">removedChild <i>Italic <b>Bold <u>Underline</u></b></i> Normal</div>',
     newHTML: '<div id="removedChildren">removedChild</div>'
   },
   {
     selector: "#addedChildren",
     oldHTML: '<div id="addedChildren">addedChildren</div>',
     newHTML: '<div id="addedChildren">addedChildren <i>Italic <b>Bold <u>Underline</u></b></i> Normal</div>'
   },
   {
     selector: "#addedAttribute",
     oldHTML: '<div id="addedAttribute">addedAttribute</div>',
     newHTML: '<div id="addedAttribute" class="important" disabled checked>addedAttribute</div>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront) {
+    validate: function*(data, inspector, testActor) {
+      let {selector, pageNodeFront, selectedNodeFront} = data;
+      let expectedOuterHTML = '<div id="addedAttribute" class="important" ' +
+                              'disabled="" checked="">addedAttribute</div>';
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-      is(pageNode.outerHTML, '<div id="addedAttribute" class="important" disabled="" checked="">addedAttribute</div>',
-            "Attributes have been added");
+      is((yield testActor.getProperty(selector, "outerHTML")),
+        expectedOuterHTML, "Attributes have been added");
     }
   },
   {
     selector: "#changedTag",
     oldHTML: '<div id="changedTag">changedTag</div>',
     newHTML: '<p id="changedTag" class="important">changedTag</p>'
   },
   {
     selector: "#siblings",
     oldHTML: '<div id="siblings">siblings</div>',
     newHTML: '<div id="siblings-before-sibling">before sibling</div>' +
              '<div id="siblings">siblings (updated)</div>' +
              '<div id="siblings-after-sibling">after sibling</div>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
-      let beforeSibling = getNode("#siblings-before-sibling");
-      let beforeSiblingFront = yield getNodeFront("#siblings-before-sibling", inspector);
-      let afterSibling = getNode("#siblings-after-sibling");
+    validate: function*(data, inspector, testActor) {
+      let {selector, selectedNodeFront} = data;
+
+      let beforeSiblingFront =
+        yield getNodeFront("#siblings-before-sibling", inspector);
+      let beforeSiblingText =
+        yield testActor.getProperty("#siblings-before-sibling", "textContent");
+      let afterSiblingText =
+        yield testActor.getProperty("#siblings-after-sibling", "textContent");
+      let selectedNodeText =
+        yield testActor.getProperty(selector, "textContent");
 
       is(beforeSiblingFront, selectedNodeFront, "Sibling has been selected");
-      is(pageNode.textContent, "siblings (updated)", "New div has expected text content");
-      is(beforeSibling.textContent, "before sibling", "Sibling has been inserted");
-      is(afterSibling.textContent, "after sibling", "Sibling has been inserted");
+      is(selectedNodeText, "siblings (updated)",
+        "New div has expected text content");
+      is(beforeSiblingText, "before sibling", "Sibling has been inserted");
+      is(afterSiblingText, "after sibling", "Sibling has been inserted");
     }
   }
 ];
 
 const TEST_URL = "data:text/html," +
   "<!DOCTYPE html>" +
   "<head><meta charset='utf-8' /></head>" +
   "<body>" +
   TEST_DATA.map(outer => outer.oldHTML).join("\n") +
   "</body>" +
   "</html>";
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
+
   inspector.markup._frame.focus();
-  yield runEditOuterHTMLTests(TEST_DATA, inspector);
+  yield runEditOuterHTMLTests(TEST_DATA, inspector, testActor);
 });
diff --git a/devtools/client/markupview/test/browser_markupview_html_edit_02.js b/devtools/client/markupview/test/browser_markupview_html_edit_02.js
--- a/devtools/client/markupview/test/browser_markupview_html_edit_02.js
+++ b/devtools/client/markupview/test/browser_markupview_html_edit_02.js
@@ -1,101 +1,127 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test outerHTML edition via the markup-view
+// Test outerHTML edition via the markup-view.
 
 loadHelperScript("helper_outerhtml_test_runner.js");
 requestLongerTimeout(2);
 
 const TEST_DATA = [
   {
     selector: "#badMarkup1",
     oldHTML: '<div id="badMarkup1">badMarkup1</div>',
     newHTML: '<div id="badMarkup1">badMarkup1</div> hanging</div>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
+    validate: function*(data, inspector, testActor) {
+      let {selector, pageNodeFront, selectedNodeFront} = data;
+
+      let textNodeNodeName = yield testActor.eval(
+        `document.querySelector("${selector}").nextSibling.nodeName`);
+      let textNodeData = yield testActor.eval(
+        `document.querySelector("${selector}").nextSibling.data`);
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-
-      let textNode = pageNode.nextSibling;
-
-      is(textNode.nodeName, "#text", "Sibling is a text element");
-      is(textNode.data, " hanging", "New text node has expected text content");
+      is(textNodeNodeName, "#text", "Sibling is a text element");
+      is(textNodeData, " hanging", "New text node has expected text content");
     }
   },
   {
     selector: "#badMarkup2",
     oldHTML: '<div id="badMarkup2">badMarkup2</div>',
     newHTML: '<div id="badMarkup2">badMarkup2</div> hanging<div></div></div></div></body>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
+    validate: function*(data, inspector, testActor) {
+      let {selector, pageNodeFront, selectedNodeFront} = data;
+
+      let textNodeNodeName = yield testActor.eval(
+        `document.querySelector("${selector}").nextSibling.nodeName`);
+      let textNodeData = yield testActor.eval(
+        `document.querySelector("${selector}").nextSibling.data`);
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-
-      let textNode = pageNode.nextSibling;
-
-      is(textNode.nodeName, "#text", "Sibling is a text element");
-      is(textNode.data, " hanging", "New text node has expected text content");
+      is(textNodeNodeName, "#text", "Sibling is a text element");
+      is(textNodeData, " hanging", "New text node has expected text content");
     }
   },
   {
     selector: "#badMarkup3",
     oldHTML: '<div id="badMarkup3">badMarkup3</div>',
     newHTML: '<div id="badMarkup3">badMarkup3 <em>Emphasized <strong> and strong</div>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
+    validate: function*(data, inspector, testActor) {
+      let {pageNodeFront, selectedNodeFront} = data;
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-
-      let em = getNode("#badMarkup3 em");
-      let strong = getNode("#badMarkup3 strong");
-
-      is(em.textContent, "Emphasized  and strong", "<em> was auto created");
-      is(strong.textContent, " and strong", "<strong> was auto created");
+      is((yield testActor.getProperty("#badMarkup3 em", "textContent")),
+        "Emphasized  and strong", "<em> was auto created");
+      is((yield testActor.getProperty("#badMarkup3 strong", "textContent")),
+        " and strong", "<strong> was auto created");
     }
   },
   {
     selector: "#badMarkup4",
     oldHTML: '<div id="badMarkup4">badMarkup4</div>',
     newHTML: '<div id="badMarkup4">badMarkup4</p>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
+    validate: function*(data, inspector, testActor) {
+      let {pageNodeFront, selectedNodeFront} = data;
+
+      let divTextContent =
+        yield testActor.getProperty("#badMarkup4", "textContent");
+      let divTagName =
+        yield testActor.getProperty("#badMarkup4", "tagName");
+      let pTextContent =
+        yield testActor.getProperty("#badMarkup4 p", "textContent");
+      let pTagName =
+        yield testActor.getProperty("#badMarkup4 p", "tagName");
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-
-      let div = getNode("#badMarkup4");
-      let p = getNode("#badMarkup4 p");
-
-      is(div.textContent, "badMarkup4", "textContent is correct");
-      is(div.tagName, "DIV", "did not change to <p> tag");
-      is(p.textContent, "", "The <p> tag has no children");
-      is(p.tagName, "P", "Created an empty <p> tag");
+      is(divTextContent, "badMarkup4", "textContent is correct");
+      is(divTagName, "DIV", "did not change to <p> tag");
+      is(pTextContent, "", "The <p> tag has no children");
+      is(pTagName, "P", "Created an empty <p> tag");
     }
   },
   {
     selector: "#badMarkup5",
     oldHTML: '<p id="badMarkup5">badMarkup5</p>',
     newHTML: '<p id="badMarkup5">badMarkup5 <div>with a nested div</div></p>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
+    validate: function*(data, inspector, testActor) {
+      let {pageNodeFront, selectedNodeFront} = data;
+      let {walker} = inspector;
+
+      let nodiv =
+        yield walker.querySelector(walker.rootNode, "#badMarkup5 div");
+      let pTagName =
+        yield testActor.getProperty("#badMarkup5", "tagName");
+      let pTextContent =
+        yield testActor.getProperty("#badMarkup5", "textContent");
+      let divTagName =
+        yield testActor.getProperty("#badMarkup5 ~ div", "tagName");
+      let divTextContent =
+        yield testActor.getProperty("#badMarkup5 ~ div", "textContent");
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-
-      let p = getNode("#badMarkup5");
-      let nodiv = getNode("#badMarkup5 div");
-      let div = getNode("#badMarkup5 ~ div");
-
       ok(!nodiv, "The invalid markup got created as a sibling");
-      is(p.textContent, "badMarkup5 ", "The <p> tag does not take in the <div> content");
-      is(p.tagName, "P", "Did not change to a <div> tag");
-      is(div.textContent, "with a nested div", "textContent is correct");
-      is(div.tagName, "DIV", "Did not change to <p> tag");
+      is(pTextContent, "badMarkup5 ",
+        "The <p> tag does not take in the <div> content");
+      is(pTagName, "P", "Did not change to a <div> tag");
+      is(divTextContent, "with a nested div", "textContent is correct");
+      is(divTagName, "DIV", "Did not change to <p> tag");
     }
   }
 ];
 
 const TEST_URL = "data:text/html," +
   "<!DOCTYPE html>" +
   "<head><meta charset='utf-8' /></head>" +
   "<body>" +
   TEST_DATA.map(outer => outer.oldHTML).join("\n") +
   "</body>" +
   "</html>";
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
+
   inspector.markup._frame.focus();
-  yield runEditOuterHTMLTests(TEST_DATA, inspector);
+  yield runEditOuterHTMLTests(TEST_DATA, inspector, testActor);
 });
diff --git a/devtools/client/markupview/test/browser_markupview_html_edit_03.js b/devtools/client/markupview/test/browser_markupview_html_edit_03.js
--- a/devtools/client/markupview/test/browser_markupview_html_edit_03.js
+++ b/devtools/client/markupview/test/browser_markupview_html_edit_03.js
@@ -2,181 +2,192 @@
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Test that outerHTML editing keybindings work as expected and that *special*
 // elements like <html>, <body> and <head> can be edited correctly.
 
-const TEST_URL = "data:text/html," +
+const TEST_URL =
+  "data:text/html," +
   "<!DOCTYPE html>" +
   "<head><meta charset='utf-8' /></head>" +
   "<body>" +
   "<div id=\"keyboard\"></div>" +
   "</body>" +
   "</html>";
 const SELECTOR = "#keyboard";
 const OLD_HTML = '<div id="keyboard"></div>';
 const NEW_HTML = '<div id="keyboard">Edited</div>';
 
 requestLongerTimeout(2);
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
-
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
   inspector.markup._frame.focus();
 
-  info("Checking that pressing escape cancels edits");
   yield testEscapeCancels(inspector);
+  yield testF2Commits(inspector);
+  yield testBody(inspector);
+  yield testHead(inspector, testActor);
 
-  info("Checking that pressing F2 commits edits");
-  yield testF2Commits(inspector);
+  yield testDocumentElement(inspector, testActor, {
+    info: "Checking that editing the <html> element works like other nodes",
+    html: '<html id="updated" foo="bar"><head><title>Updated from document element</title><script>document.body.id="executed";</script></head><body><p>Hello</p></body></html>',
+    title: "Updated from document element",
+    id: "updated",
+    class: null,
+    foo: "bar",
+    bodyTextContent: "Hello"
+  });
 
-  info("Checking that editing the <body> element works like other nodes");
-  yield testBody(inspector);
-
-  info("Checking that editing the <head> element works like other nodes");
-  yield testHead(inspector);
-
-  info("Checking that editing the <html> element works like other nodes");
-  yield testDocumentElement(inspector);
-
-  info("Checking (again) that editing the <html> element works like other nodes");
-  yield testDocumentElement2(inspector);
+  yield testDocumentElement(inspector, testActor, {
+    info: "Checking (again) that editing the <html> element works like other nodes",
+    html: '<html class="updated" id="somethingelse"><head><title>Updated again from document element</title><script>document.body.id="executed";</script></head><body><p>Hello again</p></body></html>',
+    title: "Updated again from document element",
+    id: "somethingelse",
+    class: "updated",
+    foo: null,
+    bodyTextContent: "Hello again"
+  });
 });
 
-function testEscapeCancels(inspector) {
-  let def = promise.defer();
-  let node = getNode(SELECTOR);
+function* testEscapeCancels(inspector) {
+  info("Checking that pressing escape cancels edits");
 
-  selectNode(SELECTOR, inspector).then(() => {
-    inspector.markup.htmlEditor.on("popupshown", function onPopupShown() {
-      inspector.markup.htmlEditor.off("popupshown", onPopupShown);
+  let nodeFront;
+  yield selectNode(SELECTOR, inspector);
 
-      ok(inspector.markup.htmlEditor._visible, "HTML Editor is visible");
-      is(node.outerHTML, OLD_HTML, "The node is starting with old HTML.");
+  info("Opening html editor");
+  let onPopupShown = inspector.markup.htmlEditor.once("popupshown");
+  EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
+  yield onPopupShown;
 
-      inspector.markup.htmlEditor.on("popuphidden", function onPopupHidden() {
-        inspector.markup.htmlEditor.off("popuphidden", onPopupHidden);
-        ok(!inspector.markup.htmlEditor._visible, "HTML Editor is not visible");
+  nodeFront = yield getNodeFront(SELECTOR, inspector);
+  ok(inspector.markup.htmlEditor._visible, "HTML Editor is visible");
+  is((yield inspector.markup.getNodeOuterHTML(nodeFront)), OLD_HTML,
+    "The node is starting with old HTML.");
 
-        let node = getNode(SELECTOR);
-        is(node.outerHTML, OLD_HTML, "Escape cancels edits");
-        def.resolve();
-      });
+  info("Changing text, then canceling changes");
+  let onPopupHidden = inspector.markup.htmlEditor.once("popuphidden");
+  inspector.markup.htmlEditor.editor.setText(NEW_HTML);
+  EventUtils.sendKey("ESCAPE", inspector.markup.htmlEditor.doc.defaultView);
+  yield onPopupHidden;
 
-      inspector.markup.htmlEditor.editor.setText(NEW_HTML);
-
-      EventUtils.sendKey("ESCAPE", inspector.markup.htmlEditor.doc.defaultView);
-    });
-
-    EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
-  });
-
-  return def.promise;
+  ok(!inspector.markup.htmlEditor._visible, "HTML Editor is not visible");
+  is((yield inspector.markup.getNodeOuterHTML(nodeFront)), OLD_HTML,
+    "Escape cancels edits");
 }
 
-function testF2Commits(inspector) {
-  let def = promise.defer();
-  let node = getNode(SELECTOR);
+function* testF2Commits(inspector) {
+  info("Checking that pressing F2 commits edits");
 
-  inspector.markup.htmlEditor.on("popupshown", function onPopupShown() {
-    inspector.markup.htmlEditor.off("popupshown", onPopupShown);
+  let nodeFront;
+  yield selectNode(SELECTOR, inspector);
 
-    ok(inspector.markup.htmlEditor._visible, "HTML Editor is visible");
-    is(node.outerHTML, OLD_HTML, "The node is starting with old HTML.");
+  info("Opening html editor");
+  let onPopupShown = inspector.markup.htmlEditor.once("popupshown");
+  EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
+  yield onPopupShown;
 
-    inspector.once("markupmutation", (e, aMutations) => {
-      ok(!inspector.markup.htmlEditor._visible, "HTML Editor is not visible");
+  nodeFront = yield getNodeFront(SELECTOR, inspector);
+  ok(inspector.markup.htmlEditor._visible, "HTML Editor is visible");
+  is((yield inspector.markup.getNodeOuterHTML(nodeFront)), OLD_HTML,
+    "The node is starting with old HTML.");
 
-      let node = getNode(SELECTOR);
-      is(node.outerHTML, NEW_HTML, "F2 commits edits - the node has new HTML.");
-      def.resolve();
-    });
+  info("Changing text, then commiting changes");
+  let onMutation = inspector.once("markupmutation");
+  inspector.markup.htmlEditor.editor.setText(NEW_HTML);
+  EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
+  yield onMutation;
 
-    inspector.markup.htmlEditor.editor.setText(NEW_HTML);
-    EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
-  });
-
-  inspector.markup._frame.contentDocument.documentElement.focus();
-  EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
-
-  return def.promise;
+  // Reselect nodeFront because markup was changed.
+  nodeFront = yield getNodeFront(SELECTOR, inspector);
+  ok(!inspector.markup.htmlEditor._visible, "HTML Editor is not visible");
+  is((yield inspector.markup.getNodeOuterHTML(nodeFront)), NEW_HTML,
+    "F2 commits edits - the node has new HTML.");
 }
 
 function* testBody(inspector) {
-  let body = getNode("body");
+  info("Checking that editing the <body> element works like other nodes");
+
+  let {walker} = inspector;
   let bodyHTML = '<body id="updated"><p></p></body>';
   let bodyFront = yield getNodeFront("body", inspector);
-  let doc = content.document;
 
+  info("Changing body HTML");
   let onReselected = inspector.markup.once("reselectedonremoved");
-  yield inspector.markup.updateNodeOuterHTML(bodyFront, bodyHTML, body.outerHTML);
+  yield inspector.markup.updateNodeOuterHTML(bodyFront, bodyHTML);
   yield onReselected;
 
-  is(getNode("body").outerHTML, bodyHTML, "<body> HTML has been updated");
-  is(doc.querySelectorAll("head").length, 1, "no extra <head>s have been added");
+  // Reselect bodyFront because markup was changed.
+  bodyFront = yield getNodeFront("body", inspector);
+  is((yield inspector.markup.getNodeOuterHTML(bodyFront)), bodyHTML,
+    "<body> HTML has been updated");
+  is((yield walker.querySelectorAll(walker.rootNode, "head")).length, 1,
+    "no extra <head>s have been added");
 
   yield inspector.once("inspector-updated");
 }
 
-function* testHead(inspector) {
-  let head = getNode("head");
+function* testHead(inspector, testActor) {
+  info("Checking that editing the <head> element works like other nodes");
+
+  let {walker} = inspector;
+  let headHTML = '<head id="updated"><title>New Title</title><script>document.body.id="executed";</script></head>';
+  let headFront = yield getNodeFront("head", inspector);
+
   yield selectNode("head", inspector);
 
-  let headHTML = '<head id="updated"><title>New Title</title><script>window.foo="bar";</script></head>';
-  let headFront = yield getNodeFront("head", inspector);
-  let doc = content.document;
-
+  info("Changing head HTML");
   let onReselected = inspector.markup.once("reselectedonremoved");
-  yield inspector.markup.updateNodeOuterHTML(headFront, headHTML, head.outerHTML);
+  yield inspector.markup.updateNodeOuterHTML(headFront, headHTML);
   yield onReselected;
 
-  is(doc.title, "New Title", "New title has been added");
-  is(doc.defaultView.foo, undefined, "Script has not been executed");
-  is(doc.querySelector("head").outerHTML, headHTML, "<head> HTML has been updated");
-  is(doc.querySelectorAll("body").length, 1, "no extra <body>s have been added");
+  is((yield testActor.eval("document.title")), "New Title",
+    "New title has been added");
+  is((yield testActor.hasNode("#executed")), false,
+    "Script has not been executed");
+
+  // Reselect headFront because markup was changed.
+  headFront = yield getNodeFront("head", inspector);
+  is((yield inspector.markup.getNodeOuterHTML(headFront)), headHTML,
+    "<head> HTML has been updated");
+  is((yield walker.querySelectorAll(walker.rootNode, "body")).length, 1,
+    "no extra <body>s have been added");
 
   yield inspector.once("inspector-updated");
 }
 
-function* testDocumentElement(inspector) {
-  let doc = content.document;
-  let docElement = doc.documentElement;
-  let docElementHTML = '<html id="updated" foo="bar"><head><title>Updated from document element</title><script>window.foo="bar";</script></head><body><p>Hello</p></body></html>';
+function* testDocumentElement(inspector, testActor, data) {
+  info(data.info);
+
+  let {walker} = inspector;
+  let docElementHTML = data.html;
   let docElementFront = yield inspector.markup.walker.documentElement();
 
+  info("Changing document HTML");
   let onReselected = inspector.markup.once("reselectedonremoved");
-  yield inspector.markup.updateNodeOuterHTML(docElementFront, docElementHTML, docElement.outerHTML);
+  yield inspector.markup.updateNodeOuterHTML(docElementFront, docElementHTML);
   yield onReselected;
 
-  is(doc.title, "Updated from document element", "New title has been added");
-  is(doc.defaultView.foo, undefined, "Script has not been executed");
-  is(doc.documentElement.id, "updated", "<html> ID has been updated");
-  is(doc.documentElement.className, "", "<html> class has been updated");
-  is(doc.documentElement.getAttribute("foo"), "bar", "<html> attribute has been updated");
-  is(doc.documentElement.outerHTML, docElementHTML, "<html> HTML has been updated");
-  is(doc.querySelectorAll("head").length, 1, "no extra <head>s have been added");
-  is(doc.querySelectorAll("body").length, 1, "no extra <body>s have been added");
-  is(doc.body.textContent, "Hello", "document.body.textContent has been updated");
+  is((yield testActor.eval("document.title")), data.title,
+    "New title has been added");
+  is((yield testActor.hasNode("#executed")), false,
+    "Script has not been executed");
+
+  is((yield testActor.getAttribute("html", "id")), data.id,
+    "<html> ID has been updated");
+  is((yield testActor.getAttribute("html", "class")), data.class,
+    "<html> class has been updated");
+  is((yield testActor.getAttribute("html", "foo")), data.foo,
+    "<html> attribute has been updated");
+
+  is((yield inspector.markup.getNodeOuterHTML(docElementFront)), docElementHTML,
+    "<head> HTML has been updated");
+  is((yield walker.querySelectorAll(walker.rootNode, "head")).length, 1,
+    "no extra <heads>s have been added");
+  is((yield walker.querySelectorAll(walker.rootNode, "body")).length, 1,
+    "no extra <body>s have been added");
+  is((yield testActor.eval("document.body.textContent")), data.bodyTextContent,
+    "document.body.textContent has been updated");
 }
-
-function* testDocumentElement2(inspector) {
-  let doc = content.document;
-  let docElement = doc.documentElement;
-  let docElementHTML = '<html class="updated" id="somethingelse"><head><title>Updated again from document element</title><script>window.foo="bar";</script></head><body><p>Hello again</p></body></html>';
-  let docElementFront = yield inspector.markup.walker.documentElement();
-
-  let onReselected = inspector.markup.once("reselectedonremoved");
-  inspector.markup.updateNodeOuterHTML(docElementFront, docElementHTML, docElement.outerHTML);
-  yield onReselected;
-
-  is(doc.title, "Updated again from document element", "New title has been added");
-  is(doc.defaultView.foo, undefined, "Script has not been executed");
-  is(doc.documentElement.id, "somethingelse", "<html> ID has been updated");
-  is(doc.documentElement.className, "updated", "<html> class has been updated");
-  is(doc.documentElement.getAttribute("foo"), null, "<html> attribute has been removed");
-  is(doc.documentElement.outerHTML, docElementHTML, "<html> HTML has been updated");
-  is(doc.querySelectorAll("head").length, 1, "no extra <head>s have been added");
-  is(doc.querySelectorAll("body").length, 1, "no extra <body>s have been added");
-  is(doc.body.textContent, "Hello again", "document.body.textContent has been updated");
-}
diff --git a/devtools/client/markupview/test/browser_markupview_image_tooltip.js b/devtools/client/markupview/test/browser_markupview_image_tooltip.js
--- a/devtools/client/markupview/test/browser_markupview_image_tooltip.js
+++ b/devtools/client/markupview/test/browser_markupview_image_tooltip.js
@@ -1,63 +1,58 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Test that image preview tooltips are shown on img and canvas tags in the
 // markup-view and that the tooltip actually contains an image and shows the
-// right dimension label
+// right dimension label.
 
-const PAGE_CONTENT = [
-  '<img class="local" src="chrome://branding/content/about-logo.png" />',
-  '<img class="data" src="data:image/png;base64,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" />',
-  '<img class="remote" src="' + TEST_URL_ROOT + 'doc_markup_tooltip.png" />',
-  '<canvas class="canvas" width="600" height="600"></canvas>'
-].join("\n");
+const TEST_URL = `
+  data:text/html;charset=utf8,
+  <img class="local" src="chrome://branding/content/about-logo.png">
+  <img class="data" src="data:image/png;base64,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">
+  <img class="remote" src="${TEST_URL_ROOT}/doc_markup_tooltip.png">
+  <canvas class="canvas" width="600" height="600"></canvas>`;
 
 const TEST_NODES = [
   {selector: "img.local", size: "192" + " \u00D7 " + "192"},
   {selector: "img.data", size: "64" + " \u00D7 " + "64"},
   {selector: "img.remote", size: "22" + " \u00D7 " + "23"},
   {selector: ".canvas", size: "600" + " \u00D7 " + "600"}
 ];
 
 add_task(function*() {
-  yield addTab("data:text/html,markup view tooltip test");
-  createPage();
-
-  let {inspector} = yield openInspector();
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
+  yield drawOnCanvas(testActor);
 
   info("Selecting the first <img> tag");
   yield selectNode("img", inspector);
 
   for (let testNode of TEST_NODES) {
     let target = yield getImageTooltipTarget(testNode, inspector);
     yield assertTooltipShownOn(target, inspector);
     checkImageTooltip(testNode, inspector);
   }
 });
 
-function createPage() {
-  info("Fill the page with the test content");
-  content.document.body.innerHTML = PAGE_CONTENT;
+function* drawOnCanvas(testActor) {
+  info("Fill the canvas");
 
-  info("Fill the canvas");
-  let doc = content.document;
-  let context = doc.querySelector(".canvas").getContext("2d");
-
-  context.beginPath();
-  context.moveTo(300, 0);
-  context.lineTo(600, 600);
-  context.lineTo(0, 600);
-  context.closePath();
-  context.fillStyle = "#ffc821";
-  context.fill();
+  yield testActor.eval(`
+    let context = document.querySelector(".canvas").getContext("2d");
+    context.beginPath();
+    context.moveTo(300, 0);
+    context.lineTo(600, 600);
+    context.lineTo(0, 600);
+    context.closePath();
+    context.fillStyle = "#ffc821";
+    context.fill();`);
 }
 
 function* getImageTooltipTarget({selector}, inspector) {
   let nodeFront = yield getNodeFront(selector, inspector);
   let isImg = nodeFront.tagName.toLowerCase() === "img";
 
   let container = getContainerForNodeFront(nodeFront, inspector);
 
@@ -74,12 +69,13 @@ function* assertTooltipShownOn(element, 
   ok(isValid, "The element is a valid hover target for the image tooltip");
 }
 
 function checkImageTooltip({selector, size}, {markup}) {
   let images = markup.tooltip.panel.getElementsByTagName("image");
   is(images.length, 1, "Tooltip for [" + selector + "] contains an image");
 
   let label = markup.tooltip.panel.querySelector(".devtools-tooltip-caption");
-  is(label.textContent, size, "Tooltip label for [" + selector + "] displays the right image size");
+  is(label.textContent, size,
+    "Tooltip label for [" + selector + "] displays the right image size");
 
   markup.tooltip.hide();
 }
diff --git a/devtools/client/markupview/test/browser_markupview_image_tooltip_mutations.js b/devtools/client/markupview/test/browser_markupview_image_tooltip_mutations.js
--- a/devtools/client/markupview/test/browser_markupview_image_tooltip_mutations.js
+++ b/devtools/client/markupview/test/browser_markupview_image_tooltip_mutations.js
@@ -2,26 +2,28 @@
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Test that image preview tooltip shows updated content when the image src
 // changes.
 
+const TEST_URL = `
+  data:text/html;charset=utf8,
+  <p>markup view tooltip test</p>
+  <img>`;
 const INITIAL_SRC = "data:image/png;base64,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";
 const UPDATED_SRC = TEST_URL_ROOT + "doc_markup_tooltip.png";
 
 const INITIAL_SRC_SIZE = "64" + " \u00D7 " + "64";
 const UPDATED_SRC_SIZE = "22" + " \u00D7 " + "23";
 
 add_task(function*() {
-  yield addTab("data:text/html,<p>markup view tooltip test</p><img>");
-
-  let { inspector } = yield openInspector();
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   info("Retrieving NodeFront for the <img> element.");
   let img = yield getNodeFront("img", inspector);
 
   info("Selecting the <img> element");
   yield selectNode(img, inspector);
 
   info("Adding src attribute to the image.");
@@ -47,26 +49,25 @@ add_task(function*() {
   info("Showing tooltip on the src link.");
   yield inspector.markup.tooltip.isValidHoverTarget(target);
 
   info("Checking that the new image was shown.");
   checkImageTooltip(UPDATED_SRC_SIZE, inspector);
 });
 
 /**
- * Updates the src attribute of the image. Return a Promise.
+ * Updates the src attribute of the image.
  */
-function updateImageSrc(img, newSrc, inspector) {
-  let onMutated = inspector.once("markupmutation");
-  let onModified = img.modifyAttributes([{
+function* updateImageSrc(img, newSrc, inspector) {
+  let onMutation = inspector.once("markupmutation");
+  img.modifyAttributes([{
     attributeName: "src",
     newValue: newSrc
   }]);
-
-  return Promise.all([onMutated, onModified]);
+  yield onMutation;
 }
 
 /**
  * Checks that the markup view tooltip contains an image element with the given
  * size.
  */
 function checkImageTooltip(size, {markup}) {
   let images = markup.tooltip.panel.getElementsByTagName("image");
diff --git a/devtools/client/markupview/test/browser_markupview_keybindings_01.js b/devtools/client/markupview/test/browser_markupview_keybindings_01.js
--- a/devtools/client/markupview/test/browser_markupview_keybindings_01.js
+++ b/devtools/client/markupview/test/browser_markupview_keybindings_01.js
@@ -1,36 +1,40 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Tests tabbing through attributes on a node
+// Tests tabbing through attributes on a node.
 
-const TEST_URL = "data:text/html;charset=utf8,<div a b c d e id='test'></div>";
+const TEST_URL = `
+  data:text/html;charset=utf8,
+  <div a b c d e id='test'></div>`;
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
 
   info("Focusing the tag editor of the test element");
   let {editor} = yield getContainerForSelector("div", inspector);
   editor.tag.focus();
 
   info("Pressing tab and expecting to focus the ID attribute, always first");
   EventUtils.sendKey("tab", inspector.panelWin);
   checkFocusedAttribute("id");
 
   info("Hit enter to turn the attribute to edit mode");
   EventUtils.sendKey("return", inspector.panelWin);
   checkFocusedAttribute("id", true);
 
   // Check the order of the other attributes in the DOM to the check they appear
   // correctly in the markup-view
-  let attributes = [...getNode("div").attributes].filter(attr => attr.name !== "id");
+  let attributes = (yield testActor.getAttributes("div")).filter(attr => {
+    return attr.name !== "id";
+  });
 
   info("Tabbing forward through attributes in edit mode");
   for (let {name} of attributes) {
     collapseSelectionAndTab(inspector);
     checkFocusedAttribute(name, true);
   }
 
   info("Tabbing backward through attributes in edit mode");
diff --git a/devtools/client/markupview/test/browser_markupview_keybindings_02.js b/devtools/client/markupview/test/browser_markupview_keybindings_02.js
--- a/devtools/client/markupview/test/browser_markupview_keybindings_02.js
+++ b/devtools/client/markupview/test/browser_markupview_keybindings_02.js
@@ -1,18 +1,20 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Tests that pressing ESC when a node in the markup-view is focused toggles
-// the split-console (see bug 988278)
+// the split-console (see bug 988278).
 
-const TEST_URL = "data:text/html;charset=utf8,<div></div>";
+const TEST_URL = `
+  data:text/html;charset=utf8,
+  <div></div>`;
 
 add_task(function*() {
   let {inspector, toolbox} = yield addTab(TEST_URL).then(openInspector);
 
   info("Focusing the tag editor of the test element");
   let {editor} = yield getContainerForSelector("div", inspector);
   editor.tag.focus();
 
diff --git a/devtools/client/markupview/test/browser_markupview_keybindings_03.js b/devtools/client/markupview/test/browser_markupview_keybindings_03.js
--- a/devtools/client/markupview/test/browser_markupview_keybindings_03.js
+++ b/devtools/client/markupview/test/browser_markupview_keybindings_03.js
@@ -3,20 +3,22 @@
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Tests that selecting a node with the mouse (by clicking on the line) focuses
 // the first focusable element in the corresponding MarkupContainer so that the
 // keyboard can be used immediately.
 
-const TEST_URL = "data:text/html;charset=utf8,<div class='test-class'></div>Text node";
+const TEST_URL = `
+  data:text/html;charset=utf8,
+  <div class='test-class'></div>Text node`;
 
 add_task(function*() {
-  let {inspector, toolbox} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
   let {walker} = inspector;
 
   info("Select the test node to have the 2 test containers visible");
   yield selectNode("div", inspector);
 
   let divFront = yield walker.querySelector(walker.rootNode, "div");
   let textFront = yield walker.nextSibling(divFront);
 
@@ -29,17 +31,18 @@ add_task(function*() {
   info("Click on the MarkupContainer element for the <div> node");
   yield clickContainer(divFront, inspector);
   is(inspector.markup.doc.activeElement,
      getContainerForNodeFront(divFront, inspector).editor.tag,
      "The currently focused element is the div's tagname");
 
   info("Click on the test-class attribute, to make sure it gets focused");
   let editor = getContainerForNodeFront(divFront, inspector).editor;
-  let attributeEditor = editor.attrElements.get("class").querySelector(".editable");
+  let attributeEditor =
+    editor.attrElements.get("class").querySelector(".editable");
 
   let onFocus = once(attributeEditor, "focus");
   EventUtils.synthesizeMouseAtCenter(attributeEditor, {type: "mousedown"},
     inspector.markup.doc.defaultView);
   EventUtils.synthesizeMouseAtCenter(attributeEditor, {type: "mouseup"},
     inspector.markup.doc.defaultView);
   yield onFocus;
 
diff --git a/devtools/client/markupview/test/browser_markupview_keybindings_04.js b/devtools/client/markupview/test/browser_markupview_keybindings_04.js
--- a/devtools/client/markupview/test/browser_markupview_keybindings_04.js
+++ b/devtools/client/markupview/test/browser_markupview_keybindings_04.js
@@ -7,17 +7,17 @@
 
 // Tests that selecting a node using the browser context menu (inspect element)
 // or the element picker focuses that node so that the keyboard can be used
 // immediately.
 
 const TEST_URL = "data:text/html;charset=utf8,<div>test element</div>";
 
 add_task(function*() {
-  let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   info("Select the test node with the browser ctx menu");
   yield selectWithBrowserMenu(inspector);
   assertNodeSelected(inspector, "div");
 
   info("Press arrowUp to focus <body> " +
        "(which works if the node was focused properly)");
   yield selectPreviousNodeWithArrowUp(inspector);
@@ -33,35 +33,36 @@ add_task(function*() {
   assertNodeSelected(inspector, "body");
 });
 
 function assertNodeSelected(inspector, tagName) {
   is(inspector.selection.nodeFront.tagName.toLowerCase(), tagName,
     `The <${tagName}> node is selected`);
 }
 
-function selectPreviousNodeWithArrowUp(inspector) {
-  let onNodeHighlighted = inspector.toolbox.once("node-highlight");
+function* selectPreviousNodeWithArrowUp(inspector) {
   let onUpdated = inspector.once("inspector-updated");
   EventUtils.synthesizeKey("VK_UP", {});
-  return Promise.all([onUpdated, onNodeHighlighted]);
+  yield onUpdated;
 }
 
 function* selectWithBrowserMenu(inspector) {
   yield BrowserTestUtils.synthesizeMouseAtCenter("div", {
     type: "contextmenu",
     button: 2
   }, gBrowser.selectedBrowser);
 
   // nsContextMenu also requires the popupNode to be set, but we can't set it to
   // node under e10s as it's a CPOW, not a DOM node. But under e10s,
   // nsContextMenu won't use the property anyway, so just try/catching is ok.
   try {
-    document.popupNode = getNode("div");
-  } catch (e) {}
+    document.popupNode = content.document.querySelector("div");
+  } catch (e) {
+    return;
+  }
 
   let contentAreaContextMenu = document.querySelector("#contentAreaContextMenu");
   let contextMenu = new nsContextMenu(contentAreaContextMenu);
   yield contextMenu.inspectNode();
 
   contentAreaContextMenu.hidden = true;
   contentAreaContextMenu.hidePopup();
   contextMenu.hiding();
diff --git a/devtools/client/markupview/test/browser_markupview_links_01.js b/devtools/client/markupview/test/browser_markupview_links_01.js
--- a/devtools/client/markupview/test/browser_markupview_links_01.js
+++ b/devtools/client/markupview/test/browser_markupview_links_01.js
@@ -106,19 +106,22 @@ add_task(function*() {
 
   for (let {selector, attributes} of TEST_DATA) {
     info("Testing attributes on node " + selector);
     yield selectNode(selector, inspector);
     let {editor} = yield getContainerForSelector(selector, inspector);
 
     for (let {attributeName, links} of attributes) {
       info("Testing attribute " + attributeName);
-      let linkEls = editor.attrElements.get(attributeName).querySelectorAll(".link");
+      let linkEls =
+        editor.attrElements.get(attributeName).querySelectorAll(".link");
 
       is(linkEls.length, links.length, "The right number of links were found");
 
-      for (let i = 0; i < links.length; i ++) {
-        is(linkEls[i].dataset.type, links[i].type, "Link " + i + " has the right type");
-        is(linkEls[i].textContent, links[i].value, "Link " + i + " has the right value");
+      for (let i = 0; i < links.length; i++) {
+        is(linkEls[i].dataset.type, links[i].type,
+          "Link " + i + " has the right type");
+        is(linkEls[i].textContent, links[i].value,
+          "Link " + i + " has the right value");
       }
     }
   }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_links_03.js b/devtools/client/markupview/test/browser_markupview_links_03.js
--- a/devtools/client/markupview/test/browser_markupview_links_03.js
+++ b/devtools/client/markupview/test/browser_markupview_links_03.js
@@ -7,31 +7,31 @@
 // Tests that links appear correctly in attributes created in content.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_links.html";
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   info("Adding a contextmenu attribute to the body node via the content");
-  let onMutated = inspector.once("markupmutation");
+  let onMutation = inspector.once("markupmutation");
   yield setNodeAttribute("body", "contextmenu", "menu1");
-  yield onMutated;
+  yield onMutation;
 
   info("Checking for links in the new attribute");
   let {editor} = yield getContainerForSelector("body", inspector);
   let linkEls = editor.attrElements.get("contextmenu").querySelectorAll(".link");
   is(linkEls.length, 1, "There is one link in the contextmenu attribute");
   is(linkEls[0].dataset.type, "idref", "The link has the right type");
   is(linkEls[0].textContent, "menu1", "The link has the right value");
 
   info("Editing the contextmenu attribute on the body node");
-  onMutated = inspector.once("markupmutation");
+  onMutation = inspector.once("markupmutation");
   yield setNodeAttribute("body", "contextmenu", "menu2");
-  yield onMutated;
+  yield onMutation;
 
   info("Checking for links in the updated attribute");
   ({editor} = yield getContainerForSelector("body", inspector));
   linkEls = editor.attrElements.get("contextmenu").querySelectorAll(".link");
   is(linkEls.length, 1, "There is one link in the contextmenu attribute");
   is(linkEls[0].dataset.type, "idref", "The link has the right type");
   is(linkEls[0].textContent, "menu2", "The link has the right value");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_links_04.js b/devtools/client/markupview/test/browser_markupview_links_04.js
--- a/devtools/client/markupview/test/browser_markupview_links_04.js
+++ b/devtools/client/markupview/test/browser_markupview_links_04.js
@@ -23,26 +23,30 @@ const TOOLBOX_STRINGS = Services.strings
 // - linkFollowItemLabel: the expected label of the follow-link item
 // - linkCopyItemLabel: the expected label of the copy-link item
 const TEST_DATA = [{
   selector: "link",
   attributeName: "href",
   popupNodeSelector: ".link",
   isLinkFollowItemVisible: true,
   isLinkCopyItemVisible: true,
-  linkFollowItemLabel: TOOLBOX_STRINGS.GetStringFromName("toolbox.viewCssSourceInStyleEditor.label"),
-  linkCopyItemLabel: STRINGS.GetStringFromName("inspector.menu.copyUrlToClipboard.label")
+  linkFollowItemLabel:
+    TOOLBOX_STRINGS.GetStringFromName("toolbox.viewCssSourceInStyleEditor.label"),
+  linkCopyItemLabel:
+    STRINGS.GetStringFromName("inspector.menu.copyUrlToClipboard.label")
 }, {
   selector: "link[rel=icon]",
   attributeName: "href",
   popupNodeSelector: ".link",
   isLinkFollowItemVisible: true,
   isLinkCopyItemVisible: true,
-  linkFollowItemLabel: STRINGS.GetStringFromName("inspector.menu.openUrlInNewTab.label"),
-  linkCopyItemLabel: STRINGS.GetStringFromName("inspector.menu.copyUrlToClipboard.label")
+  linkFollowItemLabel:
+    STRINGS.GetStringFromName("inspector.menu.openUrlInNewTab.label"),
+  linkCopyItemLabel:
+    STRINGS.GetStringFromName("inspector.menu.copyUrlToClipboard.label")
 }, {
   selector: "link",
   attributeName: "rel",
   popupNodeSelector: ".attr-value",
   isLinkFollowItemVisible: false,
   isLinkCopyItemVisible: false
 }, {
   selector: "output",
@@ -53,18 +57,20 @@ const TEST_DATA = [{
   linkFollowItemLabel: STRINGS.formatStringFromName(
     "inspector.menu.selectElement.label", ["name"], 1)
 }, {
   selector: "script",
   attributeName: "src",
   popupNodeSelector: ".link",
   isLinkFollowItemVisible: true,
   isLinkCopyItemVisible: true,
-  linkFollowItemLabel: TOOLBOX_STRINGS.GetStringFromName("toolbox.viewJsSourceInDebugger.label"),
-  linkCopyItemLabel: STRINGS.GetStringFromName("inspector.menu.copyUrlToClipboard.label")
+  linkFollowItemLabel:
+    TOOLBOX_STRINGS.GetStringFromName("toolbox.viewJsSourceInDebugger.label"),
+  linkCopyItemLabel:
+    STRINGS.GetStringFromName("inspector.menu.copyUrlToClipboard.label")
 }, {
   selector: "p[for]",
   attributeName: "for",
   popupNodeSelector: ".attr-value",
   isLinkFollowItemVisible: false,
   isLinkCopyItemVisible: false
 }];
 
diff --git a/devtools/client/markupview/test/browser_markupview_links_05.js b/devtools/client/markupview/test/browser_markupview_links_05.js
--- a/devtools/client/markupview/test/browser_markupview_links_05.js
+++ b/devtools/client/markupview/test/browser_markupview_links_05.js
@@ -62,18 +62,18 @@ add_task(function*() {
 
   ok(true, "The node selection failed");
   is(inspector.selection.nodeFront.tagName.toLowerCase(), "output",
     "The <output> node is still selected");
 });
 
 function waitForTabLoad(tab) {
   let def = promise.defer();
-  tab.addEventListener("load", function onLoad(e) {
-    // Skip load event for about:blank
+  tab.addEventListener("load", function onLoad() {
+    // Skip load event for about:blank.
     if (tab.linkedBrowser.currentURI.spec === "about:blank") {
       return;
     }
     tab.removeEventListener("load", onLoad);
     def.resolve();
   });
   return def.promise;
 }
diff --git a/devtools/client/markupview/test/browser_markupview_links_06.js b/devtools/client/markupview/test/browser_markupview_links_06.js
--- a/devtools/client/markupview/test/browser_markupview_links_06.js
+++ b/devtools/client/markupview/test/browser_markupview_links_06.js
@@ -21,17 +21,17 @@ add_task(function*() {
   inspector.panelDoc.popupNode = popupNode;
 
   info("Follow the link and wait for the style-editor to open");
   let onStyleEditorReady = toolbox.once("styleeditor-ready");
   inspector.onFollowLink();
   yield onStyleEditorReady;
 
   // No real need to test that the editor opened on the right file here as this
-  // is already tested in /framework/test/browser_toolbox_view_source_*
+  // is already tested in /framework/test/browser_toolbox_view_source_*.
   ok(true, "The style-editor was open");
 
   info("Switch back to the inspector");
   yield toolbox.selectTool("inspector");
 
   info("Select a node with a jsresource attribute");
   yield selectNode("script", inspector);
 
@@ -41,11 +41,11 @@ add_task(function*() {
   inspector.panelDoc.popupNode = popupNode;
 
   info("Follow the link and wait for the debugger to open");
   let onDebuggerReady = toolbox.once("jsdebugger-ready");
   inspector.onFollowLink();
   yield onDebuggerReady;
 
   // No real need to test that the debugger opened on the right file here as
-  // this is already tested in /framework/test/browser_toolbox_view_source_*
+  // this is already tested in /framework/test/browser_toolbox_view_source_*.
   ok(true, "The debugger was open");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_links_07.js b/devtools/client/markupview/test/browser_markupview_links_07.js
--- a/devtools/client/markupview/test/browser_markupview_links_07.js
+++ b/devtools/client/markupview/test/browser_markupview_links_07.js
@@ -32,17 +32,18 @@ add_task(function*() {
 
   info("Find the link element from the markup-view that contains the ref");
   ({editor} = yield getContainerForSelector("label", inspector));
   linkEl = editor.attrElements.get("for").querySelector(".link");
 
   info("Follow link with middle-click, wait for new node to be selected.");
   yield followLinkWaitForNewNode(linkEl, false, inspector);
 
-  // We have to re-select the label as the link switched the currently selected node
+  // We have to re-select the label as the link switched
+  // the currently selected node.
   yield selectNode("label", inspector);
 
   info("Follow link with ctrl/meta-click, wait for new node to be selected.");
   yield followLinkWaitForNewNode(linkEl, true, inspector);
 
   info("Select a node with an invalid IDREF attribute");
   yield selectNode("output", inspector);
 
@@ -55,17 +56,17 @@ add_task(function*() {
 
   info("Try to follow link wiith meta/ctrl-click, check no new node selected");
   yield followLinkNoNewNode(linkEl, true, inspector);
 });
 
 function waitForTabLoad(tab) {
   let def = promise.defer();
   tab.addEventListener("load", function onLoad() {
-    // Skip load event for about:blank
+    // Skip load event for about:blank.
     if (tab.linkedBrowser.currentURI.spec === "about:blank") {
       return;
     }
     tab.removeEventListener("load", onLoad);
     def.resolve();
   });
   return def.promise;
 }
diff --git a/devtools/client/markupview/test/browser_markupview_load_01.js b/devtools/client/markupview/test/browser_markupview_load_01.js
--- a/devtools/client/markupview/test/browser_markupview_load_01.js
+++ b/devtools/client/markupview/test/browser_markupview_load_01.js
@@ -1,17 +1,17 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Tests that selecting an element with the 'Inspect Element' context
 // menu during a page reload doesn't cause the markup view to become empty.
-// See https://bugzilla.mozilla.org/show_bug.cgi?id=1036324
+// See https://bugzilla.mozilla.org/show_bug.cgi?id=1036324.
 
 const server = createTestHTTPServer();
 
 // Register a slow image handler so we can simulate a long time between
 // a reload and the load event firing.
 server.registerContentType("gif", "image/gif");
 server.registerPathHandler("/slow.gif", function (metadata, response) {
   info ("Image has been requested");
diff --git a/devtools/client/markupview/test/browser_markupview_mutation_01.js b/devtools/client/markupview/test/browser_markupview_mutation_01.js
--- a/devtools/client/markupview/test/browser_markupview_mutation_01.js
+++ b/devtools/client/markupview/test/browser_markupview_mutation_01.js
@@ -12,203 +12,196 @@ const TEST_URL = TEST_URL_ROOT + "doc_ma
 // - desc: for logging only
 // - numMutations: how many mutations are expected to come happen due to the
 //   test case.  Defaults to 1 if not set.
 // - test: a function supposed to mutate the DOM
 // - check: a function supposed to test that the mutation was handled
 const TEST_DATA = [
   {
     desc: "Adding an attribute",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.setAttribute("newattr", "newattrval");
+    test: function*(testActor) {
+      yield testActor.setAttribute("#node1", "newattr", "newattrval");
     },
     check: function*(inspector) {
       let {editor} = yield getContainerForSelector("#node1", inspector);
       ok([...editor.attrList.querySelectorAll(".attreditor")].some(attr => {
         return attr.textContent.trim() === "newattr=\"newattrval\"";
       }), "newattr attribute found");
     }
   },
   {
     desc: "Removing an attribute",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.removeAttribute("newattr");
+    test: function*(testActor) {
+      yield testActor.removeAttribute("#node1", "newattr");
     },
     check: function*(inspector) {
       let {editor} = yield getContainerForSelector("#node1", inspector);
       ok(![...editor.attrList.querySelectorAll(".attreditor")].some(attr => {
         return attr.textContent.trim() === "newattr=\"newattrval\"";
       }), "newattr attribute removed");
     }
   },
   {
     desc: "Re-adding an attribute",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.setAttribute("newattr", "newattrval");
+    test: function*(testActor) {
+      yield testActor.setAttribute("#node1", "newattr", "newattrval");
     },
     check: function*(inspector) {
       let {editor} = yield getContainerForSelector("#node1", inspector);
       ok([...editor.attrList.querySelectorAll(".attreditor")].some(attr => {
         return attr.textContent.trim() === "newattr=\"newattrval\"";
       }), "newattr attribute found");
     }
   },
   {
     desc: "Changing an attribute",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.setAttribute("newattr", "newattrchanged");
+    test: function*(testActor) {
+      yield testActor.setAttribute("#node1", "newattr", "newattrchanged");
     },
     check: function*(inspector) {
       let {editor} = yield getContainerForSelector("#node1", inspector);
       ok([...editor.attrList.querySelectorAll(".attreditor")].some(attr => {
         return attr.textContent.trim() === "newattr=\"newattrchanged\"";
       }), "newattr attribute found");
     }
   },
   {
     desc: "Adding ::after element",
-    numMutations: 2,
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.classList.add("pseudo");
+    numMutations: 5,
+    test: function*(testActor) {
+      yield testActor.addClass("#node1", "pseudo");
     },
     check: function*(inspector) {
       let {children} = yield getContainerForSelector("#node1", inspector);
       is(children.childNodes.length, 2,
         "Node1 now has 2 children (text child and ::after");
     }
   },
   {
     desc: "Removing ::after element",
-    numMutations: 2,
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.classList.remove("pseudo");
+    numMutations: 5,
+    test: function*(testActor) {
+      yield testActor.removeClass("#node1", "pseudo");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(container.singleTextChild, "Has single text child.");
     }
   },
   {
     desc: "Updating the text-content",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.textContent = "newtext";
+    test: function*(testActor) {
+      yield testActor.setProperty("#node1", "textContent", "newtext");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(container.singleTextChild, "Has single text child.");
       ok(!container.canExpand, "Can't expand container with singleTextChild.");
       ok(!container.singleTextChild.canExpand, "Can't expand singleTextChild.");
       is(container.editor.elt.querySelector(".text").textContent.trim(), "newtext",
         "Single text child editor updated.");
     }
   },
   {
     desc: "Adding a second text child",
-    test: () => {
-      let node1 = getNode("#node1");
-      let newText = node1.ownerDocument.createTextNode("more");
-      node1.appendChild(newText);
+    test: function*(testActor) {
+      yield testActor.eval(`
+        let node = document.querySelector("#node1");
+        let newText = node.ownerDocument.createTextNode("more");
+        node.appendChild(newText);`);
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(!container.singleTextChild, "Does not have single text child.");
       ok(container.canExpand, "Can expand container with child nodes.");
       ok(container.editor.elt.querySelector(".text") == null,
         "Single text child editor removed.");
     },
   },
   {
     desc: "Go from 2 to 1 text child",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.textContent = "newtext";
+    test: function*(testActor) {
+      yield testActor.setProperty("#node1", "textContent", "newtext");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(container.singleTextChild, "Has single text child.");
       ok(!container.canExpand, "Can't expand container with singleTextChild.");
       ok(!container.singleTextChild.canExpand, "Can't expand singleTextChild.");
       ok(container.editor.elt.querySelector(".text").textContent.trim(), "newtext",
         "Single text child editor updated.");
     },
   },
   {
     desc: "Removing an only text child",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.innerHTML = "";
+    test: function*(testActor) {
+      yield testActor.setProperty("#node1", "innerHTML", "");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(!container.singleTextChild, "Does not have single text child.");
       ok(!container.canExpand, "Can't expand empty container.");
       ok(container.editor.elt.querySelector(".text") == null,
         "Single text child editor removed.");
     },
   },
   {
     desc: "Go from 0 to 1 text child",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.textContent = "newtext";
+    test: function*(testActor) {
+      yield testActor.setProperty("#node1", "textContent", "newtext");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(container.singleTextChild, "Has single text child.");
       ok(!container.canExpand, "Can't expand container with singleTextChild.");
       ok(!container.singleTextChild.canExpand, "Can't expand singleTextChild.");
       ok(container.editor.elt.querySelector(".text").textContent.trim(), "newtext",
         "Single text child editor updated.");
     },
   },
 
   {
     desc: "Updating the innerHTML",
-    test: () => {
-      let node2 = getNode("#node2");
-      node2.innerHTML = "<div><span>foo</span></div>";
+    test: function*(testActor) {
+      yield testActor.setProperty("#node2", "innerHTML",
+        "<div><span>foo</span></div>");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node2", inspector);
 
       let openTags = container.children.querySelectorAll(".open .tag");
       is(openTags.length, 2, "There are 2 tags in node2");
       is(openTags[0].textContent.trim(), "div", "The first tag is a div");
       is(openTags[1].textContent.trim(), "span", "The second tag is a span");
 
       is(container.children.querySelector(".text").textContent.trim(), "foo",
         "The span's textcontent is correct");
     }
   },
   {
     desc: "Removing child nodes",
-    test: () => {
-      let node4 = getNode("#node4");
-      while (node4.firstChild) {
-        node4.removeChild(node4.firstChild);
-      }
+    test: function*(testActor) {
+      yield testActor.eval(`
+        let node = document.querySelector("#node4");
+        while (node.firstChild) {
+          node.removeChild(node.firstChild);
+        }`);
     },
     check: function*(inspector) {
       let {children} = yield getContainerForSelector("#node4", inspector);
       is(children.innerHTML, "", "Children have been removed");
     }
   },
   {
     desc: "Appending a child to a different parent",
-    test: () => {
-      let node17 = getNode("#node17");
-      let node2 = getNode("#node2");
-      node2.appendChild(node17);
+    test: function*(testActor) {
+      yield testActor.eval(`
+        let node2 = document.querySelector("#node2");
+        let node17 = document.querySelector("#node17");
+        node2.appendChild(node17);`);
     },
     check: function*(inspector) {
       let {children} = yield getContainerForSelector("#node16", inspector);
       is(children.innerHTML, "", "Node17 has been removed from its node16 parent");
 
       let container = yield getContainerForSelector("#node2", inspector);
       let openTags = container.children.querySelectorAll(".open .tag");
       is(openTags.length, 3, "There are now 3 tags in node2");
@@ -225,24 +218,24 @@ const TEST_DATA = [
     //        node21
     // will become:
     // body
     //   node1
     //     node20
     //      node21
     //      node18
     //        node19
-    test: () => {
-      let node18 = getNode("#node18");
-      let node20 = getNode("#node20");
+    test: function*(testActor) {
+      yield testActor.eval(`
+        let node1 = document.querySelector("#node1");
+        let node18 = document.querySelector("#node18");
+        let node20 = document.querySelector("#node20");
 
-      let node1 = getNode("#node1");
-
-      node1.appendChild(node20);
-      node20.appendChild(node18);
+        node1.appendChild(node20);
+        node20.appendChild(node18);`);
     },
     check: function*(inspector) {
       yield inspector.markup.expandAll();
 
       let {children} = yield getContainerForSelector("#node1", inspector);
       is(children.childNodes.length, 2,
         "Node1 now has 2 children (textnode and node20)");
 
@@ -258,43 +251,38 @@ const TEST_DATA = [
       let node18 = node20Children.childNodes[1];
       is(node18.querySelector(".open .attreditor .attr-value").textContent.trim(),
         "node18", "Node20's second child is indeed node18");
     }
   }
 ];
 
 add_task(function*() {
-  let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
 
   info("Expanding all markup-view nodes");
   yield inspector.markup.expandAll();
 
   for (let {desc, test, check, numMutations} of TEST_DATA) {
     info("Starting test: " + desc);
 
     numMutations = numMutations || 1;
 
     info("Executing the test markup mutation");
-    yield new Promise((resolve) => {
-      // If a test expects more than one mutation it may come through in a
-      // single event or possibly in multiples.
-      let seenMutations = 0;
-      inspector.on("markupmutation", function onmutation(e, mutations) {
-        seenMutations += mutations.length;
-        info("Receieved " + seenMutations +
-             " mutations, expecting at least " + numMutations);
-        if (seenMutations >= numMutations) {
-          inspector.off("markupmutation", onmutation);
-          resolve();
-        }
-      });
-
-      test();
-    })
+    // If a test expects more than one mutation it may come through in a
+    // single event or possibly in multiples.
+    let seenMutations = 0;
+    while (seenMutations < numMutations) {
+      let onMutation = inspector.once("markupmutation");
+      yield test(testActor);
+      let mutations = yield onMutation;
+      seenMutations += mutations.length;
+      info("Receieved " + seenMutations +
+           " mutations, expecting at least " + numMutations);
+    }
 
     info("Expanding all markup-view nodes to make sure new nodes are imported");
     yield inspector.markup.expandAll();
 
     info("Checking the markup-view content");
     yield check(inspector);
   }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_mutation_02.js b/devtools/client/markupview/test/browser_markupview_mutation_02.js
--- a/devtools/client/markupview/test/browser_markupview_mutation_02.js
+++ b/devtools/client/markupview/test/browser_markupview_mutation_02.js
@@ -1,121 +1,130 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Test that markup-containers in the markup-view do flash when their
-// corresponding DOM nodes mutate
+// corresponding DOM nodes mutate.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_flashing.html";
 
 // The test data contains a list of mutations to test.
 // Each item is an object:
 // - desc: a description of the test step, for better logging
 // - mutate: a function that should make changes to the content DOM
-// - attribute: if set, the test will expect the corresponding attribute to flash
-//   instead of the whole node
+// - attribute: if set, the test will expect the corresponding attribute
+//   to flash instead of the whole node
 // - flashedNode: [optional] the css selector of the node that is expected to
 //   flash in the markup-view as a result of the mutation.
 //   If missing, the rootNode (".list") will be expected to flash
 const TEST_DATA = [{
   desc: "Adding a new node should flash the new node",
-  mutate: (doc, rootNode) => {
-    let newLi = doc.createElement("LI");
-    newLi.textContent = "new list item";
-    rootNode.appendChild(newLi);
+  mutate: function*(testActor) {
+    yield testActor.eval(`
+      let rootNode = document.querySelector(".list");
+      let newLi = document.createElement("LI");
+      newLi.textContent = "new list item";
+      rootNode.appendChild(newLi);`);
   },
   flashedNode: ".list li:nth-child(3)"
 }, {
   desc: "Removing a node should flash its parent",
-  mutate: (doc, rootNode) => {
-    rootNode.removeChild(rootNode.lastElementChild);
+  mutate: function*(testActor) {
+    yield testActor.eval(`
+      let rootNode = document.querySelector(".list");
+      rootNode.removeChild(rootNode.lastElementChild);`);
   }
 }, {
   desc: "Re-appending an existing node should only flash this node",
-  mutate: (doc, rootNode) => {
-    rootNode.appendChild(rootNode.firstElementChild);
+  mutate: function*(testActor) {
+    yield testActor.eval(`
+      let rootNode = document.querySelector(".list");
+      rootNode.appendChild(rootNode.firstElementChild);`);
   },
   flashedNode: ".list .item:last-child"
 }, {
   desc: "Adding an attribute should flash the attribute",
   attribute: "test-name",
-  mutate: (doc, rootNode) => {
-    rootNode.setAttribute("test-name", "value-" + Date.now());
+  mutate: function*(testActor) {
+    yield testActor.setAttribute(".list", "test-name", "value-" + Date.now());
   }
 }, {
   desc: "Editing an attribute should flash the attribute",
   attribute: "class",
-  mutate: (doc, rootNode) => {
-    rootNode.setAttribute("class", "list value-" + Date.now());
+  mutate: function*(testActor) {
+    yield testActor.setAttribute(".list", "class", "list value-" + Date.now());
   }
 }, {
   desc: "Multiple changes to an attribute should flash the attribute",
   attribute: "class",
-  mutate: (doc, rootNode) => {
-    rootNode.removeAttribute("class");
-    rootNode.setAttribute("class", "list value-" + Date.now());
-    rootNode.setAttribute("class", "list value-" + Date.now());
-    rootNode.removeAttribute("class");
-    rootNode.setAttribute("class", "list value-" + Date.now());
-    rootNode.setAttribute("class", "list value-" + Date.now());
+  mutate: function*(testActor) {
+    yield testActor.eval(`
+      let rootNode = document.querySelector(".list");
+      rootNode.removeAttribute("class");
+      rootNode.setAttribute("class", "list value-" + Date.now());
+      rootNode.setAttribute("class", "list value-" + Date.now());
+      rootNode.removeAttribute("class");
+      rootNode.setAttribute("class", "list value-" + Date.now());
+      rootNode.setAttribute("class", "list value-" + Date.now());`);
   }
 }, {
   desc: "Removing an attribute should flash the node",
-  mutate: (doc, rootNode) => {
-    rootNode.removeAttribute("class");
+  mutate: function*(testActor) {
+    yield testActor.removeAttribute(".list", "class");
   }
 }];
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
 
   // Make sure mutated nodes flash for a very long time so we can more easily
-  // assert they do
+  // assert they do.
   inspector.markup.CONTAINER_FLASHING_DURATION = 1000 * 60 * 60;
 
-  info("Getting the <ul.list> root node to test mutations on");
-  let rootNode = getNode(".list");
+  info("Getting the <ul.list> nodeFront to test mutations on");
   let rootNodeFront = yield getNodeFront(".list", inspector);
 
   info("Selecting the last element of the root node before starting");
   yield selectNode(".list .item:nth-child(2)", inspector);
 
   for (let {mutate, flashedNode, desc, attribute} of TEST_DATA) {
     info("Starting test: " + desc);
 
     info("Mutating the DOM and listening for markupmutation event");
-    let mutated = inspector.once("markupmutation");
-    mutate(content.document, rootNode);
-    yield mutated;
+    let onMutation = inspector.once("markupmutation");
+    yield mutate(testActor);
+    yield onMutation;
 
     info("Asserting that the correct markup-container is flashing");
-    let flashingNodeFront = rootNodeFront;
-    if (flashedNode) {
-      flashingNodeFront = yield getNodeFront(flashedNode, inspector);
-    }
+    let flashingNodeFront = flashedNode
+                            ? yield getNodeFront(flashedNode, inspector)
+                            : rootNodeFront;
 
     if (attribute) {
       yield assertAttributeFlashing(flashingNodeFront, attribute, inspector);
     } else {
       yield assertNodeFlashing(flashingNodeFront, inspector);
     }
   }
+
+  // Make sure that all connections are completed.
+  yield inspector.once("inspector-updated");
 });
 
 function* assertNodeFlashing(nodeFront, inspector) {
   let container = getContainerForNodeFront(nodeFront, inspector);
   ok(container, "Markup container for node found");
   ok(container.tagState.classList.contains("theme-bg-contrast"),
     "Markup container for node is flashing");
 
-  // Clear the mutation flashing timeout now that we checked the node was flashing
-  let markup = inspector.markup;
+  // Clear the mutation flashing timeout now that we checked
+  // the node was flashing.
   clearTimeout(container._flashMutationTimer);
   container._flashMutationTimer = null;
   container.tagState.classList.remove("theme-bg-contrast");
 }
 
 function* assertAttributeFlashing(nodeFront, attribute, inspector) {
   let container = getContainerForNodeFront(nodeFront, inspector);
   ok(container, "Markup container for node found");
diff --git a/devtools/client/markupview/test/browser_markupview_navigation.js b/devtools/client/markupview/test/browser_markupview_navigation.js
--- a/devtools/client/markupview/test/browser_markupview_navigation.js
+++ b/devtools/client/markupview/test/browser_markupview_navigation.js
@@ -19,17 +19,17 @@ const TEST_DATA = [
   ["down", "node3"],
   ["down", "*comment*"],
   ["down", "node4"],
   ["right", "node4"],
   ["down", "*text*"],
   ["down", "node5"],
   ["down", "node6"],
   ["down", "*comment*"],
-  ["down" , "node7"],
+  ["down", "node7"],
   ["right", "node7"],
   ["down", "*text*"],
   ["down", "node8"],
   ["left", "node7"],
   ["left", "node7"],
   ["right", "node7"],
   ["right", "*text*"],
   ["down", "node8"],
@@ -81,17 +81,17 @@ add_task(function*() {
     yield waitForChildrenUpdated(inspector);
 
     info("Checking the right node is selected");
     checkSelectedNode(key, className, inspector);
   }
 });
 
 function pressKey(key) {
-  switch(key) {
+  switch (key) {
     case "right":
       EventUtils.synthesizeKey("VK_RIGHT", {});
       break;
     case "down":
       EventUtils.synthesizeKey("VK_DOWN", {});
       break;
     case "left":
       EventUtils.synthesizeKey("VK_LEFT", {});
@@ -110,17 +110,20 @@ function pressKey(key) {
       break;
   }
 }
 
 function checkSelectedNode(key, className, inspector) {
   let node = inspector.selection.nodeFront;
 
   if (className == "*comment*") {
-    is(node.nodeType, Node.COMMENT_NODE, "Found a comment after pressing " + key);
+    is(node.nodeType, Node.COMMENT_NODE,
+      "Found a comment after pressing " + key);
   } else if (className == "*text*") {
     is(node.nodeType, Node.TEXT_NODE, "Found text after pressing " + key);
   } else if (className == "*doctype*") {
-    is(node.nodeType, Node.DOCUMENT_TYPE_NODE, "Found the doctype after pressing " + key);
+    is(node.nodeType, Node.DOCUMENT_TYPE_NODE,
+      "Found the doctype after pressing " + key);
   } else {
-    is(node.className, className, "Found node: " + className + " after pressing " + key);
+    is(node.className, className,
+      "Found node: " + className + " after pressing " + key);
   }
 }
diff --git a/devtools/client/markupview/test/browser_markupview_node_not_displayed_02.js b/devtools/client/markupview/test/browser_markupview_node_not_displayed_02.js
--- a/devtools/client/markupview/test/browser_markupview_node_not_displayed_02.js
+++ b/devtools/client/markupview/test/browser_markupview_node_not_displayed_02.js
@@ -1,121 +1,129 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Tests that nodes are marked as displayed and not-displayed dynamically, when
-// their display changes
+// their display changes.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_not_displayed.html";
 const TEST_DATA = [
   {
     desc: "Hiding a node by creating a new stylesheet",
     selector: "#normal-div",
     before: true,
-    changeStyle: (doc, node) => {
-      let div = doc.createElement("div");
-      div.id = "new-style";
-      div.innerHTML = "<style>#normal-div {display:none;}</style>";
-      doc.body.appendChild(div);
+    changeStyle: function*(selector, testActor) {
+      yield testActor.eval(`
+        let div = document.createElement("div");
+        div.id = "new-style";
+        div.innerHTML = "<style>#normal-div {display:none;}</style>";
+        document.body.appendChild(div);`);
     },
     after: false
   },
   {
     desc: "Showing a node by deleting an existing stylesheet",
     selector: "#normal-div",
     before: false,
-    changeStyle: (doc, node) => {
-      doc.getElementById("new-style").remove();
+    changeStyle: function*(selector, testActor) {
+      yield testActor.removeNode("#new-style");
     },
     after: true
   },
   {
     desc: "Hiding a node by changing its style property",
     selector: "#display-none",
     before: false,
-    changeStyle: (doc, node) => {
-      node.style.display = "block";
+    changeStyle: function*(selector, testActor) {
+      yield testActor.setProperty(selector, "style", "display: block");
     },
     after: true
   },
   {
     desc: "Showing a node by removing its hidden attribute",
     selector: "#hidden-true",
     before: false,
-    changeStyle: (doc, node) => {
-      node.removeAttribute("hidden");
+    changeStyle: function*(selector, testActor) {
+      yield testActor.removeAttribute(selector, "hidden");
     },
     after: true
   },
   {
     desc: "Hiding a node by adding a hidden attribute",
     selector: "#hidden-true",
     before: true,
-    changeStyle: (doc, node) => {
-      node.setAttribute("hidden", "true");
+    changeStyle: function*(selector, testActor) {
+      yield testActor.setAttribute(selector, "hidden", "true");
     },
     after: false
   },
   {
     desc: "Showing a node by changin a stylesheet's rule",
     selector: "#hidden-via-stylesheet",
     before: false,
-    changeStyle: (doc, node) => {
-      doc.styleSheets[0].cssRules[0].style.setProperty("display", "inline");
+    changeStyle: function*(selector, testActor) {
+      yield testActor.eval(`
+        let cssRule = document.styleSheets[0].cssRules[0];
+        cssRule.style.setProperty("display", "inline");`);
     },
     after: true
   },
   {
     desc: "Hiding a node by adding a new rule to a stylesheet",
     selector: "#hidden-via-stylesheet",
     before: true,
-    changeStyle: (doc, node) => {
-      doc.styleSheets[0].insertRule(
-        "#hidden-via-stylesheet {display: none;}", 1);
+    changeStyle: function*(selector, testActor) {
+      yield testActor.eval(`
+        let stylesheet = document.styleSheets[0];
+        stylesheet.insertRule("${selector} {display: none;}", 1);`);
     },
     after: false
   },
   {
     desc: "Hiding a node by adding a class that matches an existing rule",
     selector: "#normal-div",
     before: true,
-    changeStyle: (doc, node) => {
-      doc.styleSheets[0].insertRule(
-        ".a-new-class {display: none;}", 2);
-      node.classList.add("a-new-class");
+    changeStyle: function*(selector, testActor) {
+      yield testActor.eval(`
+        let node = document.querySelector("${selector}");
+        let stylesheet = document.styleSheets[0];
+        stylesheet.insertRule(".a-new-class {display: none;}", 2);
+        node.classList.add("a-new-class");`);
     },
     after: false
   }
 ];
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
 
   for (let data of TEST_DATA) {
     info("Running test case: " + data.desc);
-    yield runTestData(inspector, data);
+    yield runTestData(inspector, testActor, data);
   }
 });
 
-function* runTestData(inspector, {selector, before, changeStyle, after}) {
+function* runTestData(inspector, testActor, data) {
+  let {selector, before, changeStyle, after} = data;
+
   info("Getting the " + selector + " test node");
   let nodeFront = yield getNodeFront(selector, inspector);
   let container = getContainerForNodeFront(nodeFront, inspector);
   is(!container.elt.classList.contains("not-displayed"), before,
     "The container is marked as " + (before ? "shown" : "hidden"));
 
   info("Listening for the display-change event");
   let onDisplayChanged = promise.defer();
   inspector.markup.walker.once("display-change", onDisplayChanged.resolve);
 
   info("Making style changes");
-  changeStyle(content.document, getNode(selector));
+  yield changeStyle(selector, testActor);
   let nodes = yield onDisplayChanged.promise;
 
   info("Verifying that the list of changed nodes include our container");
 
   ok(nodes.length, "The display-change event was received with a nodes");
   let foundContainer = false;
   for (let node of nodes) {
     if (getContainerForNodeFront(node, inspector) === container) {
diff --git a/devtools/client/markupview/test/browser_markupview_pagesize_02.js b/devtools/client/markupview/test/browser_markupview_pagesize_02.js
--- a/devtools/client/markupview/test/browser_markupview_pagesize_02.js
+++ b/devtools/client/markupview/test/browser_markupview_pagesize_02.js
@@ -1,45 +1,47 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Tests that the markup view loads only as many nodes as specified
-// by the devtools.markup.pagesize preference and that pressing the "show all nodes"
-// actually shows the nodes
+// by the devtools.markup.pagesize preference and
+// that pressing the "show all nodes" actually shows the nodes.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_pagesize_02.html";
 
-// Make sure nodes are hidden when there are more than 5 in a row
+// Make sure nodes are hidden when there are more than 5 in a row.
 Services.prefs.setIntPref("devtools.markup.pagesize", 5);
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
 
   info("Selecting the UL node");
   yield clickContainer("ul", inspector);
   info("Reloading the page with the UL node selected will expand its children");
   yield reloadPage(inspector);
   yield inspector.markup._waitForChildren();
 
   info("Click on the 'show all nodes' button in the UL's list of children");
   yield showAllNodes(inspector);
 
-  yield assertAllNodesAreVisible(inspector);
+  yield assertAllNodesAreVisible(inspector, testActor);
 });
 
 function* showAllNodes(inspector) {
   let container = yield getContainerForSelector("ul", inspector);
   let button = container.elt.querySelector("button");
   ok(button, "All nodes button is here");
   let win = button.ownerDocument.defaultView;
 
   EventUtils.sendMouseEvent({type: "click"}, button, win);
   yield inspector.markup._waitForChildren();
 }
 
-function* assertAllNodesAreVisible(inspector) {
+function* assertAllNodesAreVisible(inspector, testActor) {
   let container = yield getContainerForSelector("ul", inspector);
-  ok(!container.elt.querySelector("button"), "All nodes button isn't here anymore");
-  is(container.children.childNodes.length, getNode("ul").children.length);
+  ok(!container.elt.querySelector("button"),
+    "All nodes button isn't here anymore");
+  is(container.children.childNodes.length,
+    (yield testActor.eval("document.querySelector('ul').children.length")));
 }
diff --git a/devtools/client/markupview/test/browser_markupview_remove_xul_attributes.js b/devtools/client/markupview/test/browser_markupview_remove_xul_attributes.js
--- a/devtools/client/markupview/test/browser_markupview_remove_xul_attributes.js
+++ b/devtools/client/markupview/test/browser_markupview_remove_xul_attributes.js
@@ -1,27 +1,26 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Test confirms that XUL attributes don't show up as empty
-// attributes after being deleted
+// attributes after being deleted.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_xul.xul";
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
-
-  let panel = yield getNode("#test", inspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
   let panelFront = yield getNodeFront("#test", inspector);
 
-  ok(panelFront.hasAttribute("id"), "panelFront has id attribute in the beginning");
+  ok(panelFront.hasAttribute("id"),
+    "panelFront has id attribute in the beginning");
 
   info("Removing panel's id attribute");
-  panel.removeAttribute("id");
+  let onMutation = inspector.once("markupmutation");
+  yield testActor.removeAttribute("#test", "id");
+  yield onMutation;
 
-  info("Waiting for markupmutation");
-  yield inspector.once("markupmutation");
-
-  is(panelFront.hasAttribute("id"), false, "panelFront doesn't have id attribute anymore");
+  is(panelFront.hasAttribute("id"), false,
+    "panelFront doesn't have id attribute anymore");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_01.js b/devtools/client/markupview/test/browser_markupview_tag_edit_01.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_01.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_01.js
@@ -1,15 +1,15 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test editing various markup-containers' attribute fields
+// Test editing various markup-containers' attribute fields.
 
 loadHelperScript("helper_attributes_test_runner.js");
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_edit.html";
 var TEST_DATA = [{
   desc: "Change an attribute",
   node: "#node1",
   originalAttributes: {
@@ -18,18 +18,18 @@ var TEST_DATA = [{
   },
   name: "class",
   value: 'class="changednode1"',
   expectedAttributes: {
     id: "node1",
     class: "changednode1"
   }
 }, {
-  desc: 'Try changing an attribute to a quote (") - this should result ' +
-        'in it being set to an empty string',
+  desc: "Try changing an attribute to a quote (\") - this should result " +
+        "in it being set to an empty string",
   node: "#node22",
   originalAttributes: {
     id: "node22",
     class: "unchanged"
   },
   name: "class",
   value: 'class="""',
   expectedAttributes: {
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_02.js b/devtools/client/markupview/test/browser_markupview_tag_edit_02.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_02.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_02.js
@@ -1,21 +1,23 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Tests that an existing attribute can be modified
+// Tests that an existing attribute can be modified.
 
-const TEST_URL = "data:text/html,<div id='test-div'>Test modifying my ID attribute</div>";
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div id='test-div'>Test modifying my ID attribute</div>`;
 
 add_task(function*() {
   info("Opening the inspector on the test page");
-  let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   info("Selecting the test node");
   yield selectNode("#test-div", inspector);
 
   info("Verify attributes, only ID should be there for now");
   yield assertAttributes("#test-div", {
     id: "test-div"
   });
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_03.js b/devtools/client/markupview/test/browser_markupview_tag_edit_03.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_03.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_03.js
@@ -1,17 +1,21 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Tests that a node's tagname can be edited in the markup-view
+// Tests that a node's tagname can be edited in the markup-view.
 
-const TEST_URL = "data:text/html;charset=utf-8,<div id='retag-me'><div id='retag-me-2'></div></div>";
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div id='retag-me'>
+    <div id='retag-me-2'></div>
+  </div>`;
 
 add_task(function*() {
   let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
 
   yield inspector.markup.expandAll();
 
   info("Selecting the test node");
   yield selectNode("#retag-me", inspector);
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_04.js b/devtools/client/markupview/test/browser_markupview_tag_edit_04.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_04.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_04.js
@@ -3,31 +3,33 @@
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Tests that a node can be deleted from the markup-view with the delete key.
 // Also checks that after deletion the correct element is highlighted.
 // The next sibling is preferred, but the parent is a fallback.
 
-const HTML = `<div id="parent">
-                <div id="first"></div>
-                <div id="second"></div>
-                <div id="third"></div>
-              </div>`;
-const TEST_URL = "data:text/html;charset=utf-8," + encodeURIComponent(HTML);
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div id="parent">
+    <div id="first"></div>
+    <div id="second"></div>
+    <div id="third"></div>
+  </div>`;
 
 // List of all the test cases. Each item is an object with the following props:
 // - selector: the css selector of the node that should be selected
 // - key: the key to press to delete the node (delete or back_space)
 // - focusedSelector: the css selector of the node we expect to be selected as
 //   a result of the deletion
 // - setup: an optional function that will be run before selecting and deleting
 //   the node
 // Note that after each test case, undo is called.
+
 const TEST_DATA = [{
   selector: "#first",
   key: "delete",
   focusedSelector: "#second"
 }, {
   selector: "#second",
   key: "delete",
   focusedSelector: "#third"
@@ -43,39 +45,40 @@ const TEST_DATA = [{
   selector: "#second",
   key: "back_space",
   focusedSelector: "#first"
 }, {
   selector: "#third",
   key: "back_space",
   focusedSelector: "#second"
 }, {
-  setup: function*(inspector) {
+  setup: function*(inspector, testActor) {
     // Removing the siblings of #first in order to test with an only child.
     let mutated = inspector.once("markupmutation");
-    for (let node of content.document.querySelectorAll("#second, #third")) {
-      node.remove();
-    }
+    yield testActor.eval(`
+      for (let node of document.querySelectorAll("#second, #third")) {
+        node.remove();
+      }`);
     yield mutated;
   },
   selector: "#first",
   key: "delete",
   focusedSelector: "#parent"
 }, {
   selector: "#first",
   key: "back_space",
   focusedSelector: "#parent"
 }];
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
 
   for (let {setup, selector, key, focusedSelector} of TEST_DATA) {
     if (setup) {
-      yield setup(inspector);
+      yield setup(inspector, testActor);
     }
 
     yield checkDeleteAndSelection(inspector, key, selector, focusedSelector);
   }
 });
 
 function* checkDeleteAndSelection(inspector, key, selector, focusedSelector) {
   info("Test deleting node " + selector + " with " + key + ", " +
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_05.js b/devtools/client/markupview/test/browser_markupview_tag_edit_05.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_05.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_05.js
@@ -9,18 +9,21 @@
 // redoable. For each step in the test, we:
 // - Create a new DIV
 // - Make the change, check that the change was made as we expect
 // - Undo the change, check that the node is back in its original state
 // - Redo the change, check that the node change was made again correctly.
 
 loadHelperScript("helper_attributes_test_runner.js");
 
-var TEST_URL = "data:text/html,<div>markup-view attributes addition test</div>";
-var TEST_DATA = [{
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div>markup-view attributes addition test</div>`;
+
+const TEST_DATA = [{
   desc: "Add an attribute value without closing \"",
   text: 'style="display: block;',
   expectedAttributes: {
     style: "display: block;"
   }
 }, {
   desc: "Add an attribute value without closing '",
   text: "style='display: inline;",
@@ -56,22 +59,22 @@ var TEST_DATA = [{
   }
 }, {
   desc: "Add multiple attributes with no value, and some with value",
   text: "disabled name='name' data-test='test' autofocus",
   expectedAttributes: {
     disabled: "",
     autofocus: "",
     name: "name",
-    'data-test': "test"
+    "data-test": "test"
   }
 }, {
   desc: "Add attribute with xmlns",
   text: "xmlns:edi='http://ecommerce.example.org/schema'",
   expectedAttributes: {
-    'xmlns:edi': "http://ecommerce.example.org/schema"
+    "xmlns:edi": "http://ecommerce.example.org/schema"
   }
 }];
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
-  yield runAddAttributesTests(TEST_DATA, "div", inspector)
+  yield runAddAttributesTests(TEST_DATA, "div", inspector);
 });
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_06.js b/devtools/client/markupview/test/browser_markupview_tag_edit_06.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_06.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_06.js
@@ -9,18 +9,21 @@
 // redoable. For each step in the test, we:
 // - Create a new DIV
 // - Make the change, check that the change was made as we expect
 // - Undo the change, check that the node is back in its original state
 // - Redo the change, check that the node change was made again correctly.
 
 loadHelperScript("helper_attributes_test_runner.js");
 
-var TEST_URL = "data:text/html,<div>markup-view attributes addition test</div>";
-var TEST_DATA = [{
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div>markup-view attributes addition test</div>";`;
+
+const TEST_DATA = [{
   desc: "Mixed single and double quotes",
   text: "name=\"hi\" maxlength='not a number'",
   expectedAttributes: {
     maxlength: "not a number",
     name: "hi"
   }
 }, {
   desc: "Invalid attribute name",
@@ -75,10 +78,10 @@ var TEST_DATA = [{
   expectedAttributes: {
     onclick: "javascript: throw new Error('wont fire');",
     onload: "alert('here');"
   }
 }];
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
-  yield runAddAttributesTests(TEST_DATA, "div", inspector)
+  yield runAddAttributesTests(TEST_DATA, "div", inspector);
 });
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_07.js b/devtools/client/markupview/test/browser_markupview_tag_edit_07.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_07.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_07.js
@@ -1,102 +1,105 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// One more test testing various add-attributes configurations
-// Some of the test data below asserts that long attributes get collapsed
+// One more test testing various add-attributes configurations.
+// Some of the test data below asserts that long attributes get collapsed.
 
 loadHelperScript("helper_attributes_test_runner.js");
 
 const LONG_ATTRIBUTE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 const LONG_ATTRIBUTE_COLLAPSED = "ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEF\u2026UVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ";
-const DATA_URL_INLINE_STYLE='color: red; background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD///+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC");';
-const DATA_URL_INLINE_STYLE_COLLAPSED='color: red; background: url("data:image/png;base64,iVBORw0KG\u2026NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC");';
+const DATA_URL_INLINE_STYLE = 'color: red; background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD///+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC");';
+const DATA_URL_INLINE_STYLE_COLLAPSED = 'color: red; background: url("data:image/png;base64,iVBORw0KG\u2026NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC");';
 const DATA_URL_ATTRIBUTE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD///+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC";
 const DATA_URL_ATTRIBUTE_COLLAPSED = "data:image/png;base64,iVBORw0K\u20269/AFGGFyjOXZtQAAAAAElFTkSuQmCC";
 
-var TEST_URL = "data:text/html,<div>markup-view attributes addition test</div>";
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div>markup-view attributes addition test</div>`;
+
 var TEST_DATA = [{
   desc: "Add an attribute value containing < > &uuml; \" & '",
   text: 'src="somefile.html?param1=<a>&param2=&uuml;&param3=\'&quot;\'"',
   expectedAttributes: {
     src: "somefile.html?param1=<a>&param2=\xfc&param3='\"'"
   }
 }, {
   desc: "Add an attribute by clicking the empty space after a node",
   text: 'class="newclass" style="color:green"',
   expectedAttributes: {
     class: "newclass",
     style: "color:green"
   }
 }, {
-  desc: 'Try add an attribute containing a quote (") attribute by ' +
-        'clicking the empty space after a node - this should result ' +
-        'in it being set to an empty string',
+  desc: "Try add an attribute containing a quote (\") attribute by " +
+        "clicking the empty space after a node - this should result " +
+        "in it being set to an empty string",
   text: 'class="newclass" style="""',
   expectedAttributes: {
     class: "newclass",
     style: ""
   }
 }, {
   desc: "Try to add long data URL to make sure it is collapsed in attribute editor.",
-  text: "style='"+DATA_URL_INLINE_STYLE+"'",
+  text: "style='" + DATA_URL_INLINE_STYLE + "'",
   expectedAttributes: {
-    'style': DATA_URL_INLINE_STYLE
+    "style": DATA_URL_INLINE_STYLE
   },
-  validate: (element, container, inspector) => {
+  validate: (selector, container, inspector) => {
     let editor = container.editor;
     let visibleAttrText = editor.attrElements.get("style").querySelector(".attr-value").textContent;
-    is (visibleAttrText, DATA_URL_INLINE_STYLE_COLLAPSED);
+    is(visibleAttrText, DATA_URL_INLINE_STYLE_COLLAPSED);
   }
 }, {
   desc: "Try to add long attribute to make sure it is collapsed in attribute editor.",
-  text: 'data-long="'+LONG_ATTRIBUTE+'"',
+  text: 'data-long="' + LONG_ATTRIBUTE + '"',
   expectedAttributes: {
-    'data-long':LONG_ATTRIBUTE
+    "data-long": LONG_ATTRIBUTE
   },
-  validate: (element, container, inspector) => {
+  validate: (selector, container, inspector) => {
     let editor = container.editor;
     let visibleAttrText = editor.attrElements.get("data-long").querySelector(".attr-value").textContent;
-    is (visibleAttrText, LONG_ATTRIBUTE_COLLAPSED)
+    is(visibleAttrText, LONG_ATTRIBUTE_COLLAPSED);
   }
 }, {
   desc: "Try to add long data URL to make sure it is collapsed in attribute editor.",
-  text: 'src="'+DATA_URL_ATTRIBUTE+'"',
+  text: 'src="' + DATA_URL_ATTRIBUTE + '"',
   expectedAttributes: {
     "src": DATA_URL_ATTRIBUTE
   },
-  validate: (element, container, inspector) => {
+  validate: (selector, container, inspector) => {
     let editor = container.editor;
-    let visibleAttrText = editor.attrElements.get("src").querySelector(".attr-value").textContent;
-    is (visibleAttrText, DATA_URL_ATTRIBUTE_COLLAPSED);
+    let visibleAttrText =
+      editor.attrElements.get("src").querySelector(".attr-value").textContent;
+    is(visibleAttrText, DATA_URL_ATTRIBUTE_COLLAPSED);
   }
 }, {
   desc: "Try to add long attribute with collapseAttributeLength == -1" +
   "to make sure it isn't collapsed in attribute editor.",
   text: 'data-long="' + LONG_ATTRIBUTE + '"',
   expectedAttributes: {
     "data-long": LONG_ATTRIBUTE
   },
   setUp: function(inspector) {
     inspector.markup.collapseAttributeLength = -1;
   },
-  validate: (element, container, inspector) => {
+  validate: (selector, container, inspector) => {
     let editor = container.editor;
     let visibleAttrText = editor.attrElements
       .get("data-long")
       .querySelector(".attr-value")
       .textContent;
     is(visibleAttrText, LONG_ATTRIBUTE);
   },
   tearDown: function(inspector) {
     inspector.markup.collapseAttributeLength = 120;
   }
 }];
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
-  yield runAddAttributesTests(TEST_DATA, "div", inspector)
+  yield runAddAttributesTests(TEST_DATA, "div", inspector);
 });
-
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_08.js b/devtools/client/markupview/test/browser_markupview_tag_edit_08.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_08.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_08.js
@@ -1,16 +1,16 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Test editing various markup-containers' attribute fields, in particular
-// attributes with long values and quotes
+// attributes with long values and quotes.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_edit.html";
 const LONG_ATTRIBUTE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 const LONG_ATTRIBUTE_COLLAPSED = "ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEF\u2026UVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ-ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
@@ -19,111 +19,111 @@ add_task(function*() {
   yield testModifyInlineStyleWithQuotes(inspector);
   yield testEditingAttributeWithMixedQuotes(inspector);
 });
 
 function* testCollapsedLongAttribute(inspector) {
   info("Try to modify the collapsed long attribute, making sure it expands.");
 
   info("Adding test attributes to the node");
-  let onMutated = inspector.once("markupmutation");
+  let onMutation = inspector.once("markupmutation");
   yield setNodeAttribute("#node24", "class", "");
   yield setNodeAttribute("#node24", "data-long", LONG_ATTRIBUTE);
-  yield onMutated;
+  yield onMutation;
 
   yield assertAttributes("#node24", {
     id: "node24",
     "class": "",
     "data-long": LONG_ATTRIBUTE
   });
 
   let {editor} = yield getContainerForSelector("#node24", inspector);
   let attr = editor.attrElements.get("data-long").querySelector(".editable");
 
-  // Check to make sure it has expanded after focus
+  // Check to make sure it has expanded after focus.
   attr.focus();
   EventUtils.sendKey("return", inspector.panelWin);
   let input = inplaceEditor(attr).input;
-  is (input.value, 'data-long="' + LONG_ATTRIBUTE + '"');
+  is(input.value, 'data-long="' + LONG_ATTRIBUTE + '"');
   EventUtils.sendKey("escape", inspector.panelWin);
 
   setEditableFieldValue(attr, input.value + ' data-short="ABC"', inspector);
   yield inspector.once("markupmutation");
 
   let visibleAttrText = editor.attrElements.get("data-long").querySelector(".attr-value").textContent;
-  is (visibleAttrText, LONG_ATTRIBUTE_COLLAPSED)
+  is(visibleAttrText, LONG_ATTRIBUTE_COLLAPSED);
 
   yield assertAttributes("#node24", {
     id: "node24",
     class: "",
-    'data-long': LONG_ATTRIBUTE,
+    "data-long": LONG_ATTRIBUTE,
     "data-short": "ABC"
   });
 }
 
 function* testModifyInlineStyleWithQuotes(inspector) {
   info("Modify inline style containing \"");
 
   yield assertAttributes("#node26", {
     id: "node26",
     style: 'background-image: url("moz-page-thumb://thumbnail?url=http%3A%2F%2Fwww.mozilla.org%2F");'
   });
 
-  let onMutated = inspector.once("markupmutation");
+  let onMutation = inspector.once("markupmutation");
   let {editor} = yield getContainerForSelector("#node26", inspector);
   let attr = editor.attrElements.get("style").querySelector(".editable");
 
   attr.focus();
   EventUtils.sendKey("return", inspector.panelWin);
 
   let input = inplaceEditor(attr).input;
   let value = input.value;
 
-  is (value,
+  is(value,
     "style='background-image: url(\"moz-page-thumb://thumbnail?url=http%3A%2F%2Fwww.mozilla.org%2F\");'",
     "Value contains actual double quotes"
   );
 
   value = value.replace(/mozilla\.org/, "mozilla.com");
   input.value = value;
 
   EventUtils.sendKey("return", inspector.panelWin);
 
-  yield onMutated;
+  yield onMutation;
 
   yield assertAttributes("#node26", {
     id: "node26",
     style: 'background-image: url("moz-page-thumb://thumbnail?url=http%3A%2F%2Fwww.mozilla.com%2F");'
   });
 }
 
 function* testEditingAttributeWithMixedQuotes(inspector) {
   info("Modify class containing \" and \'");
 
   yield assertAttributes("#node27", {
     "id": "node27",
     "class": 'Double " and single \''
   });
 
-  let onMutated = inspector.once("markupmutation");
+  let onMutation = inspector.once("markupmutation");
   let {editor} = yield getContainerForSelector("#node27", inspector);
   let attr = editor.attrElements.get("class").querySelector(".editable");
 
   attr.focus();
   EventUtils.sendKey("return", inspector.panelWin);
 
   let input = inplaceEditor(attr).input;
   let value = input.value;
 
-  is (value, "class=\"Double &quot; and single '\"", "Value contains &quot;");
+  is(value, "class=\"Double &quot; and single '\"", "Value contains &quot;");
 
   value = value.replace(/Double/, "&quot;").replace(/single/, "'");
   input.value = value;
 
   EventUtils.sendKey("return", inspector.panelWin);
 
-  yield onMutated;
+  yield onMutation;
 
   yield assertAttributes("#node27", {
     id: "node27",
     class: '" " and \' \''
   });
 }
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_09.js b/devtools/client/markupview/test/browser_markupview_tag_edit_09.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_09.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_09.js
@@ -1,15 +1,15 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test that editing a mixed-case attribute preserves the case
+// Test that editing a mixed-case attribute preserves the case.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_svg_attributes.html";
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   yield inspector.markup.expandAll();
   yield selectNode("svg", inspector);
@@ -18,54 +18,54 @@ add_task(function*() {
   yield testMalformedMixedCase(inspector);
 });
 
 function* testWellformedMixedCase(inspector) {
   info("Modifying a mixed-case attribute, " +
     "expecting the attribute's case to be preserved");
 
   info("Listening to markup mutations");
-  let onMutated = inspector.once("markupmutation");
+  let onMutation = inspector.once("markupmutation");
 
   info("Focusing the viewBox attribute editor");
   let {editor} = yield getContainerForSelector("svg", inspector);
   let attr = editor.attrElements.get("viewBox").querySelector(".editable");
   attr.focus();
   EventUtils.sendKey("return", inspector.panelWin);
 
   info("Editing the attribute value and waiting for the mutation event");
   let input = inplaceEditor(attr).input;
   input.value = "viewBox=\"0 0 1 1\"";
   EventUtils.sendKey("return", inspector.panelWin);
-  yield onMutated;
+  yield onMutation;
 
   yield assertAttributes("svg", {
     "viewBox": "0 0 1 1",
     "width": "200",
     "height": "200"
   });
 }
 
 function* testMalformedMixedCase(inspector) {
   info("Modifying a malformed, mixed-case attribute, " +
     "expecting the attribute's case to be preserved");
 
   info("Listening to markup mutations");
-  let onMutated = inspector.once("markupmutation");
+  let onMutation = inspector.once("markupmutation");
 
   info("Focusing the viewBox attribute editor");
   let {editor} = yield getContainerForSelector("svg", inspector);
   let attr = editor.attrElements.get("viewBox").querySelector(".editable");
   attr.focus();
   EventUtils.sendKey("return", inspector.panelWin);
 
   info("Editing the attribute value and waiting for the mutation event");
   let input = inplaceEditor(attr).input;
   input.value = "viewBox=\"<>\"";
   EventUtils.sendKey("return", inspector.panelWin);
-  yield onMutated;
+  yield onMutation;
 
   yield assertAttributes("svg", {
     "viewBox": "<>",
     "width": "200",
     "height": "200"
   });
 }
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_10.js b/devtools/client/markupview/test/browser_markupview_tag_edit_10.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_10.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_10.js
@@ -1,33 +1,37 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Tests that invalid tagname updates are handled correctly
+// Tests that invalid tagname updates are handled correctly.
 
-const TEST_URL = "data:text/html;charset=utf-8,<div></div>";
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div></div>`;
 
 add_task(function*() {
-  let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
   yield inspector.markup.expandAll();
   yield selectNode("div", inspector);
 
   info("Updating the DIV tagname to an invalid value");
   let container = yield getContainerForSelector("div", inspector);
   let onCancelReselect = inspector.markup.once("canceledreselectonremoved");
   let tagEditor = container.editor.tag;
   setEditableFieldValue(tagEditor, "<<<", inspector);
   yield onCancelReselect;
   ok(true, "The markup-view emitted the canceledreselectonremoved event");
-  is(inspector.selection.nodeFront, container.node, "The test DIV is still selected");
+  is(inspector.selection.nodeFront, container.node,
+    "The test DIV is still selected");
 
   info("Updating the DIV tagname to a valid value this time");
   let onReselect = inspector.markup.once("reselectedonremoved");
   setEditableFieldValue(tagEditor, "span", inspector);
   yield onReselect;
   ok(true, "The markup-view emitted the reselectedonremoved event");
 
   let spanFront = yield getNodeFront("span", inspector);
-  is(inspector.selection.nodeFront, spanFront, "The seelected node is now the SPAN");
+  is(inspector.selection.nodeFront, spanFront,
+    "The seelected node is now the SPAN");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_11.js b/devtools/client/markupview/test/browser_markupview_tag_edit_11.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_11.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_11.js
@@ -2,35 +2,39 @@
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Bug 1090874 - Tests that a node is not recreated when it's tagname editor
 // is blurred and no changes were done.
 
-const TEST_URL = "data:text/html;charset=utf-8,<div></div>";
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div></div>`;
 
 add_task(function*() {
   let isEditTagNameCalled = false;
 
-  let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   // Overriding the editTagName walkerActor method here to check that it isn't
   // called when blurring the tagname field.
-  inspector.walker.editTagName = function() { isEditTagNameCalled = true; }
+  inspector.walker.editTagName = function() {
+    isEditTagNameCalled = true;
+  };
 
   yield selectNode("div", inspector);
   let container = yield getContainerForSelector("div", inspector);
   let tagEditor = container.editor.tag;
 
   info("Blurring the tagname field");
   tagEditor.blur();
   is(isEditTagNameCalled, false, "The editTagName method wasn't called");
 
   info("Updating the tagname to uppercase");
   setEditableFieldValue(tagEditor, "DIV", inspector);
   is(isEditTagNameCalled, false, "The editTagName method wasn't called");
 
   info("Updating the tagname to a different value");
   setEditableFieldValue(tagEditor, "SPAN", inspector);
   is(isEditTagNameCalled, true, "The editTagName method was called");
-});
\ No newline at end of file
+});
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_12.js b/devtools/client/markupview/test/browser_markupview_tag_edit_12.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_12.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_12.js
@@ -2,96 +2,105 @@
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Tests that focus position is correct when tabbing through and editing
 // attributes.
 
-const TEST_URL = "data:text/html;charset=utf8,<div id='attr' c='3' b='2' a='1'></div><div id='delattr' last='1' tobeinvalid='2'></div>";
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div id='attr' c='3' b='2' a='1'></div>
+  <div id='delattr' last='1' tobeinvalid='2'></div>`;
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
 
-  yield testAttributeEditing(inspector);
-  yield testAttributeDeletion(inspector);
+  yield testAttributeEditing(inspector, testActor);
+  yield testAttributeDeletion(inspector, testActor);
 });
 
-function* testAttributeEditing(inspector) {
+function* testAttributeEditing(inspector, testActor) {
   info("Testing focus position after attribute editing");
 
   // Modifying attributes reorders them in the internal representation to move
   // the modified attribute to the end. breadcrumbs.js will update attributes
   // to match original order if you selectNode before modifying attributes.
   // So, hacky workaround for consistency with manual testing.
   // Should be removed after Bug 1093593.
   yield selectNode("#attr", inspector);
 
   info("Setting the first non-id attribute in edit mode");
-  yield activateFirstAttribute("#attr", inspector); // focuses id
-  collapseSelectionAndTab(inspector); // focuses the first attr after id
+  // Focuses id.
+  yield activateFirstAttribute("#attr", inspector);
+  // Focuses the first attr after id.
+  collapseSelectionAndTab(inspector);
 
   // Detect the attributes order from the DOM, instead of assuming an order in
   // the test, because the NamedNodeMap returned by element.attributes doesn't
   // guaranty any specific order.
   // Filter out the id attribute as the markup-view places it first anyway.
-  let attrs = getNodeAttributesOtherThanId("#attr");
+  let attrs = yield getNodeAttributesOtherThanId("#attr", testActor);
 
   info("Editing this attribute, keeping the same name, and tabbing to the next");
   yield editAttributeAndTab(attrs[0].name + '="99"', inspector);
   checkFocusedAttribute(attrs[1].name, true);
 
   info("Editing the new focused attribute, keeping the name, and tabbing to the previous");
   yield editAttributeAndTab(attrs[1].name + '="99"', inspector, true);
   checkFocusedAttribute(attrs[0].name, true);
 
   info("Editing attribute name, changes attribute order");
   yield editAttributeAndTab("d='4'", inspector);
   checkFocusedAttribute("id", true);
 
-  // Escape of the currently focused field for the next test
+  // Escape of the currently focused field for the next test.
   EventUtils.sendKey("escape", inspector.panelWin);
 }
 
-function* testAttributeDeletion(inspector) {
+function* testAttributeDeletion(inspector, testActor) {
   info("Testing focus position after attribute deletion");
 
   // Modifying attributes reorders them in the internal representation to move
   // the modified attribute to the end. breadcrumbs.js will update attributes
   // to match original order if you selectNode before modifying attributes.
   // So, hacky workaround for consistency with manual testing.
   // Should be removed after Bug 1093593.
   yield selectNode("#delattr", inspector);
 
   info("Setting the first non-id attribute in edit mode");
-  yield activateFirstAttribute("#delattr", inspector); // focuses id
-  collapseSelectionAndTab(inspector); // focuses the first attr after id
+
+  // Focuses id.
+  yield activateFirstAttribute("#delattr", inspector);
+  // Focuses the first attr after id.
+  collapseSelectionAndTab(inspector);
 
   // Detect the attributes order from the DOM, instead of assuming an order in
   // the test, because the NamedNodeMap returned by element.attributes doesn't
   // guaranty any specific order.
   // Filter out the id attribute as the markup-view places it first anyway.
-  let attrs = getNodeAttributesOtherThanId("#delattr");
+  let attrs = yield getNodeAttributesOtherThanId("#delattr", testActor);
 
   info("Entering an invalid attribute to delete the attribute");
   yield editAttributeAndTab('"', inspector);
   checkFocusedAttribute(attrs[1].name, true);
 
   info("Deleting the last attribute");
   yield editAttributeAndTab(" ", inspector);
 
-  // Check we're on the newattr element
+  // Check we're on the newattr element.
   let focusedAttr = Services.focus.focusedElement;
-  ok(focusedAttr.classList.contains("styleinspector-propertyeditor"), "in newattr");
+  ok(focusedAttr.classList.contains("styleinspector-propertyeditor"),
+    "in newattr");
   is(focusedAttr.tagName, "input", "newattr is active");
 }
 
 function* editAttributeAndTab(newValue, inspector, goPrevious) {
-  var onEditMutation = inspector.markup.once("refocusedonedit");
+  let onEditMutation = inspector.markup.once("refocusedonedit");
   inspector.markup.doc.activeElement.value = newValue;
   if (goPrevious) {
     EventUtils.synthesizeKey("VK_TAB", { shiftKey: true },
       inspector.panelWin);
   } else {
     EventUtils.sendKey("tab", inspector.panelWin);
   }
   yield onEditMutation;
@@ -105,11 +114,13 @@ function* activateFirstAttribute(contain
   let {editor} = yield getContainerForSelector(container, inspector);
   editor.tag.focus();
 
   // Go to "id" attribute and trigger edit mode.
   EventUtils.sendKey("tab", inspector.panelWin);
   EventUtils.sendKey("return", inspector.panelWin);
 }
 
-function getNodeAttributesOtherThanId(selector) {
-  return [...getNode(selector).attributes].filter(attr => attr.name !== "id");
+function* getNodeAttributesOtherThanId(selector, testActor) {
+  return (yield testActor.getAttributes(selector)).filter(attr => {
+    return attr.name !== "id";
+  });
 }
diff --git a/devtools/client/markupview/test/browser_markupview_textcontent_edit_01.js b/devtools/client/markupview/test/browser_markupview_textcontent_edit_01.js
--- a/devtools/client/markupview/test/browser_markupview_textcontent_edit_01.js
+++ b/devtools/client/markupview/test/browser_markupview_textcontent_edit_01.js
@@ -1,74 +1,81 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test editing a node's text content
+// Test editing a node's text content.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_edit.html";
 
 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
 
   info("Expanding all nodes");
   yield inspector.markup.expandAll();
   yield waitForMultipleChildrenUpdates(inspector);
 
-  yield editContainer(inspector, {
+  yield editContainer(inspector, testActor, {
     selector: ".node6",
     newValue: "New text",
     oldValue: "line6"
   });
 
-  yield editContainer(inspector, {
+  yield editContainer(inspector, testActor, {
     selector: "#node17",
     newValue: "LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT. DONEC POSUERE PLACERAT MAGNA ET IMPERDIET.",
     oldValue: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec posuere placerat magna et imperdiet.",
     shortValue: true
   });
 
-  yield editContainer(inspector, {
+  yield editContainer(inspector, testActor, {
     selector: "#node17",
     newValue: "New value",
     oldValue: "LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT. DONEC POSUERE PLACERAT MAGNA ET IMPERDIET.",
     shortValue: true
   });
 });
 
-function* editContainer(inspector, {selector, newValue, oldValue, shortValue}) {
-  let node = getNode(selector).firstChild;
-  is(node.nodeValue, oldValue, "The test node's text content is correct");
+function* editContainer(inspector, testActor, data) {
+  let {selector, newValue, oldValue, shortValue} = data;
+  let nodeValue;
+
+  nodeValue = yield testActor.eval(
+    `document.querySelector("${selector}").firstChild.nodeValue`);
+  is(nodeValue, oldValue, "The test node's text content is correct");
 
   info("Changing the text content");
-  let onMutated = inspector.once("markupmutation");
+  let onMutation = inspector.once("markupmutation");
   let container = yield getContainerForSelector(selector, inspector);
   let field = container.elt.querySelector("pre");
 
   if (shortValue) {
-    is (oldValue.indexOf(field.textContent.substring(0, field.textContent.length - 1)), 0,
+    is(oldValue.indexOf(field.textContent.substring(0, field.textContent.length - 1)), 0,
         "The shortened value starts with the full value " + field.textContent);
-    ok (oldValue.length > field.textContent.length, "The shortened value is short");
+    ok(oldValue.length > field.textContent.length, "The shortened value is short");
   } else {
-    is (field.textContent, oldValue, "The text node has the correct original value");
+    is(field.textContent, oldValue, "The text node has the correct original value");
   }
 
   inspector.markup.markNodeAsSelected(container.node);
 
   if (shortValue) {
     info("Waiting for the text to be updated");
     yield inspector.markup.once("text-expand");
   }
 
-  is (field.textContent, oldValue, "The text node has the correct original value after selecting");
+  is(field.textContent, oldValue,
+    "The text node has the correct original value after selecting");
   setEditableFieldValue(field, newValue, inspector);
 
   info("Listening to the markupmutation event");
-  yield onMutated;
+  yield onMutation;
 
-  is(node.nodeValue, newValue, "The test node's text content has changed");
+  nodeValue = yield testActor.eval(
+    `document.querySelector("${selector}").firstChild.nodeValue`);
+  is(nodeValue, newValue, "The test node's text content has changed");
 
   info("Selecting the <body> to reset the selection");
   let bodyContainer = yield getContainerForSelector("body", inspector);
   inspector.markup.markNodeAsSelected(bodyContainer.node);
 }
diff --git a/devtools/client/markupview/test/browser_markupview_toggle_01.js b/devtools/client/markupview/test/browser_markupview_toggle_01.js
--- a/devtools/client/markupview/test/browser_markupview_toggle_01.js
+++ b/devtools/client/markupview/test/browser_markupview_toggle_01.js
@@ -1,20 +1,21 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test toggling (expand/collapse) elements by clicking on twisties
+// Test toggling (expand/collapse) elements by clicking on twisties.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_toggle.html";
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {walker} = inspector;
 
   info("Getting the container for the html element");
   let container = yield getContainerForSelector("html", inspector);
   ok(container.mustExpand, "HTML element mustExpand");
   ok(container.canExpand, "HTML element canExpand");
   is(container.expander.style.visibility, "hidden", "HTML twisty is hidden");
 
   info("Getting the container for the UL parent element");
@@ -27,30 +28,31 @@ add_task(function*() {
   let onChildren = waitForChildrenUpdated(inspector);
   let onUpdated = inspector.once("inspector-updated");
   EventUtils.synthesizeMouseAtCenter(container.expander, {},
     inspector.markup.doc.defaultView);
   yield onChildren;
   yield onUpdated;
 
   info("Checking that child LI elements have been created");
-  for (let i = 0; i < content.document.querySelectorAll("li").length; i ++) {
+  let liCount = (yield walker.querySelectorAll(walker.rootNode, "li")).length;
+  for (let i = 0; i < liCount; i++) {
     let liContainer = yield getContainerForSelector(
       "li:nth-child(" + (i + 1) + ")", inspector);
     ok(liContainer, "A container for the child LI element was created");
   }
   ok(container.expanded, "Parent UL container is expanded");
 
   info("Clicking again on the UL expander");
   // No need to wait, this is a local, synchronous operation where nodes are
-  // only hidden from the view, not destroyed
+  // only hidden from the view, not destroyed.
   EventUtils.synthesizeMouseAtCenter(container.expander, {},
     inspector.markup.doc.defaultView);
 
   info("Checking that child LI elements have been hidden");
-  for (let i = 0; i < content.document.querySelectorAll("li").length; i ++) {
+  for (let i = 0; i < liCount; i++) {
     let liContainer = yield getContainerForSelector(
       "li:nth-child(" + (i + 1) + ")", inspector);
     is(liContainer.elt.getClientRects().length, 0,
       "The container for the child LI element was hidden");
   }
   ok(!container.expanded, "Parent UL container is collapsed");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_toggle_02.js b/devtools/client/markupview/test/browser_markupview_toggle_02.js
--- a/devtools/client/markupview/test/browser_markupview_toggle_02.js
+++ b/devtools/client/markupview/test/browser_markupview_toggle_02.js
@@ -1,47 +1,49 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// Test toggling (expand/collapse) elements by dbl-clicking on tag lines
+// Test toggling (expand/collapse) elements by dbl-clicking on tag lines.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_toggle.html";
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {walker} = inspector;
 
   info("Getting the container for the UL parent element");
   let container = yield getContainerForSelector("ul", inspector);
 
   info("Dbl-clicking on the UL parent expander, and waiting for children");
   let onChildren = waitForChildrenUpdated(inspector);
   let onUpdated = inspector.once("inspector-updated");
   EventUtils.synthesizeMouseAtCenter(container.tagLine, {clickCount: 2},
     inspector.markup.doc.defaultView);
   yield onChildren;
   yield onUpdated;
 
   info("Checking that child LI elements have been created");
-  for (let i = 0; i < content.document.querySelectorAll("li").length; i ++) {
+  let liCount = (yield walker.querySelectorAll(walker.rootNode, "li")).length;
+  for (let i = 0; i < liCount; i++) {
     let liContainer = yield getContainerForSelector(
       "li:nth-child(" + (i + 1) + ")", inspector);
     ok(liContainer, "A container for the child LI element was created");
   }
   ok(container.expanded, "Parent UL container is expanded");
 
   info("Dbl-clicking again on the UL expander");
   // No need to wait, this is a local, synchronous operation where nodes are
-  // only hidden from the view, not destroyed
+  // only hidden from the view, not destroyed.
   EventUtils.synthesizeMouseAtCenter(container.tagLine, {clickCount: 2},
     inspector.markup.doc.defaultView);
 
   info("Checking that child LI elements have been hidden");
-  for (let i = 0; i < content.document.querySelectorAll("li").length; i ++) {
+  for (let i = 0; i < liCount; i++) {
     let liContainer = yield getContainerForSelector(
       "li:nth-child(" + (i + 1) + ")", inspector);
     is(liContainer.elt.getClientRects().length, 0,
       "The container for the child LI element was hidden");
   }
   ok(!container.expanded, "Parent UL container is collapsed");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_toggle_03.js b/devtools/client/markupview/test/browser_markupview_toggle_03.js
--- a/devtools/client/markupview/test/browser_markupview_toggle_03.js
+++ b/devtools/client/markupview/test/browser_markupview_toggle_03.js
@@ -1,16 +1,16 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
 // Test toggling (expand/collapse) elements by alt-clicking on twisties, which
-// should expand all the descendants
+// should expand all the descendants.
 
 const TEST_URL = TEST_URL_ROOT + "doc_markup_toggle.html";
 
 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
   info("Getting the container for the UL parent element");
   let container = yield getContainerForSelector("ul", inspector);
diff --git a/devtools/client/markupview/test/browser_markupview_update-on-navigtion.js b/devtools/client/markupview/test/browser_markupview_update-on-navigtion.js
--- a/devtools/client/markupview/test/browser_markupview_update-on-navigtion.js
+++ b/devtools/client/markupview/test/browser_markupview_update-on-navigtion.js
@@ -5,23 +5,23 @@
 
 // Test that markup view handles page navigation correctly.
 
 const SCHEMA = "data:text/html;charset=UTF-8,";
 const URL_1 = SCHEMA + "<div id='one' style='color:red;'>ONE</div>";
 const URL_2 = SCHEMA + "<div id='two' style='color:green;'>TWO</div>";
 
 add_task(function* () {
-  let { inspector, toolbox } = yield addTab(URL_1).then(openInspector);
+  let {inspector, toolbox, testActor} = yield addTab(URL_1).then(openInspector);
 
   assertMarkupViewIsLoaded();
   yield selectNode("#one", inspector);
 
   let willNavigate = toolbox.target.once("will-navigate");
-  content.location = URL_2;
+  testActor.eval(`document.location = "${URL_2}"`);
 
   info("Waiting for will-navigate");
   yield willNavigate;
 
   info("Navigation to page 2 has started, the inspector should be empty");
   assertMarkupViewIsEmpty();
 
   info("Waiting for new-root");
diff --git a/devtools/client/markupview/test/doc_markup_anonymous.html b/devtools/client/markupview/test/doc_markup_anonymous.html
--- a/devtools/client/markupview/test/doc_markup_anonymous.html
+++ b/devtools/client/markupview/test/doc_markup_anonymous.html
@@ -25,9 +25,9 @@
   <script>
   var host = document.querySelector('#shadow');
   if (host.createShadowRoot) {
     var root = host.createShadowRoot();
     root.innerHTML = '<h3>Shadow DOM</h3><select multiple></select>';
   }
   </script>
 </body>
-</html>
\ No newline at end of file
+</html>
diff --git a/devtools/client/markupview/test/head.js b/devtools/client/markupview/test/head.js
--- a/devtools/client/markupview/test/head.js
+++ b/devtools/client/markupview/test/head.js
@@ -1,11 +1,13 @@
+/* vim: set ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
 
 var Cu = Components.utils;
 var {require} = Cu.import("resource://devtools/shared/Loader.jsm", {});
 var {TargetFactory} = require("devtools/client/framework/target");
 var {console} = Cu.import("resource://gre/modules/Console.jsm", {});
 var promise = require("promise");
 var {getInplaceEditorForSpan: inplaceEditor} = require("devtools/client/shared/inplace-editor");
 var clipboard = require("sdk/clipboard");
@@ -18,16 +20,20 @@ waitForExplicitFinish();
 
 // If a test times out we want to see the complete log and not just the last few
 // lines.
 SimpleTest.requestCompleteLog();
 
 // Uncomment this pref to dump all devtools emitted events to the console.
 // Services.prefs.setBoolPref("devtools.dump.emit", true);
 
+// Import helpers registering the test-actor in remote targets
+var testDir = gTestPath.substr(0, gTestPath.lastIndexOf("/"));
+Services.scriptloader.loadSubScript(testDir + "../../../shared/test/test-actor-registry.js", this);
+
 // Set the testing flag on DevToolsUtils and reset it when the test ends
 DevToolsUtils.testing = true;
 registerCleanupFunction(() => DevToolsUtils.testing = false);
 
 // Clear preferences that may be set during the course of tests.
 registerCleanupFunction(() => {
   Services.prefs.clearUserPref("devtools.inspector.htmlPanelOpen");
   Services.prefs.clearUserPref("devtools.inspector.sidebarOpen");
@@ -132,17 +138,21 @@ function openToolbox(toolId) {
  * @return a promise that resolves when the inspector is ready
  */
 function openInspector() {
   return openToolbox("inspector").then(({toolbox}) => {
     let inspector = toolbox.getCurrentPanel();
     let eventId = "inspector-updated";
     return inspector.once("inspector-updated").then(() => {
       info("The inspector panel is active and ready");
-      return {toolbox: toolbox, inspector: inspector};
+      return registerTestActor(toolbox.target.client);
+    }).then(() => {
+      return getTestActor(toolbox);
+    }).then((testActor) => {
+      return {toolbox, inspector, testActor};
     });
   });
 }
 
 /**
  * Wait for a content -> chrome message on the message manager (the window
  * messagemanager is used).
  * @param {String} name The message name
@@ -189,30 +199,16 @@ function executeInContent(name, data={},
 /**
  * Reload the current tab location.
  */
 function reloadTab() {
   return executeInContent("devtools:test:reload", {}, {}, false);
 }
 
 /**
- * Simple DOM node accesor function that takes either a node or a string css
- * selector as argument and returns the corresponding node
- * @param {String|DOMNode} nodeOrSelector
- * @return {DOMNode|CPOW} Note that in e10s mode a CPOW object is returned which
- * doesn't implement *all* of the DOMNode's properties
- */
-function getNode(nodeOrSelector) {
-  info("Getting the node for '" + nodeOrSelector + "'");
-  return typeof nodeOrSelector === "string" ?
-    content.document.querySelector(nodeOrSelector) :
-    nodeOrSelector;
-}
-
-/**
  * Get the NodeFront for a given css selector, via the protocol
  * @param {String|NodeFront} selector
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @return {Promise} Resolves to the NodeFront instance
  */
 function getNodeFront(selector, {walker}) {
   if (selector._form) {
diff --git a/devtools/client/markupview/test/helper_attributes_test_runner.js b/devtools/client/markupview/test/helper_attributes_test_runner.js
--- a/devtools/client/markupview/test/helper_attributes_test_runner.js
+++ b/devtools/client/markupview/test/helper_attributes_test_runner.js
@@ -1,98 +1,105 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
 
 /**
  * Run a series of add-attributes tests.
  * This function will iterate over the provided tests array and run each test.
  * Each test's goal is to provide some text to be entered into the test node's
  * new-attribute field and check that the given attributes have been created.
  * After each test has run, the markup-view's undo command will be called and
  * the test runner will check if all the new attributes are gone.
- * @param {Array} tests See runAddAttributesTest for the structure
- * @param {DOMNode|String} nodeOrSelector The node or node selector
- * corresponding to an element on the current test page that has *no attributes*
- * when the test starts. It will be used to add and remove attributes.
- * @param {InspectorPanel} inspector The instance of InspectorPanel currently
- * opened
- * @return a promise that resolves when the tests have run
+ *
+ * @param  {Array} tests
+ *         See runAddAttributesTest for the structure.
+ * @param  {DOMNode|String} nodeOrSelector
+ *         The node or node selector corresponding to an element on the current
+ *         test page that has *no attributes* when the test starts.
+ *         It will be used to add and remove attributes.
+ * @param  {InspectorPanel} inspector
+ * @return {Promise}
+ *         A promise that resolves when the tests have run.
  */
 function runAddAttributesTests(tests, nodeOrSelector, inspector) {
   info("Running " + tests.length + " add-attributes tests");
   return Task.spawn(function*() {
     info("Selecting the test node");
     yield selectNode("div", inspector);
 
     for (let test of tests) {
       yield runAddAttributesTest(test, "div", inspector);
     }
   });
 }
 
 /**
  * Run a single add-attribute test.
  * See runAddAttributesTests for a description.
- * @param {Object} test A test object should contain the following properties:
- *        - desc {String} a textual description for that test, to help when
- *        reading logs
- *        - text {String} the string to be inserted into the new attribute field
- *        - expectedAttributes {Object} a key/value pair object that will be
- *        used to check the attributes on the test element
- *        - validate {Function} optional extra function that will be called after
- *        the attributes have been added and which should be used to assert some
- *        more things this test runner might not be checking. The function will
- *        be called with the following arguments:
- *          - {DOMNode} The element being tested
- *          - {MarkupContainer} The corresponding container in the markup-view
- *          - {InspectorPanel} The instance of the InspectorPanel opened
- * @param {String} selector The node selector corresponding to the test element
- * @param {InspectorPanel} inspector The instance of InspectorPanel currently
- * opened
+ *
+ * @param  {Object} test
+ *         A test object should contain the following properties:
+ *         - desc {String} a textual description for that test, to help when
+ *         reading logs
+ *         - text {String} the string to be inserted into the new attribute field
+ *         - expectedAttributes {Object} a key/value pair object that will be
+ *         used to check the attributes on the test element
+ *         - validate {Function} optional extra function that will be called after
+ *         the attributes have been added and which should be used to assert some
+ *         more things this test runner might not be checking. The function will
+ *         be called with the following arguments:
+ *           - {DOMNode} The element being tested
+ *           - {MarkupContainer} The corresponding container in the markup-view
+ *           - {InspectorPanel} The instance of the InspectorPanel opened
+ * @param  {String} selector
+ * @param  {InspectorPanel} inspector
  */
 function* runAddAttributesTest(test, selector, inspector) {
   if (test.setUp) {
     test.setUp(inspector);
   }
-  let element = getNode(selector);
 
   info("Starting add-attribute test: " + test.desc);
   yield addNewAttributes(selector, test.text, inspector);
 
   info("Assert that the attribute(s) has/have been applied correctly");
   yield assertAttributes(selector, test.expectedAttributes);
 
   if (test.validate) {
     let container = yield getContainerForSelector(selector, inspector);
-    test.validate(element, container, inspector);
+    test.validate(selector, container, inspector);
   }
 
   info("Undo the change");
   yield undoChange(inspector);
 
   info("Assert that the attribute(s) has/have been removed correctly");
   yield assertAttributes(selector, {});
+
   if (test.tearDown) {
     test.tearDown(inspector);
   }
 }
 
 /**
  * Run a series of edit-attributes tests.
  * This function will iterate over the provided tests array and run each test.
  * Each test's goal is to locate a given element on the current test page, assert
  * its current attributes, then provide the name of one of them and a value to
  * be set into it, and then check if the new attributes are correct.
  * After each test has run, the markup-view's undo and redo commands will be
  * called and the test runner will assert again that the attributes are correct.
- * @param {Array} tests See runEditAttributesTest for the structure
- * @param {InspectorPanel} inspector The instance of InspectorPanel currently
- * opened
- * @return a promise that resolves when the tests have run
+ *
+ * @param  {Array} tests
+ *         See runEditAttributesTest for the structure
+ * @param  {InspectorPanel} inspector
+ * @return {Promise}
+ *         A promise that resolves when the tests have run.
  */
 function runEditAttributesTests(tests, inspector) {
   info("Running " + tests.length + " edit-attributes tests");
   return Task.spawn(function*() {
     info("Expanding all nodes in the markup-view");
     yield inspector.markup.expandAll();
 
     for (let test of tests) {
@@ -101,29 +108,30 @@ function runEditAttributesTests(tests, i
 
     yield inspector.once("inspector-updated");
   });
 }
 
 /**
  * Run a single edit-attribute test.
  * See runEditAttributesTests for a description.
- * @param {Object} test A test object should contain the following properties:
- *        - desc {String} a textual description for that test, to help when
- *        reading logs
- *        - node {String} a css selector that will be used to select the node
- *        which will be tested during this iteration
- *        - originalAttributes {Object} a key/value pair object that will be
- *        used to check the attributes of the node before the test runs
- *        - name {String} the name of the attribute to focus the editor for
- *        - value {String} the new value to be typed in the focused editor
- *        - expectedAttributes {Object} a key/value pair object that will be
- *        used to check the attributes on the test element
- * @param {InspectorPanel} inspector The instance of InspectorPanel currently
- * opened
+ *
+ * @param  {Object} test
+ *         A test object should contain the following properties:
+  *        - desc {String} a textual description for that test, to help when
+  *        reading logs
+  *        - node {String} a css selector that will be used to select the node
+  *        which will be tested during this iteration
+  *        - originalAttributes {Object} a key/value pair object that will be
+  *        used to check the attributes of the node before the test runs
+  *        - name {String} the name of the attribute to focus the editor for
+  *        - value {String} the new value to be typed in the focused editor
+  *        - expectedAttributes {Object} a key/value pair object that will be
+  *        used to check the attributes on the test element
+ * @param {InspectorPanel} inspector
  */
 function* runEditAttributesTest(test, inspector) {
   info("Starting edit-attribute test: " + test.desc);
 
   info("Selecting the test node " + test.node);
   yield selectNode(test.node, inspector);
 
   info("Asserting that the node has the right attributes to start with");
@@ -132,17 +140,18 @@ function* runEditAttributesTest(test, in
   info("Editing attribute " + test.name + " with value " + test.value);
 
   let container = yield getContainerForSelector(test.node, inspector);
   ok(container && container.editor, "The markup-container for " + test.node +
     " was found");
 
   info("Listening for the markupmutation event");
   let nodeMutated = inspector.once("markupmutation");
-  let attr = container.editor.attrElements.get(test.name).querySelector(".editable");
+  let attr =
+    container.editor.attrElements.get(test.name).querySelector(".editable");
   setEditableFieldValue(attr, test.value, inspector);
   yield nodeMutated;
 
   info("Asserting the new attributes after edition");
   yield assertAttributes(test.node, test.expectedAttributes);
 
   info("Undo the change and assert that the attributes have been changed back");
   yield undoChange(inspector);
diff --git a/devtools/client/markupview/test/helper_events_test_runner.js b/devtools/client/markupview/test/helper_events_test_runner.js
--- a/devtools/client/markupview/test/helper_events_test_runner.js
+++ b/devtools/client/markupview/test/helper_events_test_runner.js
@@ -1,11 +1,12 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
 
 /**
  * Generator function that runs checkEventsForNode() for each object in the
  * TEST_DATA array.
  */
 function* runEventPopupTests() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
 
@@ -20,33 +21,33 @@ function* runEventPopupTests() {
   // to affect other test runs when they are GCd.
   yield promiseNextTick();
 }
 
 /**
  * Generator function that takes a selector and expected results and returns
  * the event info.
  *
- * @param {String} selector
- *        Selector pointing at the node to be inspected
+ * @param  {String} selector
+ *         Selector pointing at the node to be inspected.
  */
 function* checkEventsForNode(selector, expected, inspector) {
   let container = yield getContainerForSelector(selector, inspector);
   let evHolder = container.elt.querySelector(".markupview-events");
   let tooltip = inspector.markup.tooltip;
 
   yield selectNode(selector, inspector);
 
-  // Click button to show tooltip
+  // Click button to show tooltip.
   info("Clicking evHolder");
   EventUtils.synthesizeMouseAtCenter(evHolder, {}, inspector.markup.doc.defaultView);
   yield tooltip.once("shown");
   info("tooltip shown");
 
-  // Check values
+  // Check values.
   let content = tooltip.content;
   let headers = content.querySelectorAll(".event-header");
   let nodeFront = container.node;
   let cssSelector = nodeFront.nodeName + "#" + nodeFront.id;
 
   for (let i = 0; i < headers.length; i++) {
     info("Processing header[" + i + "] for " + cssSelector);
 
diff --git a/devtools/client/markupview/test/helper_outerhtml_test_runner.js b/devtools/client/markupview/test/helper_outerhtml_test_runner.js
--- a/devtools/client/markupview/test/helper_outerhtml_test_runner.js
+++ b/devtools/client/markupview/test/helper_outerhtml_test_runner.js
@@ -1,75 +1,84 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
 
 /**
  * Run a series of edit-outer-html tests.
  * This function will iterate over the provided tests array and run each test.
  * Each test's goal is to provide a node (a selector) and a new outer-HTML to be
  * inserted in place of the current one for that node.
  * This test runner will wait for the mutation event to be fired and will check
  * a few things. Each test may also provide its own validate function to perform
  * assertions and verify that the new outer html is correct.
- * @param {Array} tests See runEditOuterHTMLTest for the structure
- * @param {InspectorPanel} inspector The instance of InspectorPanel currently
- * opened
- * @return a promise that resolves when the tests have run
+ *
+ * @param  {Array} tests
+ *         See runEditOuterHTMLTest for the structure.
+ * @param  {InspectorPanel} inspector
+ * @param  {Actor} testActor
+ * @return {Promise}
+ *         A promise that resolves when the tests have run.
  */
-function runEditOuterHTMLTests(tests, inspector) {
+function runEditOuterHTMLTests(tests, inspector, testActor) {
   info("Running " + tests.length + " edit-outer-html tests");
   return Task.spawn(function* () {
     for (let step of TEST_DATA) {
-      yield runEditOuterHTMLTest(step, inspector);
+      yield runEditOuterHTMLTest(step, inspector, testActor);
     }
   });
 }
 
 /**
  * Run a single edit-outer-html test.
  * See runEditOuterHTMLTests for a description.
- * @param {Object} test A test object should contain the following properties:
- *        - selector {String} a css selector targeting the node to edit
- *        - oldHTML {String}
- *        - newHTML {String}
- *        - validate {Function} will be executed when the edition test is done,
- *        after the new outer-html has been inserted. Should be used to verify
- *        the actual DOM, see if it corresponds to the newHTML string provided
- * @param {InspectorPanel} inspector The instance of InspectorPanel currently
- * opened
+ *
+ * @param  {Object} test
+ *         A test object should contain the following properties:
+ *         - selector {String} a css selector targeting the node to edit
+ *         - oldHTML {String}
+ *         - newHTML {String}
+ *         - validate {Function} will be executed when the edition test is done,
+ *         after the new outer-html has been inserted. Should be used to verify
+ *         the actual DOM, see if it corresponds to the newHTML string provided
+ * @param  {InspectorPanel} inspector
+ * @param  {Actor} testActor
  */
-function* runEditOuterHTMLTest(test, inspector) {
+function* runEditOuterHTMLTest(test, inspector, testActor) {
   info("Running an edit outerHTML test on '" + test.selector + "'");
   yield selectNode(test.selector, inspector);
-  let oldNodeFront = inspector.selection.nodeFront;
 
   let onUpdated = inspector.once("inspector-updated");
 
   info("Listen for reselectedonremoved and edit the outerHTML");
   let onReselected = inspector.markup.once("reselectedonremoved");
   yield inspector.markup.updateNodeOuterHTML(inspector.selection.nodeFront,
                                              test.newHTML, test.oldHTML);
   yield onReselected;
 
-  // Typically selectedNode will === pageNode, but if a new element has been
-  // injected in front of it, this will not be the case. If this happens.
+  // Typically selectedNode will === node matched by selector,
+  // but if a new element has been injected in front of it,
+  // this will not be the case. If this happens.
   let selectedNodeFront = inspector.selection.nodeFront;
-  let pageNodeFront = yield inspector.walker.querySelector(inspector.walker.rootNode, test.selector);
-  let pageNode = getNode(test.selector);
+  let {walker} = inspector;
+  let pageNodeFront = yield walker.querySelector(walker.rootNode, test.selector);
 
   if (test.validate) {
-    yield test.validate(pageNode, pageNodeFront, selectedNodeFront, inspector);
+    let data = {selector: test.selector, pageNodeFront, selectedNodeFront};
+    yield test.validate(data, inspector, testActor);
   } else {
-    is(pageNodeFront, selectedNodeFront, "Original node (grabbed by selector) is selected");
+    is(pageNodeFront, selectedNodeFront,
+      "Original node (grabbed by selector) is selected");
     let {outerHTML} = yield getNodeInfo(test.selector);
     is(outerHTML, test.newHTML, "Outer HTML has been updated");
   }
 
   // Wait for the inspector to be fully updated to avoid causing errors by
-  // abruptly closing hanging requests when the test ends
+  // abruptly closing hanging requests when the test ends.
   yield onUpdated;
 
   let closeTagLine = inspector.markup.getContainer(pageNodeFront).closeTagLine;
   if (closeTagLine) {
-    is(closeTagLine.querySelectorAll(".theme-fg-contrast").length, 0, "No contrast class");
+    is(closeTagLine.querySelectorAll(".theme-fg-contrast").length, 0,
+      "No contrast class");
   }
 }
diff --git a/devtools/client/shared/test/test-actor.js b/devtools/client/shared/test/test-actor.js
--- a/devtools/client/shared/test/test-actor.js
+++ b/devtools/client/shared/test/test-actor.js
@@ -1,40 +1,46 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 
 "use strict";
 
-// A helper actor for brower/devtools/inspector tests.
+// A helper actor for tests. It resides in the process of the test page and
+// exposes methods to work with remote document.
+// Only common and widely used methods should be added to this actor.
+// For specific cases use testActor.eval() in your test code.
 
 var { Cc, Ci, Cu, Cr } = require("chrome");
-const {getRect, getElementFromPoint, getAdjustedQuads} = require("devtools/shared/layout/utils");
+const {getRect, getElementFromPoint, getAdjustedQuads} =
+  require("devtools/shared/layout/utils");
 const promise = require("promise");
 const {Task} = Cu.import("resource://gre/modules/Task.jsm", {});
-var DOMUtils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
+var DOMUtils = Cc["@mozilla.org/inspector/dom-utils;1"]
+                 .getService(Ci.inIDOMUtils);
 var loader = Cc["@mozilla.org/moz/jssubscript-loader;1"]
-            .getService(Ci.mozIJSSubScriptLoader);
+               .getService(Ci.mozIJSSubScriptLoader);
 var EventUtils = {};
 loader.loadSubScript("chrome://marionette/content/EventUtils.js", EventUtils);
 
 const protocol = require("devtools/server/protocol");
 const {Arg, Option, method, RetVal, types} = protocol;
 
 var dumpn = msg => {
   dump(msg + "\n");
-}
+};
 
 /**
  * Get the instance of CanvasFrameAnonymousContentHelper used by a given
  * highlighter actor.
  * The instance provides methods to get/set attributes/text/style on nodes of
  * the highlighter, inserted into the nsCanvasFrame.
- * @see /devtools/server/actors/highlighters.js
- * @param {String} actorID
+ *
+ * @see    /devtools/server/actors/highlighters.js
+ * @param  {String} actorID
  */
 function getHighlighterCanvasFrameHelper(conn, actorID) {
   let actor = conn.getActor(actorID);
   if (actor && actor._highlighter) {
     return actor._highlighter.markup;
   }
 }
 
@@ -47,72 +53,82 @@ var TestActor = exports.TestActor = prot
   },
 
   get content() {
     return this.tabActor.window;
   },
 
   /**
    * Helper to retrieve a DOM element.
-   * @param {string | array} selector Either a regular selector string
-   *   or a selector array. If an array, each item, except the last one
-   *   are considered matching an iframe, so that we can query element
-   *   within deep iframes.
+   *
+   * @param  {String|Array} selector
+   *         Either a regular selector string or a selector array.
+   *         If an array, each item, except the last one are considered
+   *         matching an iframe, so that we can query element
+   *         within deep iframes.
    */
-  _querySelector: function (selector) {
+  _querySelector: function(selector) {
     let document = this.content.document;
     if (Array.isArray(selector)) {
       let fullSelector = selector.join(" >> ");
-      while(selector.length > 1) {
+      while (selector.length > 1) {
         let str = selector.shift();
         let iframe = document.querySelector(str);
         if (!iframe) {
-          throw new Error("Unable to find element with selector \"" + str + "\"" +
-                          " (full selector:" + fullSelector + ")");
+          throw new Error("Unable to find element with selector \"" + str +
+                          "\"" + " (full selector:" + fullSelector + ")");
         }
         if (!iframe.contentWindow) {
-          throw new Error("Iframe selector doesn't target an iframe \"" + str + "\"" +
-                          " (full selector:" + fullSelector + ")");
+          throw new Error("Iframe selector doesn't target an iframe \"" +
+                          str + "\"" + " (full selector:" + fullSelector + ")");
         }
         document = iframe.contentWindow.document;
       }
       selector = selector.shift();
     }
     let node = document.querySelector(selector);
     if (!node) {
       throw new Error("Unable to find element with selector \"" + selector + "\"");
     }
     return node;
   },
+
   /**
-   * Helper to get the number of elements matching a selector
-   * @param {string} CSS selector.
+   * Helper to get the number of elements matching a selector.
+   *
+   * @param  {String} selector
    */
-  getNumberOfElementMatches: protocol.method(function (selector,
-                                                       root=this.content.document) {
+  getNumberOfElementMatches: protocol.method(function(selector,
+                                                     root=this.content.document) {
     return root.querySelectorAll(selector).length;
   }, {
     request: {
       selector: Arg(0, "string"),
     },
     response: {
       value: RetVal("number")
     }
   }),
 
   /**
    * Get a value for a given attribute name, on one of the elements of the box
    * model highlighter, given its ID.
-   * @param {Object} msg The msg.data part expects the following properties
-   * - {String} nodeID The full ID of the element to get the attribute for
-   * - {String} name The name of the attribute to get
-   * - {String} actorID The highlighter actor ID
-   * @return {String} The value, if found, null otherwise
+   *
+   * @param  {Object} msg
+   *         The msg.data part expects the following properties:
+   *         - {String} nodeID
+               The full ID of the element to get the attribute for.
+   *         - {String} name
+   *           The name of the attribute to get.
+   *         - {String} actorID
+   *           The highlighter actor ID.
+   * @return {String}
+   *         The value, if found, null otherwise.
    */
-  getHighlighterAttribute: protocol.method(function (nodeID, name, actorID) {
+  getHighlighterAttribute: protocol.method(function(nodeID, name, actorID) {
     let helper = getHighlighterCanvasFrameHelper(this.conn, actorID);
     if (helper) {
       return helper.getAttributeForElement(nodeID, name);
     }
   }, {
     request: {
       nodeID: Arg(0, "string"),
       name: Arg(1, "string"),
@@ -121,19 +137,23 @@ var TestActor = exports.TestActor = prot
     response: {
       value: RetVal("string")
     }
   }),
 
   /**
    * Get the textcontent of one of the elements of the box model highlighter,
    * given its ID.
-   * @param {String} nodeID The full ID of the element to get the attribute for
-   * @param {String} actorID The highlighter actor ID
-   * @return {String} The textcontent value
+   *
+   * @param  {String} nodeID
+   *         The full ID of the element to get the attribute for.
+   * @param  {String} actorID
+   *         The highlighter actor ID.
+   * @return {String}
+   *         The textcontent value.
    */
   getHighlighterNodeTextContent: protocol.method(function (nodeID, actorID) {
     let value;
     let helper = getHighlighterCanvasFrameHelper(this.conn, actorID);
     if (helper) {
       value = helper.getTextContentForElement(nodeID);
     }
     return value;
@@ -143,22 +163,25 @@ var TestActor = exports.TestActor = prot
       actorID: Arg(1, "string")
     },
     response: {
       value: RetVal("string")
     }
   }),
 
   /**
-   * Get the number of box-model highlighters created by the SelectorHighlighter
-   * @param {String} actorID The highlighter actor ID
-   * @return {Number} The number of box-model highlighters created, or null if the
-   * SelectorHighlighter was not found.
+   * Get the number of box-model highlighters created by the SelectorHighlighter.
+   *
+   * @param  {String} actorID
+   *         The highlighter actor ID.
+   * @return {Number}
+   *         The number of box-model highlighters created, or null if the
+   *         SelectorHighlighter was not found.
    */
-  getSelectorHighlighterBoxNb: protocol.method(function (actorID) {
+  getSelectorHighlighterBoxNb: protocol.method(function(actorID) {
     let highlighter = this.conn.getActor(actorID);
     let {_highlighter: h} = highlighter;
     if (!h || !h._highlighters) {
       return null;
     } else {
       return h._highlighters.length;
     }
   }, {
@@ -166,22 +189,26 @@ var TestActor = exports.TestActor = prot
       highlighter: Arg(0, "string"),
     },
     response: {
       value: RetVal("number")
     }
   }),
 
   /**
-   * Subscribe to the box-model highlighter's update event, modify an attribute of
-   * the currently highlighted node and send a message when the highlighter has
-   * updated.
-   * @param {String} the name of the attribute to be changed
-   * @param {String} the new value for the attribute
-   * @param {String} actorID The highlighter actor ID
+   * Subscribe to the box-model highlighter's update event,
+   * modify an attribute of the currently highlighted node
+   * and send a message when the highlighter has updated.
+   *
+   * @param  {String} name
+   *         The name of the attribute to be changed.
+   * @param  {String} value
+   *         The new value for the attribute.
+   * @param  {String} actorID
+   *         The highlighter actor ID
    */
   changeHighlightedNodeWaitForUpdate: protocol.method(function (name, value, actorID) {
     let deferred = promise.defer();
 
     let highlighter = this.conn.getActor(actorID);
     let {_highlighter: h} = highlighter;
 
     h.once("updated", () => {
@@ -196,41 +223,48 @@ var TestActor = exports.TestActor = prot
       name: Arg(0, "string"),
       value: Arg(1, "string"),
       actorID: Arg(2, "string")
     },
     response: {}
   }),
 
   /**
-   * Subscribe to a given highlighter event and respond when the event is received.
-   * @param {String} event The name of the highlighter event to listen to
-   * @param {String} actorID The highlighter actor ID
+   * Subscribe to a given highlighter event and respond when
+   * the event is received.
+   *
+   * @param  {String} event
+   *         The name of the highlighter event to listen to.
+   * @param  {String} actorID
+   *         The highlighter actor ID.
    */
-  waitForHighlighterEvent: protocol.method(function (event, actorID) {
+  waitForHighlighterEvent: protocol.method(function(event, actorID) {
     let highlighter = this.conn.getActor(actorID);
     let {_highlighter: h} = highlighter;
 
     return h.once(event);
   }, {
     request: {
       event: Arg(0, "string"),
       actorID: Arg(1, "string")
     },
     response: {}
   }),
 
   /**
    * Change the zoom level of the page.
-   * Optionally subscribe to the box-model highlighter's update event and waiting
-   * for it to refresh before responding.
-   * @param {Number} level The new zoom level
-   * @param {String} actorID Optional. The highlighter actor ID
+   * Optionally subscribe to the box-model highlighter's update event
+   * and waiting for it to refresh before responding.
+   *
+   * @param  {Number} level
+   *         The new zoom level.
+   * @param  {String} actorID (optional)
+   *         The highlighter actor ID.
    */
-  changeZoomLevel: protocol.method(function (level, actorID) {
+  changeZoomLevel: protocol.method(function(level, actorID) {
     dumpn("Zooming page to " + level);
     let deferred = promise.defer();
 
     if (actorID) {
       let actor = this.conn.getActor(actorID);
       let {_highlighter: h} = actor;
       h.once("updated", () => {
         deferred.resolve();
@@ -248,17 +282,17 @@ var TestActor = exports.TestActor = prot
   }, {
     request: {
       level: Arg(0, "string"),
       actorID: Arg(1, "string"),
     },
     response: {}
   }),
 
-  assertElementAtPoint: protocol.method(function (x, y, selector) {
+  assertElementAtPoint: protocol.method(function(x, y, selector) {
     let elementAtPoint = getElementFromPoint(this.content.document, x, y);
     if (!elementAtPoint) {
       throw new Error("Unable to find element at (" + x + ", " + y + ")");
     }
     let node = this._querySelector(selector);
     return node == elementAtPoint;
   }, {
     request: {
@@ -268,20 +302,23 @@ var TestActor = exports.TestActor = prot
     },
     response: {
       value: RetVal("boolean")
     }
   }),
 
 
   /**
-   * Get all box-model regions' adjusted boxquads for the given element
-   * @param {String} selector The node selector to target a given element
-   * @return {Object} An object with each property being a box-model region, each
-   * of them being an object with the p1/p2/p3/p4 properties
+   * Get all box-model regions' adjusted boxquads for the given element.
+   *
+   * @param  {String} selector
+   *         The node selector to target a given element.
+   * @return {Object}
+   *         An object with each property being a box-model region, each
+   *         of them being an object with the p1/p2/p3/p4 properties.
    */
   getAllAdjustedQuads: protocol.method(function(selector) {
     let regions = {};
     let node = this._querySelector(selector);
     for (let boxType of ["content", "padding", "border", "margin"]) {
       regions[boxType] = getAdjustedQuads(this.content, node, boxType);
     }
 
@@ -292,24 +329,28 @@ var TestActor = exports.TestActor = prot
     },
     response: {
       value: RetVal("json")
     }
   }),
 
   /**
    * Synthesize a mouse event on an element. This handler doesn't send a message
-   * back. Consumers should listen to specific events on the inspector/highlighter
-   * to know when the event got synthesized.
-   * @param {String} selector The node selector to get the node target for the event
-   * @param {Number} x
-   * @param {Number} y
-   * @param {Boolean} center If set to true, x/y will be ignored and
-   *                  synthesizeMouseAtCenter will be used instead
-   * @param {Object} options Other event options
+   * back. Consumers should listen to specific events on the
+   * inspector/highlighter to know when the event got synthesized.
+   *
+   * @param  {String} selector
+   *         The node selector to get the node target for the event
+   * @param  {Number} x
+   * @param  {Number} y
+   * @param  {Boolean} center
+   *         If set to true, x/y will be ignored and synthesizeMouseAtCenter
+   *         will be used instead.
+   * @param  {Object} options
+   *         Other event options.
    */
   synthesizeMouse: protocol.method(function({ selector, x, y, center, options }) {
     let node = this._querySelector(selector);
 
     if (center) {
       EventUtils.synthesizeMouseAtCenter(node, options, node.ownerDocument.defaultView);
     } else {
       EventUtils.synthesizeMouse(node, x, y, options, node.ownerDocument.defaultView);
@@ -318,48 +359,51 @@ var TestActor = exports.TestActor = prot
     request: {
       object: Arg(0, "json")
     },
     response: {}
   }),
 
   /**
   * Synthesize a key event for an element. This handler doesn't send a message
-  * back. Consumers should listen to specific events on the inspector/highlighter
-  * to know when the event got synthesized.
+  * back. Consumers should listen to specific events
+  * on the inspector/highlighter to know when the event got synthesized.
   */
   synthesizeKey: protocol.method(function ({key, options, content}) {
     EventUtils.synthesizeKey(key, options, this.content);
   }, {
     request: {
       args: Arg(0, "json")
     },
     response: {}
   }),
 
   /**
    * Check that an element currently has a pseudo-class lock.
-   * @param {String} selector The node selector to get the pseudo-class from
-   * @param {String} pseudo The pseudoclass to check for
+   *
+   * @param  {String} selector
+   *         The node selector to get the pseudo-class from.
+   * @param  {String} pseudo
+   *         The pseudoclass to check for.
    * @return {Boolean}
    */
-  hasPseudoClassLock: protocol.method(function (selector, pseudo) {
+  hasPseudoClassLock: protocol.method(function(selector, pseudo) {
     let node = this._querySelector(selector);
     return DOMUtils.hasPseudoClassLock(node, pseudo);
   }, {
     request: {
       selector: Arg(0, "string"),
       pseudo: Arg(1, "string")
     },
     response: {
       value: RetVal("boolean")
     }
   }),
 
-  loadAndWaitForCustomEvent: protocol.method(function (url) {
+  loadAndWaitForCustomEvent: protocol.method(function(url) {
     let deferred = promise.defer();
     let self = this;
     // Wait for DOMWindowCreated first, as listening on the current outerwindow
     // doesn't allow receiving test-page-processing-done.
     this.tabActor.chromeEventHandler.addEventListener("DOMWindowCreated", function onWindowCreated() {
       self.tabActor.chromeEventHandler.removeEventListener("DOMWindowCreated", onWindowCreated);
       self.content.addEventListener("test-page-processing-done", function onEvent() {
         self.content.removeEventListener("test-page-processing-done", onEvent);
@@ -371,141 +415,279 @@ var TestActor = exports.TestActor = prot
     return deferred.promise;
   }, {
     request: {
       url: Arg(0, "string")
     },
     response: {}
   }),
 
-  hasNode: protocol.method(function (selector) {
+  hasNode: protocol.method(function(selector) {
     try {
-      // _querySelector throws if the node doesn't exists
+      // _querySelector throws if the node doesn't exists.
       this._querySelector(selector);
       return true;
     } catch(e) {
       return false;
     }
   }, {
     request: {
       selector: Arg(0, "string")
     },
     response: {
       value: RetVal("boolean")
     }
   }),
 
   /**
    * Get the bounding rect for a given DOM node once.
-   * @param {String} selector selector identifier to select the DOM node
-   * @return {json} the bounding rect info
+   *
+   * @param  {String} selector
+   *         Selector identifier to select the DOM node.
+   * @return {Json}
+   *         The bounding rect info.
    */
   getBoundingClientRect: protocol.method(function (selector) {
     let node = this._querySelector(selector);
     return node.getBoundingClientRect();
   }, {
     request: {
       selector: Arg(0, "string"),
     },
     response: {
       value: RetVal("json")
     }
   }),
 
   /**
    * Set a JS property on a DOM Node.
-   * @param {String} selector The node selector
-   * @param {String} attribute The attribute name
-   * @param {String} value The attribute value
+   *
+   * @param  {String} selector
+   * @param  {String} property
+   * @param  {String} value
    */
-  setProperty: protocol.method(function (selector, property, value) {
+  setProperty: protocol.method(function(selector, property, value) {
     let node = this._querySelector(selector);
     node[property] = value;
   }, {
     request: {
       selector: Arg(0, "string"),
       property: Arg(1, "string"),
       value: Arg(2, "string")
     },
     response: {}
   }),
 
   /**
    * Get a JS property on a DOM Node.
-   * @param {String} selector The node selector
-   * @param {String} attribute The attribute name
-   * @return {String} value The attribute value
+   *
+   * @param  {String} selector
+   * @param  {String} property
+   * @return {String} value
    */
-  getProperty: protocol.method(function (selector, property) {
+  getProperty: protocol.method(function(selector, property) {
     let node = this._querySelector(selector);
     return node[property];
   }, {
     request: {
       selector: Arg(0, "string"),
       property: Arg(1, "string")
     },
     response: {
       value: RetVal("string")
     }
   }),
 
   /**
+   * Get an attribute for DOM Node.
+   *
+   * @param  {String} selector
+   * @param  {String} attribute
+   * @return {String} value
+   */
+  getAttribute: protocol.method(function(selector, attribute) {
+    let node = this._querySelector(selector);
+    return node.getAttribute(attribute);
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+      attribute: Arg(1, "string")
+    },
+    response: {
+      value: RetVal("string")
+    }
+  }),
+
+  /**
+   * Get attributes for DOM Node.
+   *
+   * @param  {String} selector
+   * @return {Array}
+   *         Array of attributes (e.g. [{name: "id", value: "value"}]).
+   */
+  getAttributes: protocol.method(function(selector) {
+    let node = this._querySelector(selector);
+    return [...node.attributes].map(attribute => {
+      return {
+        name: attribute.name,
+        value: attribute.value
+      };
+    });
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+    },
+    response: {
+      value: RetVal("json")
+    }
+  }),
+
+  /**
+   * Set attribute for DOM Node.
+   *
+   * @param  {String} selector
+   * @param  {String} attribute
+   * @param  {String} value
+   */
+  setAttribute: protocol.method(function(selector, attribute, value) {
+    let node = this._querySelector(selector);
+    node.setAttribute(attribute, value);
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+      attribute: Arg(1, "string"),
+      value: Arg(2, "string")
+    },
+    response: {}
+  }),
+
+  /**
+   * Remove attribute from DOM Node.
+   *
+   * @param  {String} selector
+   * @param  {String} attribute
+   */
+  removeAttribute: protocol.method(function(selector, attribute) {
+    let node = this._querySelector(selector);
+    node.removeAttribute(attribute);
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+      attribute: Arg(1, "string")
+    },
+    response: {}
+  }),
+
+  /**
+   * Add class to DOM Node.
+   *
+   * @param  {String} selector
+   * @param  {String} className
+   */
+  addClass: protocol.method(function(selector, className) {
+    let node = this._querySelector(selector);
+    node.classList.add(className);
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+      className: Arg(1, "string")
+    },
+    response: {}
+  }),
+
+  /**
+   * Remove class from DOM Node.
+   *
+   * @param  {String} selector
+   * @param  {String} className
+   */
+  removeClass: protocol.method(function(selector, className) {
+    let node = this._querySelector(selector);
+    node.classList.remove(className);
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+      className: Arg(1, "string")
+    },
+    response: {}
+  }),
+
+  /**
+   * Remove a DOM Node.
+   *
+   * @param  {String} selector
+   */
+  removeNode: protocol.method(function(selector) {
+    let node = this._querySelector(selector);
+    node.remove();
+  }, {
+    request: {
+      selector: Arg(0, "string")
+    },
+    response: {}
+  }),
+
+  /**
    * Reload an iframe and wait for its load event.
-   * @param {String} selector The node selector
+   *
+   * @param  {String} selector
    */
-  reloadFrame: protocol.method(function (selector) {
+  reloadFrame: protocol.method(function(selector) {
     let node = this._querySelector(selector);
 
     let deferred = promise.defer();
 
-    let onLoad = function () {
+    let onLoad = function() {
       node.removeEventListener("load", onLoad);
       deferred.resolve();
     };
     node.addEventListener("load", onLoad);
 
     node.contentWindow.location.reload();
     return deferred.promise;
   }, {
     request: {
       selector: Arg(0, "string"),
     },
     response: {}
   }),
 
   /**
    * Evaluate a JS string in the context of the content document.
-   * @param {String} js JS string to evaluate
-   * @return {json} The evaluation result
+   *
+   * @param  {String} js
+   * @return {Json}
+   *         The evaluation result
    */
-  eval: protocol.method(function (js) {
+  eval: protocol.method(function(js) {
     // We have to use a sandbox, as CSP prevent us from using eval on apps...
     let sb = Cu.Sandbox(this.content, { sandboxPrototype: this.content });
     return Cu.evalInSandbox(js, sb);
   }, {
     request: {
       js: Arg(0, "string")
     },
     response: {
       value: RetVal("nullable:json")
     }
   }),
 
   /**
    * Scrolls the window to a particular set of coordinates in the document, or
    * by the given amount if `relative` is set to `true`.
    *
-   * @param {Number} x
-   * @param {Number} y
-   * @param {Boolean} relative
-   *
-   * @return {Object} An object with x / y properties, representing the number
-   * of pixels that the document has been scrolled horizontally and vertically.
+   * @param  {Number} x
+   * @param  {Number} y
+   * @param  {Boolean} relative
+   * @return {Object}
+   *         An object with x / y properties, representing the number
+   *         of pixels that the document has been scrolled
+   *         horizontally and vertically.
    */
-  scrollWindow: protocol.method(function (x, y, relative) {
+  scrollWindow: protocol.method(function(x, y, relative) {
     if (isNaN(x) || isNaN(y)) {
       return {};
     }
 
     let deferred = promise.defer();
     this.content.addEventListener("scroll", function onScroll(event) {
       this.removeEventListener("scroll", onScroll);
 
@@ -544,35 +726,42 @@ var TestActorFront = exports.TestActorFr
   initialize: function(client, { testActor }, toolbox) {
     protocol.Front.prototype.initialize.call(this, client, { actor: testActor });
     this.manage(this);
     this.toolbox = toolbox;
   },
 
   /**
    * Zoom the current page to a given level.
-   * @param {Number} level The new zoom level.
-   * @return {Promise} The returned promise will only resolve when the
-   * highlighter has updated to the new zoom level.
+   *
+   * @param  {Number} level
+   *         The new zoom level.
+   * @return {Promise}
+   *         The returned promise will only resolve when the
+   *         highlighter has updated to the new zoom level.
    */
   zoomPageTo: function(level) {
     return this.changeZoomLevel(level, this.toolbox.highlighter.actorID);
   },
 
   changeHighlightedNodeWaitForUpdate: protocol.custom(function(name, value, highlighter) {
     return this._changeHighlightedNodeWaitForUpdate(name, value, (highlighter || this.toolbox.highlighter).actorID);
   }, {
     impl: "_changeHighlightedNodeWaitForUpdate"
   }),
 
   /**
    * Get the value of an attribute on one of the highlighter's node.
-   * @param {String} nodeID The Id of the node in the highlighter.
-   * @param {String} name The name of the attribute.
-   * @param {Object} highlighter Optional custom highlither to target
+   *
+   * @param  {String} nodeID
+   *         The Id of the node in the highlighter.
+   * @param  {String} name
+   *         The name of the attribute.
+   * @param  {Object} highlighter
+   *         Optional custom highlither to target.
    * @return {String} value
    */
   getHighlighterNodeAttribute: function(nodeID, name, highlighter) {
     return this.getHighlighterAttribute(nodeID, name, (highlighter || this.toolbox.highlighter).actorID);
   },
 
   getHighlighterNodeTextContent: protocol.custom(function(nodeID, highlighter) {
     return this._getHighlighterNodeTextContent(nodeID, (highlighter || this.toolbox.highlighter).actorID);
@@ -586,20 +775,23 @@ var TestActorFront = exports.TestActorFr
   isHighlighting: function() {
     return this.getHighlighterNodeAttribute("box-model-elements", "hidden")
       .then(value => value === null);
   },
 
   /**
    * Assert that the box-model highlighter's current position corresponds to the
    * given node boxquads.
-   * @param {String} selector The node selector to get the boxQuads from
-   * @param {Function} is assertion function to call for equality checks
-   * @param {String} prefix An optional prefix for logging information to the
-   * console.
+   *
+   * @param  {String} selector
+   *         The node selector to get the boxQuads from.
+   * @param  {Function} is
+   *         Assertion function to call for equality checks.
+   * @param  {String} prefix
+   *         An optional prefix for logging information to the console.
    */
   isNodeCorrectlyHighlighted: Task.async(function*(selector, is, prefix="") {
     prefix += (prefix ? " " : "") + selector + " ";
 
     let boxModel = yield this._getBoxModelStatus();
     let regions = yield this.getAllAdjustedQuads(selector);
 
     for (let boxType of ["content", "padding", "border", "margin"]) {
@@ -624,18 +816,18 @@ var TestActorFront = exports.TestActorFr
       top: p1.y,
       left: p1.x,
       width: p2.x - p1.x,
       height: p4.y - p1.y
     };
   }),
 
   /**
-   * Get the current positions and visibility of the various box-model highlighter
-   * elements.
+   * Get the current positions and visibility of the various box-model
+   * highlighter elements.
    */
   _getBoxModelStatus: Task.async(function*() {
     let isVisible = yield this.isHighlighting();
 
     let ret = {
       visible: isVisible
     };
 
@@ -664,19 +856,20 @@ var TestActorFront = exports.TestActorFr
     function isInside(point, polygon) {
       if (polygon.length === 0) {
         return false;
       }
 
       var n = polygon.length;
       var newPoints = polygon.slice(0);
       newPoints.push(polygon[0]);
-      var wn = 0; // wn counter
+      // wn counter.
+      var wn = 0;
 
-      // loop through all edges of the polygon
+      // Loop through all edges of the polygon.
       for (var i = 0; i < n; i++) {
         // Accept points on the edges
         let r = isLeft(newPoints[i], newPoints[i + 1], point);
         if (r === 0) {
           return true;
         }
         if (newPoints[i][1] <= point[1]) {
           if (newPoints[i + 1][1] > point[1] && r > 0) {
@@ -686,63 +879,64 @@ var TestActorFront = exports.TestActorFr
           if (newPoints[i + 1][1] <= point[1] && r < 0) {
             wn--;
           }
         }
       }
       if (wn === 0) {
         dumpn(JSON.stringify(point) + " is outside of " + JSON.stringify(polygon));
       }
-      // the point is outside only when this winding number wn===0, otherwise it's inside
+      // The point is outside only when this winding number wn===0,
+      // otherwise it's inside.
       return wn !== 0;
     }
 
     let {visible, border} = yield this._getBoxModelStatus();
     let points = border.points;
     if (visible) {
-      // Check that the node is within the box model
+      // Check that the node is within the box model.
       let { left, top, width, height } = yield this.getNodeRect(selector);
       let right = left + width;
       let bottom = top + height;
 
-      // Converts points dictionnary into an array
+      // Converts points dictionnary into an array.
       let list = [];
-      for(var i = 1; i <= 4; i++) {
+      for (var i = 1; i <= 4; i++) {
         let p = points["p" + i];
         list.push([p.x, p.y]);
       }
       points = list;
 
-      // Check that each point of the node is within the box model
+      // Check that each point of the node is within the box model.
       if (!isInside([left, top], points) ||
           !isInside([right, top], points) ||
           !isInside([right, bottom], points) ||
           !isInside([left, bottom], points)) {
         return false;
       }
       return true;
     } else {
       return false;
     }
   }),
 
   /**
-   * Get the coordinate (points attribute) from one of the polygon elements in the
-   * box model highlighter.
+   * Get the coordinate (points attribute) from one of the polygon elements
+   * in the box model highlighter.
    */
   _getPointsForRegion: Task.async(function*(region) {
     let d = yield this.getHighlighterNodeAttribute("box-model-" + region, "d");
 
     let polygons = d.match(/M[^M]+/g);
     if (!polygons) {
       return null;
     }
 
     let points = polygons[0].trim().split(" ").map(i => {
-      return i.replace(/M|L/, "").split(",")
+      return i.replace(/M|L/, "").split(",");
     });
 
     return {
       p1: {
         x: parseFloat(points[0][0]),
         y: parseFloat(points[0][1])
       },
       p2: {
@@ -760,17 +954,18 @@ var TestActorFront = exports.TestActorFr
     };
   }),
 
   /**
    * Is a given region polygon element of the box-model highlighter currently
    * hidden?
    */
   _isRegionHidden: Task.async(function*(region) {
-    let value = yield this.getHighlighterNodeAttribute("box-model-" + region, "hidden");
+    let value = yield this.getHighlighterNodeAttribute("box-model-" + region,
+                                                       "hidden");
     return value !== null;
   }),
 
   _getGuideStatus: Task.async(function*(location) {
     let id = "box-model-guide-" + location;
 
     let hidden = yield this.getHighlighterNodeAttribute(id, "hidden");
     let x1 = yield this.getHighlighterNodeAttribute(id, "x1");
@@ -783,20 +978,22 @@ var TestActorFront = exports.TestActorFr
       x1: x1,
       y1: y1,
       x2: x2,
       y2: y2
     };
   }),
 
   /**
-   * Get the coordinates of the rectangle that is defined by the 4 guides displayed
-   * in the toolbox box-model highlighter.
-   * @return {Object} Null if at least one guide is hidden. Otherwise an object
-   * with p1, p2, p3, p4 properties being {x, y} objects.
+   * Get the coordinates of the rectangle that is defined by the 4 guides
+   * displayed in the toolbox box-model highlighter.
+   *
+   * @return {Object}
+   *         Null if at least one guide is hidden. Otherwise an object
+   *         with p1, p2, p3, p4 properties being {x, y} objects.
    */
   getGuidesRectangle: Task.async(function*() {
     let tGuide = yield this._getGuideStatus("top");
     let rGuide = yield this._getGuideStatus("right");
     let bGuide = yield this._getGuideStatus("bottom");
     let lGuide = yield this._getGuideStatus("left");
 
     if (!tGuide.visible || !rGuide.visible || !bGuide.visible || !lGuide.visible) {
@@ -815,36 +1012,44 @@ var TestActorFront = exports.TestActorFr
     return this._waitForHighlighterEvent(event, this.toolbox.highlighter.actorID);
   }, {
     impl: "_waitForHighlighterEvent"
   }),
 
   /**
    * Get the "d" attribute value for one of the box-model highlighter's region
    * <path> elements, and parse it to a list of points.
-   * @param {String} region The box model region name.
-   * @param {Front} highlighter The front of the highlighter.
-   * @return {Object} The object returned has the following form:
-   * - d {String} the d attribute value
-   * - points {Array} an array of all the polygons defined by the path. Each box
-   *   is itself an Array of points, themselves being [x,y] coordinates arrays.
+   *
+   * @param  {String} region
+   *         The box model region name.
+   * @param  {Front} highlighter
+   *         The front of the highlighter.
+   * @return {Object}
+   *         The object returned has the following form:
+   *         - {String} d
+   *           The d attribute value.
+   *         - {Array} points
+   *           An array of all the polygons defined by the path. Each box
+   *           is itself an Array of points, themselves being [x,y]
+   *           coordinates arrays.
    */
   getHighlighterRegionPath: Task.async(function*(region, highlighter) {
-    let d = yield this.getHighlighterNodeAttribute("box-model-" + region, "d", highlighter);
+    let d = yield this.getHighlighterNodeAttribute("box-model-" + region, "d",
+                                                   highlighter);
     if (!d) {
       return {d: null};
     }
 
     let polygons = d.match(/M[^M]+/g);
     if (!polygons) {
       return {d};
     }
 
     let points = [];
     for (let polygon of polygons) {
       points.push(polygon.trim().split(" ").map(i => {
-        return i.replace(/M|L/, "").split(",")
+        return i.replace(/M|L/, "").split(",");
       }));
     }
 
     return {d, points};
   })
 });
