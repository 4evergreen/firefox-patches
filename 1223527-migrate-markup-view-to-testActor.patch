# HG changeset patch
# User Grisha Pushkov <grisha@push.org.ru>
# Parent  d1667f3f465389b4a5c75e5832756238fde49aa3
Bug 1223527 - Migrate markup-view tests to use testActor

diff --git a/devtools/.eslintrc b/devtools/.eslintrc
--- a/devtools/.eslintrc
+++ b/devtools/.eslintrc
@@ -91,17 +91,17 @@
     // Enforces spacing between keys and values in object literal properties.
     "key-spacing": [1, {"beforeColon": false, "afterColon": true}],
     // Allow mixed 'LF' and 'CRLF' as linebreaks.
     "linebreak-style": 0,
     // Don't enforce the maximum depth that blocks can be nested. The complexity
     // rule is a better rule to check this.
     "max-depth": 0,
     // Maximum length of a line.
-    "max-len": [1, 80],
+    "max-len": [1, 80, 4, {"ignorePattern": ".{100,}"}],
     // Maximum depth callbacks can be nested.
     "max-nested-callbacks": [2, 3],
     // Don't limit the number of parameters that can be used in a function.
     "max-params": 0,
     // Don't limit the maximum number of statement allowed in a function. We
     // already have the complexity rule that's a better measurement.
     "max-statements": 0,
     // Require a capital letter for constructors, only check if all new
diff --git a/devtools/.eslintrc.mochitests b/devtools/.eslintrc.mochitests
--- a/devtools/.eslintrc.mochitests
+++ b/devtools/.eslintrc.mochitests
@@ -1,16 +1,17 @@
 // Parent config file for all devtools browser mochitest files.
 {
   "rules": {
     // Only disallow non-global unused vars, so that head.js does not produce
     // errors.
     "no-unused-vars": [2, {"vars": "local"}]
   },
   // All globals made available in the test environment.
+  // sort it!
   "globals": {
     "add_task": true,
     "Assert": true,
     "BrowserTestUtils": true,
     "content": true,
     "ContentTask": true,
     "document": true,
     "EventUtils": true,
@@ -35,10 +36,32 @@
     "SpecialPowers": true,
     "todo": true,
     "todo_is": true,
     "todo_isnot": true,
     "waitForClipboard": true,
     "waitForExplicitFinish": true,
     "waitForFocus": true,
     "window": true,
+    "TEST_URL_ROOT": true,
+    "getNodeFront": true,
+    "addTab": true,
+    "openInspector": true,
+    "selectNode": true,
+    "getContainerForNodeFront": true,
+    "undoChange": true,
+    "getContainerForSelector": true,
+    "waitForMultipleChildrenUpdates": true,
+    "wait": true,
+    "promiseNextTick": true,
+    "loadHelperScript": true,
+    "registerTabActor": true,
+    "unregisterActor": true,
+    "openToolbox": true,
+    "clickContainer": true,
+    "once": true,
+    "executeInContent": true,
+    "contextMenuClick": true,
+    "createTestHTTPServer": true,
+    "waitForChildrenUpdated": true,
+    "Node": true,
   }
 }
diff --git a/devtools/client/markupview/test/.eslintrc b/devtools/client/markupview/test/.eslintrc
--- a/devtools/client/markupview/test/.eslintrc
+++ b/devtools/client/markupview/test/.eslintrc
@@ -1,4 +1,26 @@
 {
   // Extend from the shared list of defined globals for mochitests.
-  "extends": "../../../.eslintrc.mochitests"
+  "extends": "../../../.eslintrc.mochitests",
+  "globals": {
+    "isEditingMenuDisabled": true,
+    "isEditingMenuEnabled": true,
+    "inplaceEditor": true,
+    "simulateNodeDrag": true,
+    "simulateNodeDragAndDrop": true,
+    "simulateNodeDrop": true,
+    "CHROME_BASE": true,
+    "runEventPopupTests": true,
+    "runEditOuterHTMLTests": true,
+    "checkFocusedAttribute": true,
+    "collapseSelectionAndTab": true,
+    "collapseSelectionAndShiftTab": true,
+    "setEditableFieldValue": true,
+    "addNewAttributes": true,
+    "setNodeAttribute": true,
+    "reloadPage": true,
+    "searchUsingSelectorSearch": true,
+    "runEditAttributesTests": true,
+    "runAddAttributesTests": true,
+    "assertAttributes": true,
+  }
 }
diff --git a/devtools/client/markupview/test/browser_markupview_anonymous_01.js b/devtools/client/markupview/test/browser_markupview_anonymous_01.js
--- a/devtools/client/markupview/test/browser_markupview_anonymous_01.js
+++ b/devtools/client/markupview/test/browser_markupview_anonymous_01.js
@@ -9,36 +9,36 @@ const TEST_URL = TEST_URL_ROOT + "doc_ma

 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);

   let pseudo = yield getNodeFront("#pseudo", inspector);

   // Markup looks like: <div><::before /><span /><::after /></div>
   let children = yield inspector.walker.children(pseudo);
-  is (children.nodes.length, 3, "Children returned from walker");
+  is(children.nodes.length, 3, "Children returned from walker");

-  info ("Checking the ::before pseudo element");
+  info("Checking the ::before pseudo element");
   let before = children.nodes[0];
   yield isEditingMenuDisabled(before, inspector);

-  info ("Checking the normal child element");
+  info("Checking the normal child element");
   let span = children.nodes[1];
   yield isEditingMenuEnabled(span, inspector);

-  info ("Checking the ::after pseudo element");
+  info("Checking the ::after pseudo element");
   let after = children.nodes[2];
   yield isEditingMenuDisabled(after, inspector);

   let native = yield getNodeFront("#native", inspector);

   // Markup looks like: <div><video controls /></div>
   let nativeChildren = yield inspector.walker.children(native);
-  is (nativeChildren.nodes.length, 1, "Children returned from walker");
+  is(nativeChildren.nodes.length, 1, "Children returned from walker");

-  info ("Checking the video element");
+  info("Checking the video element");
   let video = nativeChildren.nodes[0];
-  ok (!video.isAnonymous, "<video> is not anonymous");
+  ok(!video.isAnonymous, "<video> is not anonymous");

   let videoChildren = yield inspector.walker.children(video);
-  is (videoChildren.nodes.length, 0,
+  is(videoChildren.nodes.length, 0,
     "No native children returned from walker for <video> by default");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_anonymous_02.js b/devtools/client/markupview/test/browser_markupview_anonymous_02.js
--- a/devtools/client/markupview/test/browser_markupview_anonymous_02.js
+++ b/devtools/client/markupview/test/browser_markupview_anonymous_02.js
@@ -9,21 +9,21 @@ const TEST_URL = "chrome://devtools/cont

 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);

   let toolbarbutton = yield getNodeFront("toolbarbutton", inspector);
   let children = yield inspector.walker.children(toolbarbutton);

   is(toolbarbutton.numChildren, 3, "Correct number of children");
-  is (children.nodes.length, 3, "Children returned from walker");
+  is(children.nodes.length, 3, "Children returned from walker");

   is(toolbarbutton.isAnonymous, false, "Toolbarbutton is not anonymous");
   yield isEditingMenuEnabled(toolbarbutton, inspector);

   for (let node of children.nodes) {
-    ok (node.isAnonymous, "Child is anonymous");
-    ok (node._form.isXBLAnonymous, "Child is XBL anonymous");
-    ok (!node._form.isShadowAnonymous, "Child is not shadow anonymous");
-    ok (!node._form.isNativeAnonymous, "Child is not native anonymous");
+    ok(node.isAnonymous, "Child is anonymous");
+    ok(node._form.isXBLAnonymous, "Child is XBL anonymous");
+    ok(!node._form.isShadowAnonymous, "Child is not shadow anonymous");
+    ok(!node._form.isNativeAnonymous, "Child is not native anonymous");
     yield isEditingMenuDisabled(node, inspector);
   }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_anonymous_03.js b/devtools/client/markupview/test/browser_markupview_anonymous_03.js
--- a/devtools/client/markupview/test/browser_markupview_anonymous_03.js
+++ b/devtools/client/markupview/test/browser_markupview_anonymous_03.js
@@ -12,23 +12,23 @@ const TEST_URL = TEST_URL_ROOT + "doc_ma
 add_task(function*() {
   Services.prefs.setBoolPref("dom.webcomponents.enabled", true);

   let {inspector} = yield addTab(TEST_URL).then(openInspector);

   let shadow = yield getNodeFront("#shadow", inspector.markup);
   let children = yield inspector.walker.children(shadow);

-  is (shadow.numChildren, 3, "Children of the shadow root are counted");
-  is (children.nodes.length, 3, "Children returned from walker");
+  is(shadow.numChildren, 3, "Children of the shadow root are counted");
+  is(children.nodes.length, 3, "Children returned from walker");

-  info ("Checking the ::before pseudo element");
+  info("Checking the ::before pseudo element");
   let before = children.nodes[0];
   yield isEditingMenuDisabled(before, inspector);

-  info ("Checking the <h3> shadow element");
+  info("Checking the <h3> shadow element");
   let shadowChild1 = children.nodes[1];
   yield isEditingMenuDisabled(shadowChild1, inspector);

-  info ("Checking the <select> shadow element");
+  info("Checking the <select> shadow element");
   let shadowChild2 = children.nodes[2];
   yield isEditingMenuDisabled(shadowChild2, inspector);
 });
diff --git a/devtools/client/markupview/test/browser_markupview_anonymous_04.js b/devtools/client/markupview/test/browser_markupview_anonymous_04.js
--- a/devtools/client/markupview/test/browser_markupview_anonymous_04.js
+++ b/devtools/client/markupview/test/browser_markupview_anonymous_04.js
@@ -1,36 +1,37 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */

 "use strict";

-// Test native anonymous content in the markupview with devtools.inspector.showAllAnonymousContent
-// set to true
+// Test native anonymous content in the markupview with
+// devtools.inspector.showAllAnonymousContent set to true.
 const TEST_URL = TEST_URL_ROOT + "doc_markup_anonymous.html";

 add_task(function*() {
-  Services.prefs.setBoolPref("devtools.inspector.showAllAnonymousContent", true);
+  Services.prefs.setBoolPref(
+    "devtools.inspector.showAllAnonymousContent", true);

   let {inspector} = yield addTab(TEST_URL).then(openInspector);

   let native = yield getNodeFront("#native", inspector);

   // Markup looks like: <div><video controls /></div>
   let nativeChildren = yield inspector.walker.children(native);
-  is (nativeChildren.nodes.length, 1, "Children returned from walker");
+  is(nativeChildren.nodes.length, 1, "Children returned from walker");

-  info ("Checking the video element");
+  info("Checking the video element");
   let video = nativeChildren.nodes[0];
-  ok (!video.isAnonymous, "<video> is not anonymous");
+  ok(!video.isAnonymous, "<video> is not anonymous");

   let videoChildren = yield inspector.walker.children(video);
-  is (videoChildren.nodes.length, 3, "<video> has native anonymous children");
+  is(videoChildren.nodes.length, 3, "<video> has native anonymous children");

   for (let node of videoChildren.nodes) {
-    ok (node.isAnonymous, "Child is anonymous");
-    ok (!node._form.isXBLAnonymous, "Child is not XBL anonymous");
-    ok (!node._form.isShadowAnonymous, "Child is not shadow anonymous");
-    ok (node._form.isNativeAnonymous, "Child is native anonymous");
+    ok(node.isAnonymous, "Child is anonymous");
+    ok(!node._form.isXBLAnonymous, "Child is not XBL anonymous");
+    ok(!node._form.isShadowAnonymous, "Child is not shadow anonymous");
+    ok(node._form.isNativeAnonymous, "Child is native anonymous");
     yield isEditingMenuDisabled(node, inspector);
   }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_copy_image_data.js b/devtools/client/markupview/test/browser_markupview_copy_image_data.js
--- a/devtools/client/markupview/test/browser_markupview_copy_image_data.js
+++ b/devtools/client/markupview/test/browser_markupview_copy_image_data.js
@@ -2,72 +2,72 @@
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */

 "use strict";

 // Test that image nodes have the "copy data-uri" contextual menu item enabled
 // and that clicking it puts the image data into the clipboard

-const PAGE_CONTENT = [
-  '<div></div>',
-  '<img class="data" src="data:image/png;base64,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" />',
-  '<canvas class="canvas" width="600" height="600"></canvas>'
-].join("\n");
+const TEST_URL = `
+  data:text/html;charset=utf-8,
+  <div></div>
+  <img class="data" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAdYElEQVRogVWYZ3QV5pWuz6y5694pKzNzZ26SyWQyccpkJo5jx8GOHXcbgzHYgOkgJECIYoQAIQkhoYoaoIKEQEK9HUnnqJxedXpvOk3l6OiogkB0XOLkzpo/z/2BV9a6P971re/ffvbe6/32twVB3QFC+oMEdcmMa/cT0uxnwpBCwnaEZc8J7npPMDO2n8Dop3iHNhIc2URUtoVp1XYS2iSiol3E5UeZ12YRNxSz6G1idXaU5Xk9E5MqEvNO4vMu4gk7iYSVpYSRlYSelVk1t+Mqlue1LM1pWE5ouJPQcG9WxaNZNU/ier6aNfF1wspKUM29yTGeLNq4k9CyEJdxa0HC4vwwgoDmWeBBXTJBXTIRXQqTxgPELanM2Y8QUe4krNhBWLadSfVO5saSWLaksGw5yLLpEM62j/F17SQ6cpQ5UzHLgSZuTw1yZ17L6oqd+TkLc3M25uYsLM2ZuTVnYGVOy524gltxOUuzapa+hVlNqFidkbASEbHg6SZubWfJPcgXcT1P5wysTCm5HVdxO6FkcVbK8oIMQXjsAOGxZCL6Z5mfNB5gynSQKUMKE/r9hBW7mBnbz5L1MCvOYzzwZ/A0coZH/gxuW45gbHwfbe372Dt2sWAu5PFkK6tTvdyeFnN3QcPctJK5mIaFuI7lhI47CQ2rCRX3EjJW43LuJLTcndPxYE7Dw1kJtyO9TBirMfZnMXw9FU3nGR5MDPD1kpqliJg7cQWri3rmZ+QsJlQIosYDhPT7CWn3EdYlEf0WJqzZS1C5i1lLKnc86Tzwn+Zh4AxfTeTyf+OFfBHMYslwGHvLR0grX2O44i08A4e467vC41gHD2N93J8Rczcu4e6snNWE4tk5K+VefJT7iVHuz0pYjal4mNDxJKHg3kQ/cVstNtFpBmu30pj3FvXn3sQnO8+TmX4ezo6yGpdzb2GM5cQYs1MqBCHtXsbVuwmodhHU7GFyLJmY6SAzpoPEjAdYdBznrv80D8fP8iScw59mCvnvuVIe+M8wpUjC2voR0srf0XX+VwxVvoVPdJhV7yW+jnfwzVwff1gU8/XiCE/nh3g0K+Z+TMj9mJBHs4M8mRvlaVzJFzNK7keExM3VeIcz0bXtRVSzlo7S16n8/Gf0XfmIeXcNf1yRc2d6hDszWh4uu0hM6hFMGJKZNKYwbT5IwnGEW9507oUyeRTN5slELg9CWTyOnufrqQL+OFPMfycq+GaqmAXTcdx9W9DUv81Yw7vorr6HqvY9LC1biclPcNtSyC17Kfd81dwPNHA/dIN7oSZWI83cn2zl6Ww3f1gU86c5GV9MiJg31WHvO4mi/jNGqtcjrnobYflr1Gf9B/U5L+KVneWb5WFWJgZZmlDwZMXP0owdwe1AOndDp3gYzebJVC5Pp/P4IpbPV7ELfD1TxNPJfL6YKuQP08V8Eyvhy2gRK85MIrJkHN2bMTV/yHjfZ0wO7SEo3IG/ZxvBvt2M9+/D07OH8FAaE9J0YqpsYrrzzBgKmDEXMeeoYNlTx21nPXFtOY7uEwxXfUpf4bsIC9+iO+8VmjKf50bWC9RkPI+u7QD3ox3cnxnh9qSCe3M2bsWsCJ7O5PFVooA/LZTwx/kSvojlcz+cw11/Jnd8Z7njzWbFk8WqJ4dVTw5L1jNMqtIIDCUREO1mSpJEXJbEzGgS0cGdBPs+I9K7g1D3Nvxdn+Fu34qvdzfjAwfwDR7E2ZeCqXs/hu5kjN0HMLYmoW7YzmDJOjpy3qAr5036z79N26k1XD74U+qOP09t+ouM1O5i3tXI10sq7ie0LExoWJwyIPhDoogvYvk8iGRzJ5DJHd8ZbnvOMG89ybT+CBOawwTlKbjFe3EM7MErSiYqP0pMk05ce4JF/XFmZSnMjO5lQrQDb9sGXE3r8bVuxNvyMYGOLQR7dxAS7iHQv4/AwAG8gwcxd+9B1bSZ0cvv0p3/Mo0n/pO2U2sQ5a2j9cQbFG/5MWfXfpfinT+jIf0N2gs2ccvdzJ9uabgbk3JrSsXqnAnBnUAmi650pg1pjCuScIl3Yuz+BG3bBlTNH6Fs2oD65kZ0bVuwCfcQlR9nwZjDsuU8C4ZMFvWfMzm6j1D/dvzdm3E0rcPRtA5/2yYC7Z/8GSLQvQ1vzw68vbvx9e/F0bcHc8dmdNffo6/wBerS/pXGY88zkv8xA2c3UrrleY68+vec3/RTrqW/R/uFzcwYr/J4ZoT7szLufWu/AlPPZnTtH6Ns/hBp43uIqt+kp/wVhFW/Z7T+QzQ3t+AWHWBae5o5Uw4LljwWrfksWPJYMGUzrzvB+MBObG0bsTStx3DtA6w31hPo2MJ451Y8LZvwdmzB27UVZ8dmHJ1bcXZvw927A3ffZ7h6N6C6+hqd2c/Tdvq3DJ/fRFf6enLX/Zyk5/+G8xv/k9asjfSU7CSivsTdSB8P5xQ8Xh5jZVaNoLvsVTpL19BT/jsGLr/JwOW3GbzyDpqbW/ANpzJvPseKq5i7nlKWrIXMGfNYMF9g0VLEoukccdVxHJ2b0TWuRX9tHWON67Hc3ISneye+rp14O3fg796Bt2cH7q5t2Ns+wdb+Cc6uLbh7P8E3sBFX90eMNa5HUfkRPZlrKdz0Cw6++B32/fKvqNy3hv6i7Ygu7WXSeIXVqQEezct5tKTndlyNoLf8Tfoq3mLw8vtI6jcgb9yEvm07gdFjLFrzeTR+mRVnKdOaLIKSDKY1OdxxlbPqqeKW9QLR0cOYbm5EffVDjDc3Y23fhqNzN57e/bi69+HuScLTm4Svbx/e3t24u7bhaP8UZ+eneHo+wdmzDo9wIz7hLhyt++jN/oBT7/4Te3/5Fxx74x+4fvL3DJR9ysDlLSSc1TydH+L+nJQ7CS0rCQOCgUsfILryISO1G5E1bEbXsgvXwGFi2mxu2UtZtpVw113BirOcOWMB86ZCVpzl3HaUMTeWi1e4D8219agbPsLevQfvYCo+0RE8omM4+9OwdR3A1p2EszcJr3AfPuEuvD3b8PdsIdC/FVffx7iFn+Lr38t4fxr6ut00HH6Zwi0/omr/v9N+7jW6S9+h4+K7xB3lfLE4xOqslNszelbnHQgGK9YxWr0JWd1mVNe2Ye05yLQmhxVn2bMs2y+ybCtlWn0en/gkvuEMprV5TGvzCEoyMLVtR167FnXjJ/jFaUQVmUQUZwkpsghIz2DpOYyxIxlzxx6cvfvwC/fi79tBULiNkGg740Pb8Yl34RXuIzhwmPDgCaxN+xkpW8dA8Rt0Fb1MZ+nLXM//NaGxHB7O9nF3RsbtmJG7CS+Ckas7kTfvR30zBU37IbySLG7763g61cLDyA2eTLZi78+g5vRrFCT/gq6SjwiMZjKlycc1cBRd0xZGrnyA5sZWxkczmNYVMKkvIaorIawpwiLMQN+Vhr4tCWvXPrzCffj7dhEU7iAs3sO4eA+h0RR8/Ul4e/YzLUknLs3A27kLzdUPGCx7icHy33A99z/wyT9nNXqT+zMj3IsbuBO3I1D3ZyPtPcXYUC4uXRlhey1LU518uSLlm1U1y+EeJC0nObPnBfa9+48UpLyAtH4fPvEZxofSsXbuxtmbhLM/jZD0HFO6SsZVldiHi3FKL+JXlSFpPkTf5c3Im7Zj696Lo2snnp5dTAynMC1NIyRKxte3j/GBZKZHj5CQHWV6aD+Rvm0Ya99EXPBLbp5+DkXtem45qngSE7I6KebxvA6BS3+Vcdt1pv3tTI23MR1sZ3VxlG8em/jqgYFEsA9x82kObvwJ7/xCQMZnP8HYcYw5XQkB8edMKdLxDBwgLDuDazCToKKCwfpj1Odv51TSGmovfIq84wRm0SlGr+9AXLMBW/deIsNp+Pr2MTFyhLA4lcDAAcZFKUREB5kaSmF6KIkZ0R58TeuQFf+G5s//lcHi3xNT5fAo0sKDSSGPZyUIJpxdxP19zIWETHrbiAU6eHJbxX89sfD0loqovZmumlRO7vwVJz/7KS0X1uEZPMmMOocJaTqhkTSiss+JyrMZrt1NXdZ6Sk+8T27aW+z44F9Y/+pfk536G7qufMbojd0om3dh7UkhIErDN3gQ/+BhxsVHCAwdwSc6hE+YQqB/P5PiZOKjKUwKd6C/8hbN6c/Rnv0ibuERVgPXeRzr52F8CMFiYJhZ3yAJ/wDz4X7uJST81xMLf3pgYnlyEK+2Bml7JoP1aZj6zjKlLWbOWMCCMZcVWx7zY2eJqU/RX7GB0sO/Zucb36Hy9Hoy9r7CKz8V8G/fEfDRa/+Tyqw30fQewz2agV2YhnvwKFFFJh7RMXzD6fhHTuId/hxnfyouYTLBwRQmRw4wM5KCrWkDfXkv0XHuZYztB1jxNvBlQszjxAiChEvElK2HeZ+I+3EVX67o+eaegYcLSmb83QT0DUxYbjBtbSA6Vsm0oYQlewl3nBdYsmSzZDnHtDaToZrNXDn9Ojvf/nuyU15l59of8fPvCnj9lwLOH/s9yr7TeFT5uGXnCCrPManJJ6o6z7g0h4D8HOOKXMYVufhkZ/BJ0hkfPsr4UCqRoUO4OrejrF6LuPw99C37WbBX82VCxOPEEIJZp5gpWx/zPjF3p+Xcm1XwaEnL09tjPF7UPhucwoPMutuIWa8SM1UQtxSTMOWSMGYxqc4gMHqMsDwHVUsa9ec/ISv5d5xLe4czh96grngX6sF8Io6rRGxXmLBUseC9yoKzhrCmiLDuIuGxMsJjZUQM5USMpUR0+YSVZwlJTzI+dBhPbxKW1u2oGj5F25LEtOEij2NCHsYHEMy6RcRdgyyGRrk7o+LRkp6v7jl4esfK4pQcn7EVnfgS8p5CrKNlhMYuMWmsJGEv5+74ZRZthbhEaXiGzmAWZuJXViHryEHdV4isJx+nthab6hJOXSUTrgaWwm0sh9tIOK8RNVwmarpCxFxD1FJLxFpL2FJN1FxJ1FDM5Nh5IvJT+ESHcfcdwNi2B21LEhFNIQ+mOng0I0RgkdbhUjcy5e7j9rSCp3esPL5jxWHqoK7qBAf3vs3xlLWkJ39AZupaGor3YhoqZtbVyIKnjthYHvGxfILK8/ikBfiVVbiV1ZhHKhkbqcAgKcesrMRjqCbqamTGd5O4t5mY8zqTtgaCxjqClnrCtusEbQ34zTUEzJeZsFQxY6tgxpBPUJKOR3QES3cyutZ9hFR5PJhs5VG8G4F3rBGLsppJfw8L0xLik6PcWTYh7C7jxz/6H/zz9/6CH37vL3nuB/+L//jx3/DRmz/jUn4ybt0NVqJ9rASuEjcWElTmE9JWELM0MmVrIWxqxme4jt/UiM/cQMBylbCjkZi3hYXxThaDPSwGe5gPdBHzthFxNBO03yBov07IXk/EWkPUXEbMXMSMMY+gJB2H8BDOgaN4JZnMOi7z1XwfAr2kFKu2hrmJQW7NK1iaU3P3roP+/su89OIP+NEP/44ffP9v+bu/+Qv++i8FPP+zf+JCVgpOXSfLkRHmnHXEzaVMGcqYNtcQdzQRd3Uw6+lhbryfCVcLEVczEed1JtxNxLwtxP0dzHo7iHvambQ3E7U3E3G0EHG2Eva0EHXfJOqsZ8JeRcx2kVlTAWHFKdyDabhERwlITzHnqOCPCz0I1EMFeK0N3JodZnlOTiIuZ3JSTnNzIW+8+Ut+/vN/4SfP/ZDvffd/8w/f+St+++K/U5yXjlbajlPbzIztKtPGMqJj5UyZa5mxNzPjbCXu7mTG20XM18GUp5VJVxMTzhtM2q8zYbtB1NxE2HidgK6OkOkaEUcLk54Oor42JjwtRF0NTDmqmTSVEjNdIKw4hWvwEM7+VHwjJ5izFPGHRCuCMUkREed1bsXELM4MMxESYTC0UFl5ik2fvMWPf/x9nvvxD/n5z37CmpdeYN+uT7l5rRyjug+T4joR4xX8qgu4ZBfwa8qZsFwn5mghYm7Cq69j2tPKlLuZCWcjE/YGIpYGwsYGxvUNBLX1BDTVhAz1TNqbmXC1EHY2M25rZNxSTdhcybgmn7AmG9/Icay9+7D0JOEcOEhMn8vTyXoE5pEiwuZ6liL9rMyMMhMeQiW9SnnJMVKSNvL273/Db196nt+teZFPN3zA2ZMHab9RhlrajF5ag01aiEOSi1NSgFdZTshQz4TlBiHTNXy6WqLWa0Rt9USsV4mY6wibrhIx1BPWXyM61kBUX8uksZ4Jy3XC5mt4xmpxaKtwaC7i0RThkmbhlWZgF6ZgbN+OqX0ntr4kosoM7geqEFjFxUQM9dwO93MvLmUuNIxe1kBF4VGSdnzA5g1v8e7rv+GDN9ewb8cGcs+kcKMum6Gei8j7CzGIc3HJ8vCqSvEoynDIKnArL+PT1RIYq8OprMClvohXU45XU45fXYlffYmgppaI9ioxQx3TY7VE9LX4NNXYVVVY5Bexygqxy/NwSs7iHD6OqWs3uptbMLZvx967l7DkGLccFxA4RaXMmJt4MCHmXnSEOe8gfkMnzdVZ7N38Fq/9+ie8+IsfsuZX/8bH773E8ZR11JSlIu7OQ9F/HllXOsquE8g70pG2ZqDszsE0VIJDVoFTUY55pACrpACXvAiXvAi3rBSPrJyA4gphZTWT2ktEVOX4FeW45eXY5WVYFaXYFUXYFbm4ZJk4xUfRtW5Ddf1jjK1bsXbvxic+yKz+DAK7uJSEo5VHk6MsBQZIeIXcisrQiGo5vv9D3lvzHK/88ru88JO/5YXn/ooPXvk+pw69w7WKJNpqD9JxeTeNhZu4nPUBV/M3IWo8jm2kFI+iAvNIATZpMU5FCV5VKT51GT5VBT5VFUFNLVHdVYKKMvyyYpySQhySYhyKctyaCtzqUjyqAryybByDR1E3f4a8YQP65k8xt2/D1beXCdlRBDPeDhbDQpajAyxEBliKDjEXHMCuuoqwKYuTyW+x/cOf8eGr/4cNr3+fjW/8Mx+/9k9sf/+HHN3+K5LX/wtJa7/LiW0/p+7cBmQ3T2AduoBjtACHtBC3ogSPshSPugKf9jI+TTVedTVuZTUuxSWc0ou4FSX4VBUE9JcJGqoJj1UzrinHryzGJz2HuecI2pu70d/cjq5pM/obH+Pu3cGs5giCh0sKHt9SsjonYWGin4WJfpYmBog6b2KWVtJ86QAlp9ZzOvlVsg6+TvbBNzm171VOJ/2OC0feoezE+1SdfJemC5tRNB/HMXwBt7QQ23Ae1qHzeJSluBUlOBUXcSkrcKku4VZfwaupw6utwaWqxKOtxK+7RMRQw4S5hgnjFSL6CsKaEkLyPKy9R9E070J/czvG5q0YbmzE1b2VKWkKgq/v6vjDPS2PFuUsRoXMjnexEO4l7u8gbG7ENFKKuOkkHVcOIqw7grjxJH21R+m6nEpfzWFGrh9H3nQMU28WflkxAdVFnKN5mMXZWIZycEgLcMqK/gzgUV3Gq67Gq63Bq615VhVtFaGxS0SMV5gwXmHCUPHsS6rOJyjNxNyVgvb6VsZubMbU/Anm5o24OrcQGdqL4NHCCF+syHmyJOH2VB+J8TYS/hamnU2EjM9szyEpxTiYj22kGLe0AvtwKebBQmziQhyiPOyiXJxDebhH8rAP52IaOINZnI1DkodtJBeHtACPshSftgq/7go+TTUu1SUcikq8mkt4NZUEtBUEtRWEtKWE1AUE5Nn4JRk4+1MxtG5H2/gxumvP9kfGxg9xtW4i0r8LwYPZAb64LeHr21Lux/tZDLWR8DYx7Wggaqpm1tXIhLGaoLaScU0FfsVFnCMF2MR5uIYu4B7JwyY6i0l4CmNfBmN9GRgHMrANZeOS5eFRXMCtKMSjLMGruohHXYFHXYVbVYlb9cxSfaoK/KqL+FSFBBR5+GRn8AwdxTV4AHP7NgzNH6O/thZ9/Xuor7yJ6vIb2BrXEe7ZjuDx3CBf3hriyyUxd6c6SfgaiTuvErPXErPVELPVMGW6TERfQUBVglt6AYf4HHZRDo6hbBxDZ7EOnsbcfxJz/0msg6ewDWfilOTgluUS0pcQ0BTjVhTikBZgkxbiUpbh01YxPnaFce0V/OpKfMpSvIo8vJJMXENHsAuTsHZvx9iyAUPzWgzX3kNT8zry8jXIyn6Lqe49Au2bETyZFfJkXsjj2R5uhZqIOaqZNFcxZakkZq0iMlZKVFfyrKyKPHyyXHzSc7hHsnCIT2EXZWAXZWAbPIllMB2r6CSO4dO4ZefwKs4T1BUT0BTjURXgkhfgVBbjUZcR0FcRNFwmqLvMuKYCn6IIjyQH99Dn2Pr3Y+78DEPbBvQ33kV77Q00Nb9DWfky0osvoSx/BWvDWsbbtyJ4ONPF49keHs50sBxsZMZ+mQlzGZOmZ5oyXGRirIigOo+AModxxTO5Rk5iEqZhEx3HLv4cm+g4xt4jjPWmYRlMxyXNYlyTj0t+Do8ij4CmmHF9KaGxCgJjlfj1FQS05QS1lQTUZXhk+ThHzmAfTMPcvRt960Z0N95H0/B7lNVrkFa+iPTir5GXr0F35S1czRsJ9+xCcH+ylccznTyYamPRV8+0pYKooZSorpiw9gJRfSFhbR5BVTYBxVnGZafxSzLwjqTjHvocu/gYdvExbKKjWAePYRk8hlV0Aos4A+vQKbyK8/jVBYT0F4mYKoiYKgjqy/GpS/AoS/DIi3FK87ENn8UuSsc+mIq1dy/mjs0YW9ahqHmNweL/pPf8TxkqeQH1lTcxNqzF1bKVUO9eBKvRVh5MtXF/spVFXz0xaxUTxotE9YWENPmENOcJqnMYV2bil58mIMvAJ0nHPXwch+gIloHDmPtTMQkPYew7xFhvKoa+wxiFxxkTHieoLSSkKyakv0hIf5FxfSk+TRFuRSFO2QXc8gIcklxsw5k4hk7gFKdh69uHsW0z2utrUda+wXDFbxkpexlt3TvYmjfh6tzOuHA/U5JjCFZCLaxGW1mNtrIcuMas4wpT5nIiY0UEtRcIqnMJKLMIKM4QUJxhXH6KgCwd7+hx3MNHcQ0dwSlOwypK/RbmMKb+I5j6P8c8cAK37BxuWS5ueT5ueT5OeR4O2XlsknNYR3Oe3SU5OEazcA2fwj18HFtfMvqWrSivrkVy5R1GL72Bsu49rK1b8PTtJTBwgNDIEaZVpxEs+2+yEmrhbqSNlVAzi54G4vbLTJrKiIwVEVDm4JWdwSM5iWvkBJ6Rz/+/wJ3iVByiQ1hFqZj7UzH3H8YsPPYMoP8kqs4jaLqPoRdmYBw8g3k4C8tI9p9ll+bglOXgkmbhGj2NY/A4xq5k9Dd3or62GVndRygbNmJs3Y6nP4XA0BECI58TVpxhSn8OwYKvmeXxFu5EOrgbbWcl1MK851krTZrKCChzcEtOYR08gqH3ILqu/Wg7k9B37kXXsQdN2w40bTtQt+5E1bILRctulC37UbUfRNWWymhzCrKWw6i70zEMZGIdPod99FkFbJJszMNncEjP4pJl4hjOwNSdhq41hbHWZMztB7B1peLqO4p/OJ2wPPPZukWdQ1Sfx5SlCMGcu5kFXzMr4Q7uT/Vwf6Kb5UATs/aaZxCGYsZV53AOp2PoPYi6fS+Kll0omrchb9rCSMNGRq5tYKThE0avbWH0+jZkTXuRtySjbE1F232Csb4MTKIsbCO5OKX5uOUFuBT5uBTnMY+cwiY9jVOWiXXoFKa+4xi7jmHvO4l3MJOINI+o4gJT6iIm9UVEdAUE9QWExgqJmIsQxJxNxN1N3Brv4GFMyMNYH7eCN5l11jJtrWLKXE5YX4hPnol9+Dgm4SH03cmoO3ajaH0GIW/+FOXN7ahbd6Pt3I+hJ+3bR+00Lsl5XJJ8XJICXJKCPwN4FIV4VPk4FWdxKTNxK7LwyHPwSXIJSi8QlRcxpSojrqsiPnaJ2NglpgwVhPQl+PRFeHUFuLTnEUzaGpl23GDJ38bDmJBHM/3fAlxl2lpFSFdMQJ2HT56FS5KOXXwMc38q+p4kNJ270HXsQt+1E2PPfqz9qdjFx/BKMgko8gipCwmoSvApinBJCrAPfzsbSfJwywvwqi8QNFzAqz+HX5NLSFdEzFTBnLWaJUs9C6Y65k1XmbPUM2e5SsxSTdR0iYCxFLe2AKs6l/8HXK32/y5m8HIAAAAASUVORK5CYII=">
+  <canvas class="canvas" width="600" height="600"></canvas>`;

 add_task(function*() {
-  yield addTab("data:text/html,markup view copy image as data-uri");
-  createDocument();
-  let doc = content.document;
-
-  let {inspector} = yield openInspector();
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
+  let expectedClipboard;

   yield selectNode("div", inspector);
   yield assertCopyImageDataNotAvailable(inspector);

+  expectedClipboard = yield testActor.getProperty("img", "src");
   yield selectNode("img", inspector);
   yield assertCopyImageDataAvailable(inspector);
-  yield triggerCopyImageUrlAndWaitForClipboard(doc.querySelector("img").src, inspector);
+  yield triggerCopyImageUrlAndWaitForClipboard(expectedClipboard, inspector);

+  yield drawOnCanvas(testActor);
+  expectedClipboard =
+    yield testActor.eval("document.querySelector('.canvas').toDataURL()");
   yield selectNode("canvas", inspector);
   yield assertCopyImageDataAvailable(inspector);
-  let canvas = doc.querySelector(".canvas");
-  yield triggerCopyImageUrlAndWaitForClipboard(canvas.toDataURL(), inspector);
+  yield triggerCopyImageUrlAndWaitForClipboard(expectedClipboard, inspector);

   // Check again that the menu isn't available on the DIV (to make sure our
   // menu updating mechanism works)
   yield selectNode("div", inspector);
   yield assertCopyImageDataNotAvailable(inspector);
 });

-function createDocument() {
-  let doc = content.document;
-
-  doc.body.innerHTML = PAGE_CONTENT;
-  let context = doc.querySelector(".canvas").getContext("2d");
-  context.beginPath();
-  context.moveTo(300, 0);
-  context.lineTo(600, 600);
-  context.lineTo(0, 600);
-  context.closePath();
-  context.fillStyle = "#ffc821";
-  context.fill();
+function* drawOnCanvas(testActor) {
+  yield testActor.eval(`
+    let context = document.querySelector(".canvas").getContext("2d");
+    context.beginPath();
+    context.moveTo(300, 0);
+    context.lineTo(600, 600);
+    context.lineTo(0, 600);
+    context.closePath();
+    context.fillStyle = "#ffc821";
+    context.fill();`);
 }

 function assertCopyImageDataNotAvailable(inspector) {
   return openNodeMenu(inspector).then(menu => {
-    let item = menu.getElementsByAttribute("id", "node-menu-copyimagedatauri")[0];
+    let item =
+      menu.getElementsByAttribute("id", "node-menu-copyimagedatauri")[0];
     ok(item, "The menu item was found in the contextual menu");
     is(item.getAttribute("disabled"), "true", "The menu item is disabled");
   }).then(() => closeNodeMenu(inspector));
 }

 function assertCopyImageDataAvailable(inspector) {
   return openNodeMenu(inspector).then(menu => {
-    let item = menu.getElementsByAttribute("id", "node-menu-copyimagedatauri")[0];
+    let item =
+      menu.getElementsByAttribute("id", "node-menu-copyimagedatauri")[0];
     ok(item, "The menu item was found in the contextual menu");
     is(item.getAttribute("disabled"), "", "The menu item is enabled");
   }).then(() => closeNodeMenu(inspector));
 }

 function openNodeMenu(inspector) {
   let def = promise.defer();

@@ -93,19 +93,22 @@ function closeNodeMenu(inspector) {

   return def.promise;
 }

 function triggerCopyImageUrlAndWaitForClipboard(expected, inspector) {
   let def = promise.defer();

   SimpleTest.waitForClipboard(expected, () => {
-    inspector.markup.getContainer(inspector.selection.nodeFront).copyImageDataUri();
+    inspector.markup.getContainer(inspector.selection.nodeFront)
+      .copyImageDataUri();
   }, () => {
-    ok(true, "The clipboard contains the expected value " + expected.substring(0, 50) + "...");
+    ok(true, "The clipboard contains the expected value "
+      + expected.substring(0, 50) + "...");
     def.resolve();
   }, () => {
-    ok(false, "The clipboard doesn't contain the expected value " + expected.substring(0, 50) + "...");
+    ok(false, "The clipboard doesn't contain the expected value "
+      + expected.substring(0, 50) + "...");
     def.resolve();
   });

   return def.promise;
 }
diff --git a/devtools/client/markupview/test/browser_markupview_css_completion_style_attribute.js b/devtools/client/markupview/test/browser_markupview_css_completion_style_attribute.js
--- a/devtools/client/markupview/test/browser_markupview_css_completion_style_attribute.js
+++ b/devtools/client/markupview/test/browser_markupview_css_completion_style_attribute.js
@@ -17,71 +17,71 @@ const TEST_URL = TEST_URL_ROOT + "doc_ma
 //  [
 //    what key to press,
 //    expected input box value after keypress,
 //    expected input.selectionStart,
 //    expected input.selectionEnd,
 //    is popup expected to be open ?
 //  ]
 const TEST_DATA = [
-  ['s', 's', 1, 1, false],
-  ['t', 'st', 2, 2, false],
-  ['y', 'sty', 3, 3, false],
-  ['l', 'styl', 4, 4, false],
-  ['e', 'style', 5, 5, false],
-  ['=', 'style=', 6, 6, false],
-  ['"', 'style="', 7, 7, false],
-  ['d', 'style="direction', 8, 16, true],
-  ['VK_DOWN', 'style="display', 8, 14, true],
-  ['VK_TAB', 'style="display', 14, 14, true],
-  ['VK_TAB', 'style="dominant-baseline', 24, 24, true],
-  ['VK_TAB', 'style="direction', 16, 16, true],
-  ['click_1', 'style="display', 14, 14, false],
-  [':', 'style="display:-moz-box', 15, 23, true],
-  ['n', 'style="display:none', 16, 19, false],
-  ['VK_BACK_SPACE', 'style="display:n', 16, 16, false],
-  ['VK_BACK_SPACE', 'style="display:', 15, 15, false],
-  [' ', 'style="display: -moz-box', 16, 24, true],
-  [' ', 'style="display:  -moz-box', 17, 25, true],
-  ['i', 'style="display:  inherit', 18, 24, true],
-  ['VK_RIGHT', 'style="display:  inherit', 24, 24, false],
-  [';', 'style="display:  inherit;', 25, 25, false],
-  [' ', 'style="display:  inherit; ', 26, 26, false],
-  [' ', 'style="display:  inherit;  ', 27, 27, false],
-  ['VK_LEFT', 'style="display:  inherit;  ', 26, 26, false],
-  ['c', 'style="display:  inherit; caption-side ', 27, 38, true],
-  ['o', 'style="display:  inherit; color ', 28, 31, true],
-  ['VK_RIGHT', 'style="display:  inherit; color ', 31, 31, false],
-  [' ', 'style="display:  inherit; color  ', 32, 32, false],
-  ['c', 'style="display:  inherit; color c ', 33, 33, false],
-  ['VK_BACK_SPACE', 'style="display:  inherit; color  ', 32, 32, false],
-  [':', 'style="display:  inherit; color :aliceblue ', 33, 42, true],
-  ['c', 'style="display:  inherit; color :cadetblue ', 34, 42, true],
-  ['VK_DOWN', 'style="display:  inherit; color :chartreuse ', 34, 43, true],
-  ['VK_RIGHT', 'style="display:  inherit; color :chartreuse ', 43, 43, false],
-  [' ', 'style="display:  inherit; color :chartreuse !important; ', 44, 55, true],
-  ['!', 'style="display:  inherit; color :chartreuse !important; ', 45, 55, false],
-  ['VK_RIGHT', 'style="display:  inherit; color :chartreuse !important; ', 55, 55, false],
-  ['VK_RETURN', 'style="display:  inherit; color :chartreuse !important;"', -1, -1, false]
+  ["s", "s", 1, 1, false],
+  ["t", "st", 2, 2, false],
+  ["y", "sty", 3, 3, false],
+  ["l", "styl", 4, 4, false],
+  ["e", "style", 5, 5, false],
+  ["=", "style=", 6, 6, false],
+  ["\"", "style='", 7, 7, false],
+  ["d", "style='direction", 8, 16, true],
+  ["VK_DOWN", "style='display", 8, 14, true],
+  ["VK_TAB", "style='display", 14, 14, true],
+  ["VK_TAB", "style='dominant-baseline", 24, 24, true],
+  ["VK_TAB", "style='direction", 16, 16, true],
+  ["click_1", "style='display", 14, 14, false],
+  [":", "style='display:-moz-box", 15, 23, true],
+  ["n", "style='display:none", 16, 19, false],
+  ["VK_BACK_SPACE", "style='display:n", 16, 16, false],
+  ["VK_BACK_SPACE", "style='display:", 15, 15, false],
+  [" ", "style='display: -moz-box", 16, 24, true],
+  [" ", "style='display:  -moz-box", 17, 25, true],
+  ["i", "style='display:  inherit", 18, 24, true],
+  ["VK_RIGHT", "style='display:  inherit", 24, 24, false],
+  [";", "style='display:  inherit;", 25, 25, false],
+  [" ", "style='display:  inherit; ", 26, 26, false],
+  [" ", "style='display:  inherit;  ", 27, 27, false],
+  ["VK_LEFT", "style='display:  inherit;  ", 26, 26, false],
+  ["c", "style='display:  inherit; caption-side ", 27, 38, true],
+  ["o", "style='display:  inherit; color ", 28, 31, true],
+  ["VK_RIGHT", "style='display:  inherit; color ", 31, 31, false],
+  [" ", "style='display:  inherit; color  ", 32, 32, false],
+  ["c", "style='display:  inherit; color c ", 33, 33, false],
+  ["VK_BACK_SPACE", "style='display:  inherit; color  ", 32, 32, false],
+  [":", "style='display:  inherit; color :aliceblue ", 33, 42, true],
+  ["c", "style='display:  inherit; color :cadetblue ", 34, 42, true],
+  ["VK_DOWN", "style='display:  inherit; color :chartreuse ", 34, 43, true],
+  ["VK_RIGHT", "style='display:  inherit; color :chartreuse ", 43, 43, false],
+  [" ", "style='display:  inherit; color :chartreuse !important; ", 44, 55, true],
+  ["!", "style='display:  inherit; color :chartreuse !important; ", 45, 55, false],
+  ["VK_RIGHT", "style='display:  inherit; color :chartreuse !important; ", 55, 55, false],
+  ["VK_RETURN", "style='display:  inherit; color :chartreuse !important;'", -1, -1, false]
 ];

 add_task(function*() {
   info("Opening the inspector on the test URL");
   let {inspector} = yield addTab(TEST_URL).then(openInspector);

   yield inspector.markup.expandAll();

   let nodeFront = yield getNodeFront("#node14", inspector);
   let container = getContainerForNodeFront(nodeFront, inspector);
   let attr = container.editor.newAttr;
   attr.focus();
   EventUtils.sendKey("return", inspector.panelWin);
   let editor = inplaceEditor(attr);

-  for (let i = 0; i < TEST_DATA.length; i ++) {
+  for (let i = 0; i < TEST_DATA.length; i++) {
     yield enterData(i, editor, inspector);
     yield checkData(i, editor, inspector);
   }

   while (inspector.markup.undo.canUndo()) {
     yield undoChange(inspector);
   }
 });
@@ -117,28 +117,31 @@ function enterData(index, editor, inspec
     });
   }
   EventUtils.synthesizeKey(key, {}, inspector.panelWin);

   return def.promise;
 }

 function* checkData(index, editor, inspector) {
-  let [key, completion, selStart, selEnd, popupOpen] = TEST_DATA[index];
+  let [completion, selStart, selEnd, popupOpen] = TEST_DATA[index];
   info("Test data " + index + " entered. Checking state.");

   if (selEnd != -1) {
     is(editor.input.value, completion, "Completed value is correct");
-    is(editor.input.selectionStart, selStart, "Selection start position is correct");
-    is(editor.input.selectionEnd, selEnd, "Selection end position is correct");
+    is(editor.input.selectionStart, selStart,
+      "Selection start position is correct");
+    is(editor.input.selectionEnd, selEnd,
+      "Selection end position is correct");
     if (popupOpen) {
       ok(editor.popup.isOpen, "Popup is open");
     } else {
-      ok(editor.popup._panel.state != "open" && editor.popup._panel.state != "showing",
-        "Popup is closed");
+      ok(editor.popup._panel.state != "open" &&
+         editor.popup._panel.state != "showing", "Popup is closed");
     }
   } else {
     let nodeFront = yield getNodeFront("#node14", inspector);
-    let editor = getContainerForNodeFront(nodeFront, inspector).editor;
+    editor = getContainerForNodeFront(nodeFront, inspector).editor;
     let attr = editor.attrElements.get("style").querySelector(".editable");
-    is(attr.textContent, completion, "Correct value is persisted after pressing Enter");
+    is(attr.textContent, completion,
+      "Correct value is persisted after pressing Enter");
   }
 }
diff --git a/devtools/client/markupview/test/browser_markupview_dragdrop_tooltip.js b/devtools/client/markupview/test/browser_markupview_dragdrop_tooltip.js
--- a/devtools/client/markupview/test/browser_markupview_dragdrop_tooltip.js
+++ b/devtools/client/markupview/test/browser_markupview_dragdrop_tooltip.js
@@ -15,20 +15,20 @@ add_task(function*() {
   info("Check that the src attribute of the image is a valid tooltip target");
   let isValid = yield markup.tooltip.isValidHoverTarget(target);
   ok(isValid, "The element is a valid tooltip target");

   info("Start dragging the test div");
   yield simulateNodeDrag(inspector, "div");

   info("Now check that the src attribute of the image isn't a valid target");
-  try{
+  try {
     yield markup.tooltip.isValidHoverTarget(target);
     isValid = true;
-  } catch(e) {
+  } catch (e) {
     isValid = false;
   }
   ok(!isValid, "The element is not a valid tooltip target");

   info("Stop dragging the test div");
   yield simulateNodeDrop(inspector, "div");

   info("Check again the src attribute of the image");
diff --git a/devtools/client/markupview/test/browser_markupview_events-overflow.js b/devtools/client/markupview/test/browser_markupview_events-overflow.js
--- a/devtools/client/markupview/test/browser_markupview_events-overflow.js
+++ b/devtools/client/markupview/test/browser_markupview_events-overflow.js
@@ -2,18 +2,20 @@
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */
 "use strict";

 const TEST_URL = TEST_URL_ROOT + "doc_markup_events-overflow.html";
 const TEST_DATA = [
   {
     desc: "editor overflows container",
-    initialScrollTop: -1, // scroll to bottom
-    headerToClick: 49, // last header
+    // scroll to bottom
+    initialScrollTop: -1,
+    // last header
+    headerToClick: 49,
     alignBottom: true,
     alignTop: false,
   },
   {
     desc: "header overflows the container",
     initialScrollTop: 2,
     headerToClick: 0,
     alignBottom: false,
@@ -31,17 +33,18 @@ const TEST_DATA = [
 add_task(function*() {
   let { inspector } = yield addTab(TEST_URL).then(openInspector);

   let markupContainer = yield getContainerForSelector("#events", inspector);
   let evHolder = markupContainer.elt.querySelector(".markupview-events");
   let tooltip = inspector.markup.tooltip;

   info("Clicking to open event tooltip.");
-  EventUtils.synthesizeMouseAtCenter(evHolder, {}, inspector.markup.doc.defaultView);
+  EventUtils.synthesizeMouseAtCenter(evHolder, {},
+    inspector.markup.doc.defaultView);
   yield tooltip.once("shown");
   info("EventTooltip visible.");

   let container = tooltip.content;
   let containerRect = container.getBoundingClientRect();
   let headers = container.querySelectorAll(".event-header");

   for (let data of TEST_DATA) {
@@ -70,21 +73,19 @@ add_task(function*() {
     // Wait for any scrolling to finish.
     yield promiseNextTick();

     if (data.alignTop) {
       let headerRect = header.getBoundingClientRect();

       is(Math.round(headerRect.top), Math.round(containerRect.top),
         "Clicked header is aligned with the container top.");
-
     } else if (data.alignBottom) {
       let editorRect = header.nextElementSibling.getBoundingClientRect();

       is(Math.round(editorRect.bottom), Math.round(containerRect.bottom),
         "Clicked event handler code is aligned with the container bottom.");
-
     } else {
       is(container.scrollTop, data.initialScrollTop,
         "Container did not scroll, as expected.");
     }
   }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_events.js b/devtools/client/markupview/test/browser_markupview_events.js
--- a/devtools/client/markupview/test/browser_markupview_events.js
+++ b/devtools/client/markupview/test/browser_markupview_events.js
@@ -31,51 +31,51 @@ const TEST_DATA = [
     expected: [
       {
         type: "mouseover",
         filename: TEST_URL + ":62",
         attributes: [
           "Capturing",
           "DOM2"
         ],
-        handler: 'function mouseoverHandler(event) {\n' +
-                 '  if (event.target.id !== "container") {\n' +
-                 '    let output = document.getElementById("output");\n' +
-                 '    output.textContent = event.target.textContent;\n' +
-                 '  }\n' +
-                 '}'
+        handler: "function mouseoverHandler(event) {\n" +
+                 "  if (event.target.id !== \"container\") {\n" +
+                 "    let output = document.getElementById(\"output\");\n" +
+                 "    output.textContent = event.target.textContent;\n" +
+                 "  }\n" +
+                 "}"
       }
     ]
   },
   {
     selector: "#multiple",
     expected: [
       {
         type: "click",
         filename: TEST_URL + ":69",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'function clickHandler(event) {\n' +
-                 '  let output = document.getElementById("output");\n' +
-                 '  output.textContent = "click";\n' +
-                 '}'
+        handler: "function clickHandler(event) {\n" +
+                 "  let output = document.getElementById(\"output\");\n" +
+                 "  output.textContent = \"click\";\n" +
+                 "}"
       },
       {
         type: "mouseup",
         filename: TEST_URL + ":78",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'function mouseupHandler(event) {\n' +
-                 '  let output = document.getElementById("output");\n' +
-                 '  output.textContent = "mouseup";\n' +
-                 '}'
+        handler: "function mouseupHandler(event) {\n" +
+                 "  let output = document.getElementById(\"output\");\n" +
+                 "  output.textContent = \"mouseup\";\n" +
+                 "}"
       }
     ]
   },
   {
     selector: "#DOM0",
     expected: [
       {
         type: "click",
@@ -93,65 +93,65 @@ const TEST_DATA = [
     expected: [
       {
         type: "click",
         filename: TEST_URL + ":89",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'handleEvent: function(blah) {\n' +
-                 '  alert("handleEvent clicked");\n' +
-                 '}'
+        handler: "handleEvent: function(blah) {\n" +
+                 "  alert(\"handleEvent clicked\");\n" +
+                 "}"
       }
     ]
   },
   {
     selector: "#fatarrow",
     expected: [
       {
         type: "click",
         filename: TEST_URL + ":57",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'event => {\n' +
-                 '  alert("Yay for the fat arrow!");\n' +
-                 '}'
+        handler: "event => {\n" +
+                 "  alert(\"Yay for the fat arrow!\");\n" +
+                 "}"
       }
     ]
   },
   {
     selector: "#boundhe",
     expected: [
       {
         type: "click",
         filename: TEST_URL + ":101",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'handleEvent: function() {\n' +
-                 '  alert("boundHandleEvent clicked");\n' +
-                 '}'
+        handler: "handleEvent: function() {\n" +
+                 "  alert(\"boundHandleEvent clicked\");\n" +
+                 "}"
       }
     ]
   },
   {
     selector: "#bound",
     expected: [
       {
         type: "click",
         filename: TEST_URL + ":74",
         attributes: [
           "Bubbling",
           "DOM2"
         ],
-        handler: 'function boundClickHandler(event) {\n' +
-                 '  alert("Bound event clicked");\n' +
-                 '}'
+        handler: "function boundClickHandler(event) {\n" +
+                 "  alert(\"Bound event clicked\");\n" +
+                 "}"
       }
     ]
   },
 ];

 add_task(runEventPopupTests);
diff --git a/devtools/client/markupview/test/browser_markupview_events_form.js b/devtools/client/markupview/test/browser_markupview_events_form.js
--- a/devtools/client/markupview/test/browser_markupview_events_form.js
+++ b/devtools/client/markupview/test/browser_markupview_events_form.js
@@ -12,17 +12,17 @@
 const TEST_PAGE_URL = TEST_URL_ROOT + "doc_markup_events_form.html";
 const TEST_ACTOR_URL = CHROME_BASE + "actor_events_form.js";

 var {ActorRegistryFront} = require("devtools/server/actors/actor-registry");
 var {EventsFormFront} = require(TEST_ACTOR_URL);

 add_task(function*() {
   info("Opening the Toolbox");
-  let {tab} = yield addTab(TEST_PAGE_URL);
+  yield addTab(TEST_PAGE_URL);
   let {toolbox} = yield openToolbox("webconsole");

   info("Registering test actor");
   let {registrar, front} = yield registerTestActor(toolbox);

   info("Selecting the Inspector panel");
   let inspector = yield toolbox.selectTool("inspector");
   let container = yield getContainerForSelector("#container", inspector);
diff --git a/devtools/client/markupview/test/browser_markupview_html_edit_01.js b/devtools/client/markupview/test/browser_markupview_html_edit_01.js
--- a/devtools/client/markupview/test/browser_markupview_html_edit_01.js
+++ b/devtools/client/markupview/test/browser_markupview_html_edit_01.js
@@ -8,70 +8,89 @@

 loadHelperScript("helper_outerhtml_test_runner.js");

 const TEST_DATA = [
   {
     selector: "#one",
     oldHTML: '<div id="one">First <em>Div</em></div>',
     newHTML: '<div id="one">First Div</div>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront) {
-      is(pageNode.textContent, "First Div", "New div has expected text content");
-      ok(!getNode("#one em"), "No em remaining")
+    validate: function*(data, inspector, testActor) {
+      let {selector, selectedNodeFront} = data;
+
+      is((yield testActor.getProperty(selector, "textContent")), "First Div",
+        "New div has expected text content");
+      ok(!(yield testActor.hasNode("#one em")), "No em remaining")
     }
   },
   {
     selector: "#removedChildren",
     oldHTML: '<div id="removedChildren">removedChild <i>Italic <b>Bold <u>Underline</u></b></i> Normal</div>',
     newHTML: '<div id="removedChildren">removedChild</div>'
   },
   {
     selector: "#addedChildren",
     oldHTML: '<div id="addedChildren">addedChildren</div>',
     newHTML: '<div id="addedChildren">addedChildren <i>Italic <b>Bold <u>Underline</u></b></i> Normal</div>'
   },
   {
     selector: "#addedAttribute",
     oldHTML: '<div id="addedAttribute">addedAttribute</div>',
     newHTML: '<div id="addedAttribute" class="important" disabled checked>addedAttribute</div>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront) {
+    validate: function*(data, inspector, testActor) {
+      let {selector, pageNodeFront, selectedNodeFront} = data;
+      let expectedOuterHTML = '<div id="addedAttribute" class="important" ' +
+                              'disabled="" checked="">addedAttribute</div>';
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-      is(pageNode.outerHTML, '<div id="addedAttribute" class="important" disabled="" checked="">addedAttribute</div>',
-            "Attributes have been added");
+      is((yield testActor.getProperty(selector, "outerHTML")),
+        expectedOuterHTML, "Attributes have been added");
     }
   },
   {
     selector: "#changedTag",
     oldHTML: '<div id="changedTag">changedTag</div>',
     newHTML: '<p id="changedTag" class="important">changedTag</p>'
   },
   {
     selector: "#siblings",
     oldHTML: '<div id="siblings">siblings</div>',
     newHTML: '<div id="siblings-before-sibling">before sibling</div>' +
              '<div id="siblings">siblings (updated)</div>' +
              '<div id="siblings-after-sibling">after sibling</div>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
-      let beforeSibling = getNode("#siblings-before-sibling");
-      let beforeSiblingFront = yield getNodeFront("#siblings-before-sibling", inspector);
-      let afterSibling = getNode("#siblings-after-sibling");
+    validate: function*(data, inspector, testActor) {
+      let {selector, selectedNodeFront} = data;
+
+      let [
+        beforeSiblingFront,
+        beforeSiblingText,
+        afterSiblingText,
+        selectedNodeText
+      ] = [
+        yield getNodeFront("#siblings-before-sibling", inspector),
+        yield testActor.getProperty("#siblings-before-sibling", "textContent"),
+        yield testActor.getProperty("#siblings-after-sibling", "textContent"),
+        yield testActor.getProperty(selector, "textContent")
+      ];

       is(beforeSiblingFront, selectedNodeFront, "Sibling has been selected");
-      is(pageNode.textContent, "siblings (updated)", "New div has expected text content");
-      is(beforeSibling.textContent, "before sibling", "Sibling has been inserted");
-      is(afterSibling.textContent, "after sibling", "Sibling has been inserted");
+      is(selectedNodeText, "siblings (updated)",
+        "New div has expected text content");
+      is(beforeSiblingText, "before sibling", "Sibling has been inserted");
+      is(afterSiblingText, "after sibling", "Sibling has been inserted");
     }
   }
 ];

 const TEST_URL = "data:text/html," +
   "<!DOCTYPE html>" +
   "<head><meta charset='utf-8' /></head>" +
   "<body>" +
   TEST_DATA.map(outer => outer.oldHTML).join("\n") +
   "</body>" +
   "</html>";

 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
+
   inspector.markup._frame.focus();
-  yield runEditOuterHTMLTests(TEST_DATA, inspector);
+  yield runEditOuterHTMLTests(TEST_DATA, inspector, testActor);
 });
diff --git a/devtools/client/markupview/test/browser_markupview_html_edit_02.js b/devtools/client/markupview/test/browser_markupview_html_edit_02.js
--- a/devtools/client/markupview/test/browser_markupview_html_edit_02.js
+++ b/devtools/client/markupview/test/browser_markupview_html_edit_02.js
@@ -9,93 +9,129 @@
 loadHelperScript("helper_outerhtml_test_runner.js");
 requestLongerTimeout(2);

 const TEST_DATA = [
   {
     selector: "#badMarkup1",
     oldHTML: '<div id="badMarkup1">badMarkup1</div>',
     newHTML: '<div id="badMarkup1">badMarkup1</div> hanging</div>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
+    validate: function*(data, inspector, testActor) {
+      let {selector, pageNodeFront, selectedNodeFront} = data;
+
+      let textNodeNodeName = yield testActor.eval(
+        `document.querySelector("${selector}").nextSibling.nodeName`);
+      let textNodeData = yield testActor.eval(
+        `document.querySelector("${selector}").nextSibling.data`);
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-
-      let textNode = pageNode.nextSibling;
-
-      is(textNode.nodeName, "#text", "Sibling is a text element");
-      is(textNode.data, " hanging", "New text node has expected text content");
+      is(textNodeNodeName, "#text", "Sibling is a text element");
+      is(textNodeData, " hanging", "New text node has expected text content");
     }
   },
   {
     selector: "#badMarkup2",
     oldHTML: '<div id="badMarkup2">badMarkup2</div>',
     newHTML: '<div id="badMarkup2">badMarkup2</div> hanging<div></div></div></div></body>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
+    validate: function*(data, inspector, testActor) {
+      let {selector, pageNodeFront, selectedNodeFront} = data;
+
+      let textNodeNodeName = yield testActor.eval(
+        `document.querySelector("${selector}").nextSibling.nodeName`);
+      let textNodeData = yield testActor.eval(
+        `document.querySelector("${selector}").nextSibling.data`);
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-
-      let textNode = pageNode.nextSibling;
-
-      is(textNode.nodeName, "#text", "Sibling is a text element");
-      is(textNode.data, " hanging", "New text node has expected text content");
+      is(textNodeNodeName, "#text", "Sibling is a text element");
+      is(textNodeData, " hanging", "New text node has expected text content");
     }
   },
   {
     selector: "#badMarkup3",
     oldHTML: '<div id="badMarkup3">badMarkup3</div>',
     newHTML: '<div id="badMarkup3">badMarkup3 <em>Emphasized <strong> and strong</div>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
+    validate: function*(data, inspector, testActor) {
+      let {pageNodeFront, selectedNodeFront} = data;
+
+      let emTextContent = yield testActor.eval(
+        "document.querySelector('#badMarkup3 em').textContent");
+      let strongTextContent = yield testActor.eval(
+        "document.querySelector('#badMarkup3 strong').textContent");
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-
-      let em = getNode("#badMarkup3 em");
-      let strong = getNode("#badMarkup3 strong");
-
-      is(em.textContent, "Emphasized  and strong", "<em> was auto created");
-      is(strong.textContent, " and strong", "<strong> was auto created");
+      is(emTextContent, "Emphasized  and strong", "<em> was auto created");
+      is(strongTextContent, " and strong", "<strong> was auto created");
     }
   },
   {
     selector: "#badMarkup4",
     oldHTML: '<div id="badMarkup4">badMarkup4</div>',
     newHTML: '<div id="badMarkup4">badMarkup4</p>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
+    validate: function*(data, inspector, testActor) {
+      let {pageNodeFront, selectedNodeFront} = data;
+
+      let querySelector = "document.querySelector('#badMarkup4";
+      let [
+        divTextContent,
+        divTagName,
+        pTextContent,
+        pTagName
+      ] = [
+        yield testActor.eval(querySelector + "').textContent"),
+        yield testActor.eval(querySelector + "').tagName"),
+        yield testActor.eval(querySelector + " p').textContent"),
+        yield testActor.eval(querySelector + " p').tagName"),
+      ];
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-
-      let div = getNode("#badMarkup4");
-      let p = getNode("#badMarkup4 p");
-
-      is(div.textContent, "badMarkup4", "textContent is correct");
-      is(div.tagName, "DIV", "did not change to <p> tag");
-      is(p.textContent, "", "The <p> tag has no children");
-      is(p.tagName, "P", "Created an empty <p> tag");
+      is(divTextContent, "badMarkup4", "textContent is correct");
+      is(divTagName, "DIV", "did not change to <p> tag");
+      is(pTextContent, "", "The <p> tag has no children");
+      is(pTagName, "P", "Created an empty <p> tag");
     }
   },
   {
     selector: "#badMarkup5",
     oldHTML: '<p id="badMarkup5">badMarkup5</p>',
     newHTML: '<p id="badMarkup5">badMarkup5 <div>with a nested div</div></p>',
-    validate: function*(pageNode, pageNodeFront, selectedNodeFront, inspector) {
+    validate: function*(data, inspector, testActor) {
+      let {pageNodeFront, selectedNodeFront} = data;
+
+      let querySelector = "document.querySelector('#badMarkup5";
+      let [
+        nodiv,
+        pTagName,
+        pTextContent,
+        divTagName,
+        divTextContent
+      ] = [
+        yield testActor.eval(querySelector + " div')"),
+        yield testActor.eval(querySelector + "').tagName"),
+        yield testActor.eval(querySelector + "').textContent"),
+        yield testActor.eval(querySelector + " ~ div').tagName"),
+        yield testActor.eval(querySelector + " ~ div').textContent")
+      ];
+
       is(pageNodeFront, selectedNodeFront, "Original element is selected");
-
-      let p = getNode("#badMarkup5");
-      let nodiv = getNode("#badMarkup5 div");
-      let div = getNode("#badMarkup5 ~ div");
-
       ok(!nodiv, "The invalid markup got created as a sibling");
-      is(p.textContent, "badMarkup5 ", "The <p> tag does not take in the <div> content");
-      is(p.tagName, "P", "Did not change to a <div> tag");
-      is(div.textContent, "with a nested div", "textContent is correct");
-      is(div.tagName, "DIV", "Did not change to <p> tag");
+      is(pTextContent, "badMarkup5 ",
+        "The <p> tag does not take in the <div> content");
+      is(pTagName, "P", "Did not change to a <div> tag");
+      is(divTextContent, "with a nested div", "textContent is correct");
+      is(divTagName, "DIV", "Did not change to <p> tag");
     }
   }
 ];

 const TEST_URL = "data:text/html," +
   "<!DOCTYPE html>" +
   "<head><meta charset='utf-8' /></head>" +
   "<body>" +
   TEST_DATA.map(outer => outer.oldHTML).join("\n") +
   "</body>" +
   "</html>";

 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
+
   inspector.markup._frame.focus();
-  yield runEditOuterHTMLTests(TEST_DATA, inspector);
+  yield runEditOuterHTMLTests(TEST_DATA, inspector, testActor);
 });
diff --git a/devtools/client/markupview/test/browser_markupview_html_edit_03.js b/devtools/client/markupview/test/browser_markupview_html_edit_03.js
--- a/devtools/client/markupview/test/browser_markupview_html_edit_03.js
+++ b/devtools/client/markupview/test/browser_markupview_html_edit_03.js
@@ -2,181 +2,192 @@
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */

 "use strict";

 // Test that outerHTML editing keybindings work as expected and that *special*
 // elements like <html>, <body> and <head> can be edited correctly.

-const TEST_URL = "data:text/html," +
+const TEST_URL =
+  "data:text/html," +
   "<!DOCTYPE html>" +
   "<head><meta charset='utf-8' /></head>" +
   "<body>" +
   "<div id=\"keyboard\"></div>" +
   "</body>" +
   "</html>";
 const SELECTOR = "#keyboard";
 const OLD_HTML = '<div id="keyboard"></div>';
 const NEW_HTML = '<div id="keyboard">Edited</div>';

 requestLongerTimeout(2);

 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
-
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
   inspector.markup._frame.focus();

-  info("Checking that pressing escape cancels edits");
   yield testEscapeCancels(inspector);
+  yield testF2Commits(inspector);
+  yield testBody(inspector);
+  yield testHead(inspector, testActor);

-  info("Checking that pressing F2 commits edits");
-  yield testF2Commits(inspector);
+  yield testDocumentElement(inspector, testActor, {
+    info: "Checking that editing the <html> element works like other nodes",
+    html: '<html id="updated" foo="bar"><head><title>Updated from document element</title><script>document.body.id="executed";</script></head><body><p>Hello</p></body></html>',
+    title: "Updated from document element",
+    id: "updated",
+    class: null,
+    foo: "bar",
+    bodyTextContent: "Hello"
+  });

-  info("Checking that editing the <body> element works like other nodes");
-  yield testBody(inspector);
-
-  info("Checking that editing the <head> element works like other nodes");
-  yield testHead(inspector);
-
-  info("Checking that editing the <html> element works like other nodes");
-  yield testDocumentElement(inspector);
-
-  info("Checking (again) that editing the <html> element works like other nodes");
-  yield testDocumentElement2(inspector);
+  yield testDocumentElement(inspector, testActor, {
+    info: "Checking (again) that editing the <html> element works like other nodes",
+    html: '<html class="updated" id="somethingelse"><head><title>Updated again from document element</title><script>document.body.id="executed";</script></head><body><p>Hello again</p></body></html>',
+    title: "Updated again from document element",
+    id: "somethingelse",
+    class: "updated",
+    foo: null,
+    bodyTextContent: "Hello again"
+  });
 });

-function testEscapeCancels(inspector) {
-  let def = promise.defer();
-  let node = getNode(SELECTOR);
+function* testEscapeCancels(inspector) {
+  info("Checking that pressing escape cancels edits");

-  selectNode(SELECTOR, inspector).then(() => {
-    inspector.markup.htmlEditor.on("popupshown", function onPopupShown() {
-      inspector.markup.htmlEditor.off("popupshown", onPopupShown);
+  let nodeFront;
+  yield selectNode(SELECTOR, inspector);

-      ok(inspector.markup.htmlEditor._visible, "HTML Editor is visible");
-      is(node.outerHTML, OLD_HTML, "The node is starting with old HTML.");
+  info("Opening html editor");
+  let onPopupShown = inspector.markup.htmlEditor.once("popupshown");
+  EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
+  yield onPopupShown;

-      inspector.markup.htmlEditor.on("popuphidden", function onPopupHidden() {
-        inspector.markup.htmlEditor.off("popuphidden", onPopupHidden);
-        ok(!inspector.markup.htmlEditor._visible, "HTML Editor is not visible");
+  nodeFront = yield getNodeFront(SELECTOR, inspector);
+  ok(inspector.markup.htmlEditor._visible, "HTML Editor is visible");
+  is((yield inspector.markup.getNodeOuterHTML(nodeFront)), OLD_HTML,
+    "The node is starting with old HTML.");

-        let node = getNode(SELECTOR);
-        is(node.outerHTML, OLD_HTML, "Escape cancels edits");
-        def.resolve();
-      });
+  info("Changing text, then canceling changes");
+  let onPopupHidden = inspector.markup.htmlEditor.once("popuphidden");
+  inspector.markup.htmlEditor.editor.setText(NEW_HTML);
+  EventUtils.sendKey("ESCAPE", inspector.markup.htmlEditor.doc.defaultView);
+  yield onPopupHidden;

-      inspector.markup.htmlEditor.editor.setText(NEW_HTML);
-
-      EventUtils.sendKey("ESCAPE", inspector.markup.htmlEditor.doc.defaultView);
-    });
-
-    EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
-  });
-
-  return def.promise;
+  ok(!inspector.markup.htmlEditor._visible, "HTML Editor is not visible");
+  is((yield inspector.markup.getNodeOuterHTML(nodeFront)), OLD_HTML,
+    "Escape cancels edits");
 }

-function testF2Commits(inspector) {
-  let def = promise.defer();
-  let node = getNode(SELECTOR);
+function* testF2Commits(inspector) {
+  info("Checking that pressing F2 commits edits");

-  inspector.markup.htmlEditor.on("popupshown", function onPopupShown() {
-    inspector.markup.htmlEditor.off("popupshown", onPopupShown);
+  let nodeFront;
+  yield selectNode(SELECTOR, inspector);

-    ok(inspector.markup.htmlEditor._visible, "HTML Editor is visible");
-    is(node.outerHTML, OLD_HTML, "The node is starting with old HTML.");
+  info("Opening html editor");
+  let onPopupShown = inspector.markup.htmlEditor.once("popupshown");
+  EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
+  yield onPopupShown;

-    inspector.once("markupmutation", (e, aMutations) => {
-      ok(!inspector.markup.htmlEditor._visible, "HTML Editor is not visible");
+  nodeFront = yield getNodeFront(SELECTOR, inspector);
+  ok(inspector.markup.htmlEditor._visible, "HTML Editor is visible");
+  is((yield inspector.markup.getNodeOuterHTML(nodeFront)), OLD_HTML,
+    "The node is starting with old HTML.");

-      let node = getNode(SELECTOR);
-      is(node.outerHTML, NEW_HTML, "F2 commits edits - the node has new HTML.");
-      def.resolve();
-    });
+  info("Changing text, then commiting changes");
+  let onMutation = inspector.once("markupmutation");
+  inspector.markup.htmlEditor.editor.setText(NEW_HTML);
+  EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
+  yield onMutation;

-    inspector.markup.htmlEditor.editor.setText(NEW_HTML);
-    EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
-  });
-
-  inspector.markup._frame.contentDocument.documentElement.focus();
-  EventUtils.sendKey("F2", inspector.markup._frame.contentWindow);
-
-  return def.promise;
+  // Reselect nodeFront because markup was changed.
+  nodeFront = yield getNodeFront(SELECTOR, inspector);
+  ok(!inspector.markup.htmlEditor._visible, "HTML Editor is not visible");
+  is((yield inspector.markup.getNodeOuterHTML(nodeFront)), NEW_HTML,
+    "F2 commits edits - the node has new HTML.");
 }

 function* testBody(inspector) {
-  let body = getNode("body");
+  info("Checking that editing the <body> element works like other nodes");
+
+  let walker = inspector.walker;
   let bodyHTML = '<body id="updated"><p></p></body>';
   let bodyFront = yield getNodeFront("body", inspector);
-  let doc = content.document;

+  info("Changing body HTML");
   let onReselected = inspector.markup.once("reselectedonremoved");
-  yield inspector.markup.updateNodeOuterHTML(bodyFront, bodyHTML, body.outerHTML);
+  yield inspector.markup.updateNodeOuterHTML(bodyFront, bodyHTML);
   yield onReselected;

-  is(getNode("body").outerHTML, bodyHTML, "<body> HTML has been updated");
-  is(doc.querySelectorAll("head").length, 1, "no extra <head>s have been added");
+  // Reselect bodyFront because markup was changed.
+  bodyFront = yield getNodeFront("body", inspector);
+  is((yield inspector.markup.getNodeOuterHTML(bodyFront)), bodyHTML,
+    "<body> HTML has been updated");
+  is((yield walker.querySelectorAll(walker.rootNode, "head")).length, 1,
+    "no extra <head>s have been added");

   yield inspector.once("inspector-updated");
 }

-function* testHead(inspector) {
-  let head = getNode("head");
+function* testHead(inspector, testActor) {
+  info("Checking that editing the <head> element works like other nodes");
+
+  let walker = inspector.walker;
+  let headHTML = '<head id="updated"><title>New Title</title><script>document.body.id="executed";</script></head>';
+  let headFront = yield getNodeFront("head", inspector);
+
   yield selectNode("head", inspector);

-  let headHTML = '<head id="updated"><title>New Title</title><script>window.foo="bar";</script></head>';
-  let headFront = yield getNodeFront("head", inspector);
-  let doc = content.document;
-
+  info("Changing head HTML");
   let onReselected = inspector.markup.once("reselectedonremoved");
-  yield inspector.markup.updateNodeOuterHTML(headFront, headHTML, head.outerHTML);
+  yield inspector.markup.updateNodeOuterHTML(headFront, headHTML);
   yield onReselected;

-  is(doc.title, "New Title", "New title has been added");
-  is(doc.defaultView.foo, undefined, "Script has not been executed");
-  is(doc.querySelector("head").outerHTML, headHTML, "<head> HTML has been updated");
-  is(doc.querySelectorAll("body").length, 1, "no extra <body>s have been added");
+  is((yield testActor.eval("document.title")), "New Title",
+    "New title has been added");
+  is((yield testActor.hasNode("#executed")), false,
+    "Script has not been executed");
+
+  // Reselect headFront because markup was changed.
+  headFront = yield getNodeFront("head", inspector);
+  is((yield inspector.markup.getNodeOuterHTML(headFront)), headHTML,
+    "<head> HTML has been updated");
+  is((yield walker.querySelectorAll(walker.rootNode, "body")).length, 1,
+    "no extra <body>s have been added");

   yield inspector.once("inspector-updated");
 }

-function* testDocumentElement(inspector) {
-  let doc = content.document;
-  let docElement = doc.documentElement;
-  let docElementHTML = '<html id="updated" foo="bar"><head><title>Updated from document element</title><script>window.foo="bar";</script></head><body><p>Hello</p></body></html>';
+function* testDocumentElement(inspector, testActor, data) {
+  info(data.info);
+
+  let walker = inspector.walker;
+  let docElementHTML = data.html;
   let docElementFront = yield inspector.markup.walker.documentElement();

+  info("Changing document HTML");
   let onReselected = inspector.markup.once("reselectedonremoved");
-  yield inspector.markup.updateNodeOuterHTML(docElementFront, docElementHTML, docElement.outerHTML);
+  yield inspector.markup.updateNodeOuterHTML(docElementFront, docElementHTML);
   yield onReselected;

-  is(doc.title, "Updated from document element", "New title has been added");
-  is(doc.defaultView.foo, undefined, "Script has not been executed");
-  is(doc.documentElement.id, "updated", "<html> ID has been updated");
-  is(doc.documentElement.className, "", "<html> class has been updated");
-  is(doc.documentElement.getAttribute("foo"), "bar", "<html> attribute has been updated");
-  is(doc.documentElement.outerHTML, docElementHTML, "<html> HTML has been updated");
-  is(doc.querySelectorAll("head").length, 1, "no extra <head>s have been added");
-  is(doc.querySelectorAll("body").length, 1, "no extra <body>s have been added");
-  is(doc.body.textContent, "Hello", "document.body.textContent has been updated");
+  is((yield testActor.eval("document.title")), data.title,
+    "New title has been added");
+  is((yield testActor.hasNode("#executed")), false,
+    "Script has not been executed");
+
+  is((yield testActor.getAttribute("html", "id")), data.id,
+    "<html> ID has been updated");
+  is((yield testActor.getAttribute("html", "class")), data.class,
+    "<html> class has been updated");
+  is((yield testActor.getAttribute("html", "foo")), data.foo,
+    "<html> attribute has been updated");
+
+  is((yield inspector.markup.getNodeOuterHTML(docElementFront)), docElementHTML,
+    "<head> HTML has been updated");
+  is((yield walker.querySelectorAll(walker.rootNode, "head")).length, 1,
+    "no extra <heads>s have been added");
+  is((yield walker.querySelectorAll(walker.rootNode, "body")).length, 1,
+    "no extra <body>s have been added");
+  is((yield testActor.eval("document.body.textContent")), data.bodyTextContent,
+    "document.body.textContent has been updated");
 }
-
-function* testDocumentElement2(inspector) {
-  let doc = content.document;
-  let docElement = doc.documentElement;
-  let docElementHTML = '<html class="updated" id="somethingelse"><head><title>Updated again from document element</title><script>window.foo="bar";</script></head><body><p>Hello again</p></body></html>';
-  let docElementFront = yield inspector.markup.walker.documentElement();
-
-  let onReselected = inspector.markup.once("reselectedonremoved");
-  inspector.markup.updateNodeOuterHTML(docElementFront, docElementHTML, docElement.outerHTML);
-  yield onReselected;
-
-  is(doc.title, "Updated again from document element", "New title has been added");
-  is(doc.defaultView.foo, undefined, "Script has not been executed");
-  is(doc.documentElement.id, "somethingelse", "<html> ID has been updated");
-  is(doc.documentElement.className, "updated", "<html> class has been updated");
-  is(doc.documentElement.getAttribute("foo"), null, "<html> attribute has been removed");
-  is(doc.documentElement.outerHTML, docElementHTML, "<html> HTML has been updated");
-  is(doc.querySelectorAll("head").length, 1, "no extra <head>s have been added");
-  is(doc.querySelectorAll("body").length, 1, "no extra <body>s have been added");
-  is(doc.body.textContent, "Hello again", "document.body.textContent has been updated");
-}
diff --git a/devtools/client/markupview/test/browser_markupview_image_tooltip.js b/devtools/client/markupview/test/browser_markupview_image_tooltip.js
--- a/devtools/client/markupview/test/browser_markupview_image_tooltip.js
+++ b/devtools/client/markupview/test/browser_markupview_image_tooltip.js
@@ -3,61 +3,56 @@
  http://creativecommons.org/publicdomain/zero/1.0/ */

 "use strict";

 // Test that image preview tooltips are shown on img and canvas tags in the
 // markup-view and that the tooltip actually contains an image and shows the
 // right dimension label

-const PAGE_CONTENT = [
-  '<img class="local" src="chrome://branding/content/about-logo.png" />',
-  '<img class="data" src="data:image/png;base64,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" />',
-  '<img class="remote" src="' + TEST_URL_ROOT + 'doc_markup_tooltip.png" />',
-  '<canvas class="canvas" width="600" height="600"></canvas>'
-].join("\n");
+const TEST_URL = `
+  data:text/html;charset=utf8,
+  <img class="local" src="chrome://branding/content/about-logo.png">
+  <img class="data" src="data:image/png;base64,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">
+  <img class="remote" src="${TEST_URL_ROOT}/doc_markup_tooltip.png">
+  <canvas class="canvas" width="600" height="600"></canvas>`;

 const TEST_NODES = [
   {selector: "img.local", size: "192" + " \u00D7 " + "192"},
   {selector: "img.data", size: "64" + " \u00D7 " + "64"},
   {selector: "img.remote", size: "22" + " \u00D7 " + "23"},
   {selector: ".canvas", size: "600" + " \u00D7 " + "600"}
 ];

 add_task(function*() {
-  yield addTab("data:text/html,markup view tooltip test");
-  createPage();
-
-  let {inspector} = yield openInspector();
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
+  yield drawOnCanvas(testActor);

   info("Selecting the first <img> tag");
   yield selectNode("img", inspector);

   for (let testNode of TEST_NODES) {
     let target = yield getImageTooltipTarget(testNode, inspector);
     yield assertTooltipShownOn(target, inspector);
     checkImageTooltip(testNode, inspector);
   }
 });

-function createPage() {
-  info("Fill the page with the test content");
-  content.document.body.innerHTML = PAGE_CONTENT;
+function* drawOnCanvas(testActor) {
+  info("Fill the canvas");

-  info("Fill the canvas");
-  let doc = content.document;
-  let context = doc.querySelector(".canvas").getContext("2d");
-
-  context.beginPath();
-  context.moveTo(300, 0);
-  context.lineTo(600, 600);
-  context.lineTo(0, 600);
-  context.closePath();
-  context.fillStyle = "#ffc821";
-  context.fill();
+  yield testActor.eval(`
+    let context = document.querySelector(".canvas").getContext("2d");
+    context.beginPath();
+    context.moveTo(300, 0);
+    context.lineTo(600, 600);
+    context.lineTo(0, 600);
+    context.closePath();
+    context.fillStyle = "#ffc821";
+    context.fill();`);
 }

 function* getImageTooltipTarget({selector}, inspector) {
   let nodeFront = yield getNodeFront(selector, inspector);
   let isImg = nodeFront.tagName.toLowerCase() === "img";

   let container = getContainerForNodeFront(nodeFront, inspector);

@@ -74,12 +69,13 @@ function* assertTooltipShownOn(element,
   ok(isValid, "The element is a valid hover target for the image tooltip");
 }

 function checkImageTooltip({selector, size}, {markup}) {
   let images = markup.tooltip.panel.getElementsByTagName("image");
   is(images.length, 1, "Tooltip for [" + selector + "] contains an image");

   let label = markup.tooltip.panel.querySelector(".devtools-tooltip-caption");
-  is(label.textContent, size, "Tooltip label for [" + selector + "] displays the right image size");
+  is(label.textContent, size,
+    "Tooltip label for [" + selector + "] displays the right image size");

   markup.tooltip.hide();
 }
diff --git a/devtools/client/markupview/test/browser_markupview_image_tooltip_mutations.js b/devtools/client/markupview/test/browser_markupview_image_tooltip_mutations.js
--- a/devtools/client/markupview/test/browser_markupview_image_tooltip_mutations.js
+++ b/devtools/client/markupview/test/browser_markupview_image_tooltip_mutations.js
@@ -2,26 +2,25 @@
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */

 "use strict";

 // Test that image preview tooltip shows updated content when the image src
 // changes.

+const TEST_URL = "data:text/html;charset=utf8,<p>markup view tooltip test</p><img>";
 const INITIAL_SRC = "data:image/png;base64,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";
 const UPDATED_SRC = TEST_URL_ROOT + "doc_markup_tooltip.png";

 const INITIAL_SRC_SIZE = "64" + " \u00D7 " + "64";
 const UPDATED_SRC_SIZE = "22" + " \u00D7 " + "23";

 add_task(function*() {
-  yield addTab("data:text/html,<p>markup view tooltip test</p><img>");
-
-  let { inspector } = yield openInspector();
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);

   info("Retrieving NodeFront for the <img> element.");
   let img = yield getNodeFront("img", inspector);

   info("Selecting the <img> element");
   yield selectNode(img, inspector);

   info("Adding src attribute to the image.");
@@ -47,26 +46,25 @@ add_task(function*() {
   info("Showing tooltip on the src link.");
   yield inspector.markup.tooltip.isValidHoverTarget(target);

   info("Checking that the new image was shown.");
   checkImageTooltip(UPDATED_SRC_SIZE, inspector);
 });

 /**
- * Updates the src attribute of the image. Return a Promise.
+ * Updates the src attribute of the image.
  */
-function updateImageSrc(img, newSrc, inspector) {
-  let onMutated = inspector.once("markupmutation");
-  let onModified = img.modifyAttributes([{
+function* updateImageSrc(img, newSrc, inspector) {
+  let onMutation = inspector.once("markupmutation");
+  img.modifyAttributes([{
     attributeName: "src",
     newValue: newSrc
   }]);
-
-  return Promise.all([onMutated, onModified]);
+  yield onMutation;
 }

 /**
  * Checks that the markup view tooltip contains an image element with the given
  * size.
  */
 function checkImageTooltip(size, {markup}) {
   let images = markup.tooltip.panel.getElementsByTagName("image");
diff --git a/devtools/client/markupview/test/browser_markupview_keybindings_01.js b/devtools/client/markupview/test/browser_markupview_keybindings_01.js
--- a/devtools/client/markupview/test/browser_markupview_keybindings_01.js
+++ b/devtools/client/markupview/test/browser_markupview_keybindings_01.js
@@ -4,33 +4,35 @@

 "use strict";

 // Tests tabbing through attributes on a node

 const TEST_URL = "data:text/html;charset=utf8,<div a b c d e id='test'></div>";

 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);

   info("Focusing the tag editor of the test element");
   let {editor} = yield getContainerForSelector("div", inspector);
   editor.tag.focus();

   info("Pressing tab and expecting to focus the ID attribute, always first");
   EventUtils.sendKey("tab", inspector.panelWin);
   checkFocusedAttribute("id");

   info("Hit enter to turn the attribute to edit mode");
   EventUtils.sendKey("return", inspector.panelWin);
   checkFocusedAttribute("id", true);

   // Check the order of the other attributes in the DOM to the check they appear
   // correctly in the markup-view
-  let attributes = [...getNode("div").attributes].filter(attr => attr.name !== "id");
+  let attributes = (yield testActor.getAttributes("div")).filter(attr => {
+    return attr.name !== "id";
+  });

   info("Tabbing forward through attributes in edit mode");
   for (let {name} of attributes) {
     collapseSelectionAndTab(inspector);
     checkFocusedAttribute(name, true);
   }

   info("Tabbing backward through attributes in edit mode");
diff --git a/devtools/client/markupview/test/browser_markupview_keybindings_03.js b/devtools/client/markupview/test/browser_markupview_keybindings_03.js
--- a/devtools/client/markupview/test/browser_markupview_keybindings_03.js
+++ b/devtools/client/markupview/test/browser_markupview_keybindings_03.js
@@ -6,17 +6,17 @@

 // Tests that selecting a node with the mouse (by clicking on the line) focuses
 // the first focusable element in the corresponding MarkupContainer so that the
 // keyboard can be used immediately.

 const TEST_URL = "data:text/html;charset=utf8,<div class='test-class'></div>Text node";

 add_task(function*() {
-  let {inspector, toolbox} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);
   let {walker} = inspector;

   info("Select the test node to have the 2 test containers visible");
   yield selectNode("div", inspector);

   let divFront = yield walker.querySelector(walker.rootNode, "div");
   let textFront = yield walker.nextSibling(divFront);

diff --git a/devtools/client/markupview/test/browser_markupview_keybindings_04.js b/devtools/client/markupview/test/browser_markupview_keybindings_04.js
--- a/devtools/client/markupview/test/browser_markupview_keybindings_04.js
+++ b/devtools/client/markupview/test/browser_markupview_keybindings_04.js
@@ -7,20 +7,20 @@

 // Tests that selecting a node using the browser context menu (inspect element)
 // or the element picker focuses that node so that the keyboard can be used
 // immediately.

 const TEST_URL = "data:text/html;charset=utf8,<div>test element</div>";

 add_task(function*() {
-  let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);

   info("Select the test node with the browser ctx menu");
-  yield selectWithBrowserMenu(inspector);
+  yield selectWithBrowserMenu(inspector, testActor);
   assertNodeSelected(inspector, "div");

   info("Press arrowUp to focus <body> " +
        "(which works if the node was focused properly)");
   yield selectPreviousNodeWithArrowUp(inspector);
   assertNodeSelected(inspector, "body");

   info("Select the test node with the element picker");
@@ -33,36 +33,29 @@ add_task(function*() {
   assertNodeSelected(inspector, "body");
 });

 function assertNodeSelected(inspector, tagName) {
   is(inspector.selection.nodeFront.tagName.toLowerCase(), tagName,
     `The <${tagName}> node is selected`);
 }

-function selectPreviousNodeWithArrowUp(inspector) {
-  let onNodeHighlighted = inspector.toolbox.once("node-highlight");
+function* selectPreviousNodeWithArrowUp(inspector) {
   let onUpdated = inspector.once("inspector-updated");
   EventUtils.synthesizeKey("VK_UP", {});
-  return Promise.all([onUpdated, onNodeHighlighted]);
+  yield onUpdated;
 }

-function* selectWithBrowserMenu(inspector) {
+function* selectWithBrowserMenu(inspector, testActor) {
   yield BrowserTestUtils.synthesizeMouseAtCenter("div", {
     type: "contextmenu",
     button: 2
   }, gBrowser.selectedBrowser);

-  // nsContextMenu also requires the popupNode to be set, but we can't set it to
-  // node under e10s as it's a CPOW, not a DOM node. But under e10s,
-  // nsContextMenu won't use the property anyway, so just try/catching is ok.
-  try {
-    document.popupNode = getNode("div");
-  } catch (e) {}
-
+  yield testActor.eval("document.popupNode = document.querySelector('div')");
   let contentAreaContextMenu = document.querySelector("#contentAreaContextMenu");
   let contextMenu = new nsContextMenu(contentAreaContextMenu);
   yield contextMenu.inspectNode();

   contentAreaContextMenu.hidden = true;
   contentAreaContextMenu.hidePopup();
   contextMenu.hiding();

diff --git a/devtools/client/markupview/test/browser_markupview_links_01.js b/devtools/client/markupview/test/browser_markupview_links_01.js
--- a/devtools/client/markupview/test/browser_markupview_links_01.js
+++ b/devtools/client/markupview/test/browser_markupview_links_01.js
@@ -111,14 +111,16 @@ add_task(function*() {

     for (let {attributeName, links} of attributes) {
       info("Testing attribute " + attributeName);
       let linkEls = editor.attrElements.get(attributeName).querySelectorAll(".link");

       is(linkEls.length, links.length, "The right number of links were found");

       for (let i = 0; i < links.length; i ++) {
-        is(linkEls[i].dataset.type, links[i].type, "Link " + i + " has the right type");
-        is(linkEls[i].textContent, links[i].value, "Link " + i + " has the right value");
+        is(linkEls[i].dataset.type, links[i].type,
+          "Link " + i + " has the right type");
+        is(linkEls[i].textContent, links[i].value,
+          "Link " + i + " has the right value");
       }
     }
   }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_links_05.js b/devtools/client/markupview/test/browser_markupview_links_05.js
--- a/devtools/client/markupview/test/browser_markupview_links_05.js
+++ b/devtools/client/markupview/test/browser_markupview_links_05.js
@@ -62,17 +62,17 @@ add_task(function*() {

   ok(true, "The node selection failed");
   is(inspector.selection.nodeFront.tagName.toLowerCase(), "output",
     "The <output> node is still selected");
 });

 function waitForTabLoad(tab) {
   let def = promise.defer();
-  tab.addEventListener("load", function onLoad(e) {
+  tab.addEventListener("load", function onLoad() {
     // Skip load event for about:blank
     if (tab.linkedBrowser.currentURI.spec === "about:blank") {
       return;
     }
     tab.removeEventListener("load", onLoad);
     def.resolve();
   });
   return def.promise;
diff --git a/devtools/client/markupview/test/browser_markupview_mutation_01.js b/devtools/client/markupview/test/browser_markupview_mutation_01.js
--- a/devtools/client/markupview/test/browser_markupview_mutation_01.js
+++ b/devtools/client/markupview/test/browser_markupview_mutation_01.js
@@ -12,203 +12,202 @@ const TEST_URL = TEST_URL_ROOT + "doc_ma
 // - desc: for logging only
 // - numMutations: how many mutations are expected to come happen due to the
 //   test case.  Defaults to 1 if not set.
 // - test: a function supposed to mutate the DOM
 // - check: a function supposed to test that the mutation was handled
 const TEST_DATA = [
   {
     desc: "Adding an attribute",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.setAttribute("newattr", "newattrval");
+    test: function*(testActor) {
+      yield testActor.setAttribute("#node1", "newattr", "newattrval");
     },
     check: function*(inspector) {
       let {editor} = yield getContainerForSelector("#node1", inspector);
       ok([...editor.attrList.querySelectorAll(".attreditor")].some(attr => {
         return attr.textContent.trim() === "newattr=\"newattrval\"";
       }), "newattr attribute found");
     }
   },
   {
     desc: "Removing an attribute",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.removeAttribute("newattr");
+    test: function*(testActor) {
+      yield testActor.removeAttribute("#node1", "newattr");
     },
     check: function*(inspector) {
       let {editor} = yield getContainerForSelector("#node1", inspector);
       ok(![...editor.attrList.querySelectorAll(".attreditor")].some(attr => {
         return attr.textContent.trim() === "newattr=\"newattrval\"";
       }), "newattr attribute removed");
     }
   },
   {
     desc: "Re-adding an attribute",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.setAttribute("newattr", "newattrval");
+    test: function*(testActor) {
+      yield testActor.setAttribute("#node1", "newattr", "newattrval");
     },
     check: function*(inspector) {
       let {editor} = yield getContainerForSelector("#node1", inspector);
       ok([...editor.attrList.querySelectorAll(".attreditor")].some(attr => {
         return attr.textContent.trim() === "newattr=\"newattrval\"";
       }), "newattr attribute found");
     }
   },
   {
     desc: "Changing an attribute",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.setAttribute("newattr", "newattrchanged");
+    test: function*(testActor) {
+      yield testActor.setAttribute("#node1", "newattr", "newattrchanged");
     },
     check: function*(inspector) {
       let {editor} = yield getContainerForSelector("#node1", inspector);
       ok([...editor.attrList.querySelectorAll(".attreditor")].some(attr => {
         return attr.textContent.trim() === "newattr=\"newattrchanged\"";
       }), "newattr attribute found");
     }
   },
   {
     desc: "Adding ::after element",
-    numMutations: 2,
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.classList.add("pseudo");
+    // refactoring-log: with 5 numMutations I got 1 failure per 10 tries,
+    // for 3 - 6 failures per 10 tried.
+    // Also I can set numMutations to 100000 and it will be reached. Mutations
+    // is happening continuously? In while-true-loop (of course no)?
+    // Then how to explain this? Maybe we should add event on pseudo elements
+    // adding / removal in markup-view.js?
+    numMutations: 5,
+    test: function*(testActor) {
+      yield testActor.addClass("#node1", "pseudo");
     },
     check: function*(inspector) {
       let {children} = yield getContainerForSelector("#node1", inspector);
       is(children.childNodes.length, 2,
         "Node1 now has 2 children (text child and ::after");
     }
   },
   {
     desc: "Removing ::after element",
-    numMutations: 2,
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.classList.remove("pseudo");
+    numMutations: 5,
+    test: function*(testActor) {
+      yield testActor.removeClass("#node1", "pseudo");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(container.singleTextChild, "Has single text child.");
     }
   },
   {
     desc: "Updating the text-content",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.textContent = "newtext";
+    test: function*(testActor) {
+      yield testActor.setProperty("#node1", "textContent", "newtext");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(container.singleTextChild, "Has single text child.");
       ok(!container.canExpand, "Can't expand container with singleTextChild.");
       ok(!container.singleTextChild.canExpand, "Can't expand singleTextChild.");
       is(container.editor.elt.querySelector(".text").textContent.trim(), "newtext",
         "Single text child editor updated.");
     }
   },
   {
     desc: "Adding a second text child",
-    test: () => {
-      let node1 = getNode("#node1");
-      let newText = node1.ownerDocument.createTextNode("more");
-      node1.appendChild(newText);
+    test: function*(testActor) {
+      yield testActor.eval(`
+        let node = document.querySelector("#node1");
+        let newText = node.ownerDocument.createTextNode("more");
+        node.appendChild(newText);`);
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(!container.singleTextChild, "Does not have single text child.");
       ok(container.canExpand, "Can expand container with child nodes.");
       ok(container.editor.elt.querySelector(".text") == null,
         "Single text child editor removed.");
     },
   },
   {
     desc: "Go from 2 to 1 text child",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.textContent = "newtext";
+    test: function*(testActor) {
+      yield testActor.setProperty("#node1", "textContent", "newtext");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(container.singleTextChild, "Has single text child.");
       ok(!container.canExpand, "Can't expand container with singleTextChild.");
       ok(!container.singleTextChild.canExpand, "Can't expand singleTextChild.");
       ok(container.editor.elt.querySelector(".text").textContent.trim(), "newtext",
         "Single text child editor updated.");
     },
   },
   {
     desc: "Removing an only text child",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.innerHTML = "";
+    test: function*(testActor) {
+      yield testActor.setProperty("#node1", "innerHTML", "");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(!container.singleTextChild, "Does not have single text child.");
       ok(!container.canExpand, "Can't expand empty container.");
       ok(container.editor.elt.querySelector(".text") == null,
         "Single text child editor removed.");
     },
   },
   {
     desc: "Go from 0 to 1 text child",
-    test: () => {
-      let node1 = getNode("#node1");
-      node1.textContent = "newtext";
+    test: function*(testActor) {
+      yield testActor.setProperty("#node1", "textContent", "newtext");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node1", inspector);
       ok(container.singleTextChild, "Has single text child.");
       ok(!container.canExpand, "Can't expand container with singleTextChild.");
       ok(!container.singleTextChild.canExpand, "Can't expand singleTextChild.");
       ok(container.editor.elt.querySelector(".text").textContent.trim(), "newtext",
         "Single text child editor updated.");
     },
   },

   {
     desc: "Updating the innerHTML",
-    test: () => {
-      let node2 = getNode("#node2");
-      node2.innerHTML = "<div><span>foo</span></div>";
+    test: function*(testActor) {
+      yield testActor.setProperty("#node2", "innerHTML",
+        "<div><span>foo</span></div>");
     },
     check: function*(inspector) {
       let container = yield getContainerForSelector("#node2", inspector);

       let openTags = container.children.querySelectorAll(".open .tag");
       is(openTags.length, 2, "There are 2 tags in node2");
       is(openTags[0].textContent.trim(), "div", "The first tag is a div");
       is(openTags[1].textContent.trim(), "span", "The second tag is a span");

       is(container.children.querySelector(".text").textContent.trim(), "foo",
         "The span's textcontent is correct");
     }
   },
   {
     desc: "Removing child nodes",
-    test: () => {
-      let node4 = getNode("#node4");
-      while (node4.firstChild) {
-        node4.removeChild(node4.firstChild);
-      }
+    test: function*(testActor) {
+      yield testActor.eval(`
+        let node = document.querySelector("#node4");
+        while (node.firstChild) {
+          node.removeChild(node.firstChild);
+        }`);
     },
     check: function*(inspector) {
       let {children} = yield getContainerForSelector("#node4", inspector);
       is(children.innerHTML, "", "Children have been removed");
     }
   },
   {
     desc: "Appending a child to a different parent",
-    test: () => {
-      let node17 = getNode("#node17");
-      let node2 = getNode("#node2");
-      node2.appendChild(node17);
+    test: function*(testActor) {
+      yield testActor.eval(`
+        let node2 = document.querySelector("#node2");
+        let node17 = document.querySelector("#node17");
+        node2.appendChild(node17);`);
     },
     check: function*(inspector) {
       let {children} = yield getContainerForSelector("#node16", inspector);
       is(children.innerHTML, "", "Node17 has been removed from its node16 parent");

       let container = yield getContainerForSelector("#node2", inspector);
       let openTags = container.children.querySelectorAll(".open .tag");
       is(openTags.length, 3, "There are now 3 tags in node2");
@@ -225,24 +224,24 @@ const TEST_DATA = [
     //        node21
     // will become:
     // body
     //   node1
     //     node20
     //      node21
     //      node18
     //        node19
-    test: () => {
-      let node18 = getNode("#node18");
-      let node20 = getNode("#node20");
+    test: function*(testActor) {
+      yield testActor.eval(`
+        let node1 = document.querySelector("#node1");
+        let node18 = document.querySelector("#node18");
+        let node20 = document.querySelector("#node20");

-      let node1 = getNode("#node1");
-
-      node1.appendChild(node20);
-      node20.appendChild(node18);
+        node1.appendChild(node20);
+        node20.appendChild(node18);`);
     },
     check: function*(inspector) {
       yield inspector.markup.expandAll();

       let {children} = yield getContainerForSelector("#node1", inspector);
       is(children.childNodes.length, 2,
         "Node1 now has 2 children (textnode and node20)");

@@ -258,43 +257,38 @@ const TEST_DATA = [
       let node18 = node20Children.childNodes[1];
       is(node18.querySelector(".open .attreditor .attr-value").textContent.trim(),
         "node18", "Node20's second child is indeed node18");
     }
   }
 ];

 add_task(function*() {
-  let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {toolbox, inspector, testActor} = yield addTab(TEST_URL).then(openInspector);

   info("Expanding all markup-view nodes");
   yield inspector.markup.expandAll();

   for (let {desc, test, check, numMutations} of TEST_DATA) {
     info("Starting test: " + desc);

     numMutations = numMutations || 1;

     info("Executing the test markup mutation");
-    yield new Promise((resolve) => {
-      // If a test expects more than one mutation it may come through in a
-      // single event or possibly in multiples.
-      let seenMutations = 0;
-      inspector.on("markupmutation", function onmutation(e, mutations) {
-        seenMutations += mutations.length;
-        info("Receieved " + seenMutations +
-             " mutations, expecting at least " + numMutations);
-        if (seenMutations >= numMutations) {
-          inspector.off("markupmutation", onmutation);
-          resolve();
-        }
-      });
-
-      test();
-    })
+    // If a test expects more than one mutation it may come through in a
+    // single event or possibly in multiples.
+    let seenMutations = 0;
+    while (seenMutations < numMutations) {
+      let onMutation = inspector.once("markupmutation");
+      yield test(testActor);
+      let mutations = yield onMutation;
+      seenMutations += mutations.length;
+      info("Receieved " + seenMutations +
+           " mutations, expecting at least " + numMutations);
+    }

     info("Expanding all markup-view nodes to make sure new nodes are imported");
     yield inspector.markup.expandAll();

     info("Checking the markup-view content");
     yield check(inspector);
   }
 });
diff --git a/devtools/client/markupview/test/browser_markupview_mutation_02.js b/devtools/client/markupview/test/browser_markupview_mutation_02.js
--- a/devtools/client/markupview/test/browser_markupview_mutation_02.js
+++ b/devtools/client/markupview/test/browser_markupview_mutation_02.js
@@ -15,107 +15,116 @@ const TEST_URL = TEST_URL_ROOT + "doc_ma
 // - mutate: a function that should make changes to the content DOM
 // - attribute: if set, the test will expect the corresponding attribute to flash
 //   instead of the whole node
 // - flashedNode: [optional] the css selector of the node that is expected to
 //   flash in the markup-view as a result of the mutation.
 //   If missing, the rootNode (".list") will be expected to flash
 const TEST_DATA = [{
   desc: "Adding a new node should flash the new node",
-  mutate: (doc, rootNode) => {
-    let newLi = doc.createElement("LI");
-    newLi.textContent = "new list item";
-    rootNode.appendChild(newLi);
+  mutate: function*(testActor) {
+    yield testActor.eval(`
+      let rootNode = document.querySelector(".list");
+      let newLi = document.createElement("LI");
+      newLi.textContent = "new list item";
+      rootNode.appendChild(newLi);`);
   },
   flashedNode: ".list li:nth-child(3)"
 }, {
   desc: "Removing a node should flash its parent",
-  mutate: (doc, rootNode) => {
-    rootNode.removeChild(rootNode.lastElementChild);
+  mutate: function*(testActor) {
+    yield testActor.eval(`
+      let rootNode = document.querySelector(".list");
+      rootNode.removeChild(rootNode.lastElementChild);`);
   }
 }, {
   desc: "Re-appending an existing node should only flash this node",
-  mutate: (doc, rootNode) => {
-    rootNode.appendChild(rootNode.firstElementChild);
+  mutate: function*(testActor) {
+    yield testActor.eval(`
+      let rootNode = document.querySelector(".list");
+      rootNode.appendChild(rootNode.firstElementChild);`);
   },
   flashedNode: ".list .item:last-child"
 }, {
   desc: "Adding an attribute should flash the attribute",
   attribute: "test-name",
-  mutate: (doc, rootNode) => {
-    rootNode.setAttribute("test-name", "value-" + Date.now());
+  mutate: function*(testActor) {
+    yield testActor.setAttribute(".list", "test-name", "value-" + Date.now());
   }
 }, {
   desc: "Editing an attribute should flash the attribute",
   attribute: "class",
-  mutate: (doc, rootNode) => {
-    rootNode.setAttribute("class", "list value-" + Date.now());
+  mutate: function*(testActor) {
+    yield testActor.setAttribute(".list", "class", "list value-" + Date.now());
   }
 }, {
   desc: "Multiple changes to an attribute should flash the attribute",
   attribute: "class",
-  mutate: (doc, rootNode) => {
-    rootNode.removeAttribute("class");
-    rootNode.setAttribute("class", "list value-" + Date.now());
-    rootNode.setAttribute("class", "list value-" + Date.now());
-    rootNode.removeAttribute("class");
-    rootNode.setAttribute("class", "list value-" + Date.now());
-    rootNode.setAttribute("class", "list value-" + Date.now());
+  mutate: function*(testActor) {
+    yield testActor.eval(`
+      let rootNode = document.querySelector(".list");
+      rootNode.removeAttribute("class");
+      rootNode.setAttribute("class", "list value-" + Date.now());
+      rootNode.setAttribute("class", "list value-" + Date.now());
+      rootNode.removeAttribute("class");
+      rootNode.setAttribute("class", "list value-" + Date.now());
+      rootNode.setAttribute("class", "list value-" + Date.now());`);
   }
 }, {
   desc: "Removing an attribute should flash the node",
-  mutate: (doc, rootNode) => {
-    rootNode.removeAttribute("class");
+  mutate: function*(testActor) {
+    yield testActor.removeAttribute(".list", "class");
   }
 }];

 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);

   // Make sure mutated nodes flash for a very long time so we can more easily
   // assert they do
   inspector.markup.CONTAINER_FLASHING_DURATION = 1000 * 60 * 60;

-  info("Getting the <ul.list> root node to test mutations on");
-  let rootNode = getNode(".list");
+  info("Getting the <ul.list> nodeFront to test mutations on");
   let rootNodeFront = yield getNodeFront(".list", inspector);

   info("Selecting the last element of the root node before starting");
   yield selectNode(".list .item:nth-child(2)", inspector);

   for (let {mutate, flashedNode, desc, attribute} of TEST_DATA) {
     info("Starting test: " + desc);

     info("Mutating the DOM and listening for markupmutation event");
-    let mutated = inspector.once("markupmutation");
-    mutate(content.document, rootNode);
-    yield mutated;
+    let onMutation = inspector.once("markupmutation");
+    yield mutate(testActor);
+    yield onMutation;

     info("Asserting that the correct markup-container is flashing");
-    let flashingNodeFront = rootNodeFront;
-    if (flashedNode) {
-      flashingNodeFront = yield getNodeFront(flashedNode, inspector);
-    }
+    let flashingNodeFront = flashedNode
+                            ? yield getNodeFront(flashedNode, inspector)
+                            : rootNodeFront;

     if (attribute) {
       yield assertAttributeFlashing(flashingNodeFront, attribute, inspector);
     } else {
       yield assertNodeFlashing(flashingNodeFront, inspector);
     }
   }
+
+  // Make sure that all connections are completed.
+  yield inspector.once("inspector-updated");
 });

 function* assertNodeFlashing(nodeFront, inspector) {
   let container = getContainerForNodeFront(nodeFront, inspector);
   ok(container, "Markup container for node found");
   ok(container.tagState.classList.contains("theme-bg-contrast"),
     "Markup container for node is flashing");

-  // Clear the mutation flashing timeout now that we checked the node was flashing
-  let markup = inspector.markup;
+  // Clear the mutation flashing timeout now that we checked
+  // the node was flashing.
   clearTimeout(container._flashMutationTimer);
   container._flashMutationTimer = null;
   container.tagState.classList.remove("theme-bg-contrast");
 }

 function* assertAttributeFlashing(nodeFront, attribute, inspector) {
   let container = getContainerForNodeFront(nodeFront, inspector);
   ok(container, "Markup container for node found");
diff --git a/devtools/client/markupview/test/browser_markupview_navigation.js b/devtools/client/markupview/test/browser_markupview_navigation.js
--- a/devtools/client/markupview/test/browser_markupview_navigation.js
+++ b/devtools/client/markupview/test/browser_markupview_navigation.js
@@ -19,17 +19,17 @@ const TEST_DATA = [
   ["down", "node3"],
   ["down", "*comment*"],
   ["down", "node4"],
   ["right", "node4"],
   ["down", "*text*"],
   ["down", "node5"],
   ["down", "node6"],
   ["down", "*comment*"],
-  ["down" , "node7"],
+  ["down", "node7"],
   ["right", "node7"],
   ["down", "*text*"],
   ["down", "node8"],
   ["left", "node7"],
   ["left", "node7"],
   ["right", "node7"],
   ["right", "*text*"],
   ["down", "node8"],
@@ -81,17 +81,17 @@ add_task(function*() {
     yield waitForChildrenUpdated(inspector);

     info("Checking the right node is selected");
     checkSelectedNode(key, className, inspector);
   }
 });

 function pressKey(key) {
-  switch(key) {
+  switch (key) {
     case "right":
       EventUtils.synthesizeKey("VK_RIGHT", {});
       break;
     case "down":
       EventUtils.synthesizeKey("VK_DOWN", {});
       break;
     case "left":
       EventUtils.synthesizeKey("VK_LEFT", {});
@@ -110,17 +110,18 @@ function pressKey(key) {
       break;
   }
 }

 function checkSelectedNode(key, className, inspector) {
   let node = inspector.selection.nodeFront;

   if (className == "*comment*") {
-    is(node.nodeType, Node.COMMENT_NODE, "Found a comment after pressing " + key);
+    is(node.nodeType, Node.COMMENT_NODE,
+      "Found a comment after pressing " + key);
   } else if (className == "*text*") {
     is(node.nodeType, Node.TEXT_NODE, "Found text after pressing " + key);
   } else if (className == "*doctype*") {
     is(node.nodeType, Node.DOCUMENT_TYPE_NODE, "Found the doctype after pressing " + key);
   } else {
     is(node.className, className, "Found node: " + className + " after pressing " + key);
   }
 }
diff --git a/devtools/client/markupview/test/browser_markupview_node_not_displayed_02.js b/devtools/client/markupview/test/browser_markupview_node_not_displayed_02.js
--- a/devtools/client/markupview/test/browser_markupview_node_not_displayed_02.js
+++ b/devtools/client/markupview/test/browser_markupview_node_not_displayed_02.js
@@ -8,114 +8,122 @@
 // their display changes

 const TEST_URL = TEST_URL_ROOT + "doc_markup_not_displayed.html";
 const TEST_DATA = [
   {
     desc: "Hiding a node by creating a new stylesheet",
     selector: "#normal-div",
     before: true,
-    changeStyle: (doc, node) => {
-      let div = doc.createElement("div");
-      div.id = "new-style";
-      div.innerHTML = "<style>#normal-div {display:none;}</style>";
-      doc.body.appendChild(div);
+    changeStyle: function*(selector, testActor) {
+      yield testActor.eval(`
+        let div = document.createElement("div");
+        div.id = "new-style";
+        div.innerHTML = "<style>#normal-div {display:none;}</style>";
+        document.body.appendChild(div);`);
     },
     after: false
   },
   {
     desc: "Showing a node by deleting an existing stylesheet",
     selector: "#normal-div",
     before: false,
-    changeStyle: (doc, node) => {
-      doc.getElementById("new-style").remove();
+    changeStyle: function*(selector, testActor) {
+      yield testActor.removeNode("#new-style");
     },
     after: true
   },
   {
     desc: "Hiding a node by changing its style property",
     selector: "#display-none",
     before: false,
-    changeStyle: (doc, node) => {
-      node.style.display = "block";
+    changeStyle: function*(selector, testActor) {
+      yield testActor.setProperty(selector, "style", "display: block");
     },
     after: true
   },
   {
     desc: "Showing a node by removing its hidden attribute",
     selector: "#hidden-true",
     before: false,
-    changeStyle: (doc, node) => {
-      node.removeAttribute("hidden");
+    changeStyle: function*(selector, testActor) {
+      yield testActor.removeAttribute(selector, "hidden");
     },
     after: true
   },
   {
     desc: "Hiding a node by adding a hidden attribute",
     selector: "#hidden-true",
     before: true,
-    changeStyle: (doc, node) => {
-      node.setAttribute("hidden", "true");
+    changeStyle: function*(selector, testActor) {
+      yield testActor.setAttribute(selector, "hidden", "true");
     },
     after: false
   },
   {
     desc: "Showing a node by changin a stylesheet's rule",
     selector: "#hidden-via-stylesheet",
     before: false,
-    changeStyle: (doc, node) => {
-      doc.styleSheets[0].cssRules[0].style.setProperty("display", "inline");
+    changeStyle: function*(selector, testActor) {
+      yield testActor.eval(`
+        let cssRule = document.styleSheets[0].cssRules[0];
+        cssRule.style.setProperty("display", "inline");`);
     },
     after: true
   },
   {
     desc: "Hiding a node by adding a new rule to a stylesheet",
     selector: "#hidden-via-stylesheet",
     before: true,
-    changeStyle: (doc, node) => {
-      doc.styleSheets[0].insertRule(
-        "#hidden-via-stylesheet {display: none;}", 1);
+    changeStyle: function*(selector, testActor) {
+      yield testActor.eval(`
+        let stylesheet = document.styleSheets[0];
+        stylesheet.insertRule("${selector} {display: none;}", 1);`);
     },
     after: false
   },
   {
     desc: "Hiding a node by adding a class that matches an existing rule",
     selector: "#normal-div",
     before: true,
-    changeStyle: (doc, node) => {
-      doc.styleSheets[0].insertRule(
-        ".a-new-class {display: none;}", 2);
-      node.classList.add("a-new-class");
+    changeStyle: function*(selector, testActor) {
+      yield testActor.eval(`
+        let node = document.querySelector("${selector}");
+        let stylesheet = document.styleSheets[0];
+        stylesheet.insertRule(".a-new-class {display: none;}", 2);
+        node.classList.add("a-new-class");`);
     },
     after: false
   }
 ];

 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);

   for (let data of TEST_DATA) {
     info("Running test case: " + data.desc);
-    yield runTestData(inspector, data);
+    yield runTestData(inspector, testActor, data);
   }
 });

-function* runTestData(inspector, {selector, before, changeStyle, after}) {
+function* runTestData(inspector, testActor, data) {
+  let {selector, before, changeStyle, after} = data;
+
   info("Getting the " + selector + " test node");
   let nodeFront = yield getNodeFront(selector, inspector);
   let container = getContainerForNodeFront(nodeFront, inspector);
   is(!container.elt.classList.contains("not-displayed"), before,
     "The container is marked as " + (before ? "shown" : "hidden"));

   info("Listening for the display-change event");
   let onDisplayChanged = promise.defer();
   inspector.markup.walker.once("display-change", onDisplayChanged.resolve);

   info("Making style changes");
-  changeStyle(content.document, getNode(selector));
+  yield changeStyle(selector, testActor);
   let nodes = yield onDisplayChanged.promise;

   info("Verifying that the list of changed nodes include our container");

   ok(nodes.length, "The display-change event was received with a nodes");
   let foundContainer = false;
   for (let node of nodes) {
     if (getContainerForNodeFront(node, inspector) === container) {
diff --git a/devtools/client/markupview/test/browser_markupview_pagesize_02.js b/devtools/client/markupview/test/browser_markupview_pagesize_02.js
--- a/devtools/client/markupview/test/browser_markupview_pagesize_02.js
+++ b/devtools/client/markupview/test/browser_markupview_pagesize_02.js
@@ -1,45 +1,46 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */

 "use strict";

 // Tests that the markup view loads only as many nodes as specified
-// by the devtools.markup.pagesize preference and that pressing the "show all nodes"
-// actually shows the nodes
+// by the devtools.markup.pagesize preference and
+// that pressing the "show all nodes" actually shows the nodes.

 const TEST_URL = TEST_URL_ROOT + "doc_markup_pagesize_02.html";

 // Make sure nodes are hidden when there are more than 5 in a row
 Services.prefs.setIntPref("devtools.markup.pagesize", 5);

 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);

   info("Selecting the UL node");
   yield clickContainer("ul", inspector);
   info("Reloading the page with the UL node selected will expand its children");
   yield reloadPage(inspector);
   yield inspector.markup._waitForChildren();

   info("Click on the 'show all nodes' button in the UL's list of children");
   yield showAllNodes(inspector);

-  yield assertAllNodesAreVisible(inspector);
+  yield assertAllNodesAreVisible(inspector, testActor);
 });

 function* showAllNodes(inspector) {
   let container = yield getContainerForSelector("ul", inspector);
   let button = container.elt.querySelector("button");
   ok(button, "All nodes button is here");
   let win = button.ownerDocument.defaultView;

   EventUtils.sendMouseEvent({type: "click"}, button, win);
   yield inspector.markup._waitForChildren();
 }

-function* assertAllNodesAreVisible(inspector) {
+function* assertAllNodesAreVisible(inspector, testActor) {
   let container = yield getContainerForSelector("ul", inspector);
   ok(!container.elt.querySelector("button"), "All nodes button isn't here anymore");
-  is(container.children.childNodes.length, getNode("ul").children.length);
+  is(container.children.childNodes.length,
+    (yield testActor.eval("document.querySelector('ul').children.length")));
 }
diff --git a/devtools/client/markupview/test/browser_markupview_remove_xul_attributes.js b/devtools/client/markupview/test/browser_markupview_remove_xul_attributes.js
--- a/devtools/client/markupview/test/browser_markupview_remove_xul_attributes.js
+++ b/devtools/client/markupview/test/browser_markupview_remove_xul_attributes.js
@@ -5,23 +5,22 @@
 "use strict";

 // Test confirms that XUL attributes don't show up as empty
 // attributes after being deleted

 const TEST_URL = TEST_URL_ROOT + "doc_markup_xul.xul";

 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
-
-  let panel = yield getNode("#test", inspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);
   let panelFront = yield getNodeFront("#test", inspector);

-  ok(panelFront.hasAttribute("id"), "panelFront has id attribute in the beginning");
+  ok(panelFront.hasAttribute("id"),
+    "panelFront has id attribute in the beginning");

   info("Removing panel's id attribute");
-  panel.removeAttribute("id");
+  let onMutation = inspector.once("markupmutation");
+  yield testActor.removeAttribute("#test", "id");
+  yield onMutation;

-  info("Waiting for markupmutation");
-  yield inspector.once("markupmutation");
-
-  is(panelFront.hasAttribute("id"), false, "panelFront doesn't have id attribute anymore");
+  is(panelFront.hasAttribute("id"), false,
+    "panelFront doesn't have id attribute anymore");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_02.js b/devtools/client/markupview/test/browser_markupview_tag_edit_02.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_02.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_02.js
@@ -5,17 +5,17 @@
 "use strict";

 // Tests that an existing attribute can be modified

 const TEST_URL = "data:text/html,<div id='test-div'>Test modifying my ID attribute</div>";

 add_task(function*() {
   info("Opening the inspector on the test page");
-  let {toolbox, inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector} = yield addTab(TEST_URL).then(openInspector);

   info("Selecting the test node");
   yield selectNode("#test-div", inspector);

   info("Verify attributes, only ID should be there for now");
   yield assertAttributes("#test-div", {
     id: "test-div"
   });
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_05.js b/devtools/client/markupview/test/browser_markupview_tag_edit_05.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_05.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_05.js
@@ -56,22 +56,22 @@ var TEST_DATA = [{
   }
 }, {
   desc: "Add multiple attributes with no value, and some with value",
   text: "disabled name='name' data-test='test' autofocus",
   expectedAttributes: {
     disabled: "",
     autofocus: "",
     name: "name",
-    'data-test': "test"
+    "data-test": "test"
   }
 }, {
   desc: "Add attribute with xmlns",
   text: "xmlns:edi='http://ecommerce.example.org/schema'",
   expectedAttributes: {
-    'xmlns:edi': "http://ecommerce.example.org/schema"
+    "xmlns:edi": "http://ecommerce.example.org/schema"
   }
 }];

 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
-  yield runAddAttributesTests(TEST_DATA, "div", inspector)
+  yield runAddAttributesTests(TEST_DATA, "div", inspector);
 });
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_06.js b/devtools/client/markupview/test/browser_markupview_tag_edit_06.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_06.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_06.js
@@ -75,10 +75,10 @@ var TEST_DATA = [{
   expectedAttributes: {
     onclick: "javascript: throw new Error('wont fire');",
     onload: "alert('here');"
   }
 }];

 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
-  yield runAddAttributesTests(TEST_DATA, "div", inspector)
+  yield runAddAttributesTests(TEST_DATA, "div", inspector);
 });
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_07.js b/devtools/client/markupview/test/browser_markupview_tag_edit_07.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_07.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_07.js
@@ -40,63 +40,62 @@ var TEST_DATA = [{
     style: ""
   }
 }, {
   desc: "Try to add long data URL to make sure it is collapsed in attribute editor.",
   text: "style='"+DATA_URL_INLINE_STYLE+"'",
   expectedAttributes: {
     'style': DATA_URL_INLINE_STYLE
   },
-  validate: (element, container, inspector) => {
+  validate: (selector, container, inspector) => {
     let editor = container.editor;
     let visibleAttrText = editor.attrElements.get("style").querySelector(".attr-value").textContent;
     is (visibleAttrText, DATA_URL_INLINE_STYLE_COLLAPSED);
   }
 }, {
   desc: "Try to add long attribute to make sure it is collapsed in attribute editor.",
   text: 'data-long="'+LONG_ATTRIBUTE+'"',
   expectedAttributes: {
     'data-long':LONG_ATTRIBUTE
   },
-  validate: (element, container, inspector) => {
+  validate: (selector, container, inspector) => {
     let editor = container.editor;
     let visibleAttrText = editor.attrElements.get("data-long").querySelector(".attr-value").textContent;
     is (visibleAttrText, LONG_ATTRIBUTE_COLLAPSED)
   }
 }, {
   desc: "Try to add long data URL to make sure it is collapsed in attribute editor.",
   text: 'src="'+DATA_URL_ATTRIBUTE+'"',
   expectedAttributes: {
     "src": DATA_URL_ATTRIBUTE
   },
-  validate: (element, container, inspector) => {
+  validate: (selector, container, inspector) => {
     let editor = container.editor;
     let visibleAttrText = editor.attrElements.get("src").querySelector(".attr-value").textContent;
     is (visibleAttrText, DATA_URL_ATTRIBUTE_COLLAPSED);
   }
 }, {
   desc: "Try to add long attribute with collapseAttributeLength == -1" +
   "to make sure it isn't collapsed in attribute editor.",
   text: 'data-long="' + LONG_ATTRIBUTE + '"',
   expectedAttributes: {
     "data-long": LONG_ATTRIBUTE
   },
   setUp: function(inspector) {
     inspector.markup.collapseAttributeLength = -1;
   },
-  validate: (element, container, inspector) => {
+  validate: (selector, container, inspector) => {
     let editor = container.editor;
     let visibleAttrText = editor.attrElements
       .get("data-long")
       .querySelector(".attr-value")
       .textContent;
     is(visibleAttrText, LONG_ATTRIBUTE);
   },
   tearDown: function(inspector) {
     inspector.markup.collapseAttributeLength = 120;
   }
 }];

 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
   yield runAddAttributesTests(TEST_DATA, "div", inspector)
 });
-
diff --git a/devtools/client/markupview/test/browser_markupview_tag_edit_12.js b/devtools/client/markupview/test/browser_markupview_tag_edit_12.js
--- a/devtools/client/markupview/test/browser_markupview_tag_edit_12.js
+++ b/devtools/client/markupview/test/browser_markupview_tag_edit_12.js
@@ -5,23 +5,23 @@
 "use strict";

 // Tests that focus position is correct when tabbing through and editing
 // attributes.

 const TEST_URL = "data:text/html;charset=utf8,<div id='attr' c='3' b='2' a='1'></div><div id='delattr' last='1' tobeinvalid='2'></div>";

 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);

-  yield testAttributeEditing(inspector);
-  yield testAttributeDeletion(inspector);
+  yield testAttributeEditing(inspector, testActor);
+  yield testAttributeDeletion(inspector, testActor);
 });

-function* testAttributeEditing(inspector) {
+function* testAttributeEditing(inspector, testActor) {
   info("Testing focus position after attribute editing");

   // Modifying attributes reorders them in the internal representation to move
   // the modified attribute to the end. breadcrumbs.js will update attributes
   // to match original order if you selectNode before modifying attributes.
   // So, hacky workaround for consistency with manual testing.
   // Should be removed after Bug 1093593.
   yield selectNode("#attr", inspector);
@@ -29,17 +29,17 @@ function* testAttributeEditing(inspector
   info("Setting the first non-id attribute in edit mode");
   yield activateFirstAttribute("#attr", inspector); // focuses id
   collapseSelectionAndTab(inspector); // focuses the first attr after id

   // Detect the attributes order from the DOM, instead of assuming an order in
   // the test, because the NamedNodeMap returned by element.attributes doesn't
   // guaranty any specific order.
   // Filter out the id attribute as the markup-view places it first anyway.
-  let attrs = getNodeAttributesOtherThanId("#attr");
+  let attrs = yield getNodeAttributesOtherThanId("#attr", testActor);

   info("Editing this attribute, keeping the same name, and tabbing to the next");
   yield editAttributeAndTab(attrs[0].name + '="99"', inspector);
   checkFocusedAttribute(attrs[1].name, true);

   info("Editing the new focused attribute, keeping the name, and tabbing to the previous");
   yield editAttributeAndTab(attrs[1].name + '="99"', inspector, true);
   checkFocusedAttribute(attrs[0].name, true);
@@ -47,17 +47,17 @@ function* testAttributeEditing(inspector
   info("Editing attribute name, changes attribute order");
   yield editAttributeAndTab("d='4'", inspector);
   checkFocusedAttribute("id", true);

   // Escape of the currently focused field for the next test
   EventUtils.sendKey("escape", inspector.panelWin);
 }

-function* testAttributeDeletion(inspector) {
+function* testAttributeDeletion(inspector, testActor) {
   info("Testing focus position after attribute deletion");

   // Modifying attributes reorders them in the internal representation to move
   // the modified attribute to the end. breadcrumbs.js will update attributes
   // to match original order if you selectNode before modifying attributes.
   // So, hacky workaround for consistency with manual testing.
   // Should be removed after Bug 1093593.
   yield selectNode("#delattr", inspector);
@@ -65,17 +65,17 @@ function* testAttributeDeletion(inspecto
   info("Setting the first non-id attribute in edit mode");
   yield activateFirstAttribute("#delattr", inspector); // focuses id
   collapseSelectionAndTab(inspector); // focuses the first attr after id

   // Detect the attributes order from the DOM, instead of assuming an order in
   // the test, because the NamedNodeMap returned by element.attributes doesn't
   // guaranty any specific order.
   // Filter out the id attribute as the markup-view places it first anyway.
-  let attrs = getNodeAttributesOtherThanId("#delattr");
+  let attrs = yield getNodeAttributesOtherThanId("#delattr", testActor);

   info("Entering an invalid attribute to delete the attribute");
   yield editAttributeAndTab('"', inspector);
   checkFocusedAttribute(attrs[1].name, true);

   info("Deleting the last attribute");
   yield editAttributeAndTab(" ", inspector);

@@ -105,11 +105,13 @@ function* activateFirstAttribute(contain
   let {editor} = yield getContainerForSelector(container, inspector);
   editor.tag.focus();

   // Go to "id" attribute and trigger edit mode.
   EventUtils.sendKey("tab", inspector.panelWin);
   EventUtils.sendKey("return", inspector.panelWin);
 }

-function getNodeAttributesOtherThanId(selector) {
-  return [...getNode(selector).attributes].filter(attr => attr.name !== "id");
+function* getNodeAttributesOtherThanId(selector, testActor) {
+  return (yield testActor.getAttributes(selector)).filter(attr => {
+    return attr.name !== "id";
+  });
 }
diff --git a/devtools/client/markupview/test/browser_markupview_textcontent_edit_01.js b/devtools/client/markupview/test/browser_markupview_textcontent_edit_01.js
--- a/devtools/client/markupview/test/browser_markupview_textcontent_edit_01.js
+++ b/devtools/client/markupview/test/browser_markupview_textcontent_edit_01.js
@@ -4,49 +4,53 @@

 "use strict";

 // Test editing a node's text content

 const TEST_URL = TEST_URL_ROOT + "doc_markup_edit.html";

 add_task(function*() {
-  let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {inspector, testActor} = yield addTab(TEST_URL).then(openInspector);

   info("Expanding all nodes");
   yield inspector.markup.expandAll();
   yield waitForMultipleChildrenUpdates(inspector);

-  yield editContainer(inspector, {
+  yield editContainer(inspector, testActor, {
     selector: ".node6",
     newValue: "New text",
     oldValue: "line6"
   });

-  yield editContainer(inspector, {
+  yield editContainer(inspector, testActor, {
     selector: "#node17",
     newValue: "LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT. DONEC POSUERE PLACERAT MAGNA ET IMPERDIET.",
     oldValue: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec posuere placerat magna et imperdiet.",
     shortValue: true
   });

-  yield editContainer(inspector, {
+  yield editContainer(inspector, testActor, {
     selector: "#node17",
     newValue: "New value",
     oldValue: "LOREM IPSUM DOLOR SIT AMET, CONSECTETUR ADIPISCING ELIT. DONEC POSUERE PLACERAT MAGNA ET IMPERDIET.",
     shortValue: true
   });
 });

-function* editContainer(inspector, {selector, newValue, oldValue, shortValue}) {
-  let node = getNode(selector).firstChild;
-  is(node.nodeValue, oldValue, "The test node's text content is correct");
+function* editContainer(inspector, testActor, data) {
+  let {selector, newValue, oldValue, shortValue} = data;
+  let nodeValue;
+
+  nodeValue = yield testActor.eval(
+    `document.querySelector("${selector}").firstChild.nodeValue`);
+  is(nodeValue, oldValue, "The test node's text content is correct");

   info("Changing the text content");
-  let onMutated = inspector.once("markupmutation");
+  let onMutation = inspector.once("markupmutation");
   let container = yield getContainerForSelector(selector, inspector);
   let field = container.elt.querySelector("pre");

   if (shortValue) {
     is (oldValue.indexOf(field.textContent.substring(0, field.textContent.length - 1)), 0,
         "The shortened value starts with the full value " + field.textContent);
     ok (oldValue.length > field.textContent.length, "The shortened value is short");
   } else {
@@ -59,16 +63,18 @@ function* editContainer(inspector, {sele
     info("Waiting for the text to be updated");
     yield inspector.markup.once("text-expand");
   }

   is (field.textContent, oldValue, "The text node has the correct original value after selecting");
   setEditableFieldValue(field, newValue, inspector);

   info("Listening to the markupmutation event");
-  yield onMutated;
+  yield onMutation;

-  is(node.nodeValue, newValue, "The test node's text content has changed");
+  nodeValue = yield testActor.eval(
+    `document.querySelector("${selector}").firstChild.nodeValue`);
+  is(nodeValue, newValue, "The test node's text content has changed");

   info("Selecting the <body> to reset the selection");
   let bodyContainer = yield getContainerForSelector("body", inspector);
   inspector.markup.markNodeAsSelected(bodyContainer.node);
 }
diff --git a/devtools/client/markupview/test/browser_markupview_toggle_01.js b/devtools/client/markupview/test/browser_markupview_toggle_01.js
--- a/devtools/client/markupview/test/browser_markupview_toggle_01.js
+++ b/devtools/client/markupview/test/browser_markupview_toggle_01.js
@@ -5,16 +5,17 @@
 "use strict";

 // Test toggling (expand/collapse) elements by clicking on twisties

 const TEST_URL = TEST_URL_ROOT + "doc_markup_toggle.html";

 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {walker} = inspector;

   info("Getting the container for the html element");
   let container = yield getContainerForSelector("html", inspector);
   ok(container.mustExpand, "HTML element mustExpand");
   ok(container.canExpand, "HTML element canExpand");
   is(container.expander.style.visibility, "hidden", "HTML twisty is hidden");

   info("Getting the container for the UL parent element");
@@ -27,30 +28,31 @@ add_task(function*() {
   let onChildren = waitForChildrenUpdated(inspector);
   let onUpdated = inspector.once("inspector-updated");
   EventUtils.synthesizeMouseAtCenter(container.expander, {},
     inspector.markup.doc.defaultView);
   yield onChildren;
   yield onUpdated;

   info("Checking that child LI elements have been created");
-  for (let i = 0; i < content.document.querySelectorAll("li").length; i ++) {
+  let liCount = (yield walker.querySelectorAll(walker.rootNode, "li")).length;
+  for (let i = 0; i < liCount; i ++) {
     let liContainer = yield getContainerForSelector(
       "li:nth-child(" + (i + 1) + ")", inspector);
     ok(liContainer, "A container for the child LI element was created");
   }
   ok(container.expanded, "Parent UL container is expanded");

   info("Clicking again on the UL expander");
   // No need to wait, this is a local, synchronous operation where nodes are
   // only hidden from the view, not destroyed
   EventUtils.synthesizeMouseAtCenter(container.expander, {},
     inspector.markup.doc.defaultView);

   info("Checking that child LI elements have been hidden");
-  for (let i = 0; i < content.document.querySelectorAll("li").length; i ++) {
+  for (let i = 0; i < liCount; i ++) {
     let liContainer = yield getContainerForSelector(
       "li:nth-child(" + (i + 1) + ")", inspector);
     is(liContainer.elt.getClientRects().length, 0,
       "The container for the child LI element was hidden");
   }
   ok(!container.expanded, "Parent UL container is collapsed");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_toggle_02.js b/devtools/client/markupview/test/browser_markupview_toggle_02.js
--- a/devtools/client/markupview/test/browser_markupview_toggle_02.js
+++ b/devtools/client/markupview/test/browser_markupview_toggle_02.js
@@ -5,43 +5,45 @@
 "use strict";

 // Test toggling (expand/collapse) elements by dbl-clicking on tag lines

 const TEST_URL = TEST_URL_ROOT + "doc_markup_toggle.html";

 add_task(function*() {
   let {inspector} = yield addTab(TEST_URL).then(openInspector);
+  let {walker} = inspector;

   info("Getting the container for the UL parent element");
   let container = yield getContainerForSelector("ul", inspector);

   info("Dbl-clicking on the UL parent expander, and waiting for children");
   let onChildren = waitForChildrenUpdated(inspector);
   let onUpdated = inspector.once("inspector-updated");
   EventUtils.synthesizeMouseAtCenter(container.tagLine, {clickCount: 2},
     inspector.markup.doc.defaultView);
   yield onChildren;
   yield onUpdated;

   info("Checking that child LI elements have been created");
-  for (let i = 0; i < content.document.querySelectorAll("li").length; i ++) {
+  let liCount = (yield walker.querySelectorAll(walker.rootNode, "li")).length;
+  for (let i = 0; i < liCount; i++) {
     let liContainer = yield getContainerForSelector(
       "li:nth-child(" + (i + 1) + ")", inspector);
     ok(liContainer, "A container for the child LI element was created");
   }
   ok(container.expanded, "Parent UL container is expanded");

   info("Dbl-clicking again on the UL expander");
   // No need to wait, this is a local, synchronous operation where nodes are
   // only hidden from the view, not destroyed
   EventUtils.synthesizeMouseAtCenter(container.tagLine, {clickCount: 2},
     inspector.markup.doc.defaultView);

   info("Checking that child LI elements have been hidden");
-  for (let i = 0; i < content.document.querySelectorAll("li").length; i ++) {
+  for (let i = 0; i < liCount; i++) {
     let liContainer = yield getContainerForSelector(
       "li:nth-child(" + (i + 1) + ")", inspector);
     is(liContainer.elt.getClientRects().length, 0,
       "The container for the child LI element was hidden");
   }
   ok(!container.expanded, "Parent UL container is collapsed");
 });
diff --git a/devtools/client/markupview/test/browser_markupview_update-on-navigtion.js b/devtools/client/markupview/test/browser_markupview_update-on-navigtion.js
--- a/devtools/client/markupview/test/browser_markupview_update-on-navigtion.js
+++ b/devtools/client/markupview/test/browser_markupview_update-on-navigtion.js
@@ -5,23 +5,23 @@

 // Test that markup view handles page navigation correctly.

 const SCHEMA = "data:text/html;charset=UTF-8,";
 const URL_1 = SCHEMA + "<div id='one' style='color:red;'>ONE</div>";
 const URL_2 = SCHEMA + "<div id='two' style='color:green;'>TWO</div>";

 add_task(function* () {
-  let { inspector, toolbox } = yield addTab(URL_1).then(openInspector);
+  let {inspector, toolbox, testActor} = yield addTab(URL_1).then(openInspector);

   assertMarkupViewIsLoaded();
   yield selectNode("#one", inspector);

   let willNavigate = toolbox.target.once("will-navigate");
-  content.location = URL_2;
+  testActor.eval(`document.location = "${URL_2}"`);

   info("Waiting for will-navigate");
   yield willNavigate;

   info("Navigation to page 2 has started, the inspector should be empty");
   assertMarkupViewIsEmpty();

   info("Waiting for new-root");
diff --git a/devtools/client/markupview/test/head.js b/devtools/client/markupview/test/head.js
--- a/devtools/client/markupview/test/head.js
+++ b/devtools/client/markupview/test/head.js
@@ -18,16 +18,20 @@ waitForExplicitFinish();

 // If a test times out we want to see the complete log and not just the last few
 // lines.
 SimpleTest.requestCompleteLog();

 // Uncomment this pref to dump all devtools emitted events to the console.
 // Services.prefs.setBoolPref("devtools.dump.emit", true);

+// Import helpers registering the test-actor in remote targets
+var testDir = gTestPath.substr(0, gTestPath.lastIndexOf("/"));
+Services.scriptloader.loadSubScript(testDir + "../../../shared/test/test-actor-registry.js", this);
+
 // Set the testing flag on DevToolsUtils and reset it when the test ends
 DevToolsUtils.testing = true;
 registerCleanupFunction(() => DevToolsUtils.testing = false);

 // Clear preferences that may be set during the course of tests.
 registerCleanupFunction(() => {
   Services.prefs.clearUserPref("devtools.inspector.htmlPanelOpen");
   Services.prefs.clearUserPref("devtools.inspector.sidebarOpen");
@@ -132,17 +136,21 @@ function openToolbox(toolId) {
  * @return a promise that resolves when the inspector is ready
  */
 function openInspector() {
   return openToolbox("inspector").then(({toolbox}) => {
     let inspector = toolbox.getCurrentPanel();
     let eventId = "inspector-updated";
     return inspector.once("inspector-updated").then(() => {
       info("The inspector panel is active and ready");
-      return {toolbox: toolbox, inspector: inspector};
+      return registerTestActor(toolbox.target.client);
+    }).then(() => {
+      return getTestActor(toolbox);
+    }).then((testActor) => {
+      return {toolbox, inspector, testActor};
     });
   });
 }

 /**
  * Wait for a content -> chrome message on the message manager (the window
  * messagemanager is used).
  * @param {String} name The message name
@@ -189,30 +197,16 @@ function executeInContent(name, data={},
 /**
  * Reload the current tab location.
  */
 function reloadTab() {
   return executeInContent("devtools:test:reload", {}, {}, false);
 }

 /**
- * Simple DOM node accesor function that takes either a node or a string css
- * selector as argument and returns the corresponding node
- * @param {String|DOMNode} nodeOrSelector
- * @return {DOMNode|CPOW} Note that in e10s mode a CPOW object is returned which
- * doesn't implement *all* of the DOMNode's properties
- */
-function getNode(nodeOrSelector) {
-  info("Getting the node for '" + nodeOrSelector + "'");
-  return typeof nodeOrSelector === "string" ?
-    content.document.querySelector(nodeOrSelector) :
-    nodeOrSelector;
-}
-
-/**
  * Get the NodeFront for a given css selector, via the protocol
  * @param {String|NodeFront} selector
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * loaded in the toolbox
  * @return {Promise} Resolves to the NodeFront instance
  */
 function getNodeFront(selector, {walker}) {
   if (selector._form) {
diff --git a/devtools/client/markupview/test/helper_attributes_test_runner.js b/devtools/client/markupview/test/helper_attributes_test_runner.js
--- a/devtools/client/markupview/test/helper_attributes_test_runner.js
+++ b/devtools/client/markupview/test/helper_attributes_test_runner.js
@@ -48,34 +48,34 @@ function runAddAttributesTests(tests, no
  * @param {String} selector The node selector corresponding to the test element
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * opened
  */
 function* runAddAttributesTest(test, selector, inspector) {
   if (test.setUp) {
     test.setUp(inspector);
   }
-  let element = getNode(selector);

   info("Starting add-attribute test: " + test.desc);
   yield addNewAttributes(selector, test.text, inspector);

   info("Assert that the attribute(s) has/have been applied correctly");
   yield assertAttributes(selector, test.expectedAttributes);

   if (test.validate) {
     let container = yield getContainerForSelector(selector, inspector);
-    test.validate(element, container, inspector);
+    test.validate(selector, container, inspector);
   }

   info("Undo the change");
   yield undoChange(inspector);

   info("Assert that the attribute(s) has/have been removed correctly");
   yield assertAttributes(selector, {});
+
   if (test.tearDown) {
     test.tearDown(inspector);
   }
 }

 /**
  * Run a series of edit-attributes tests.
  * This function will iterate over the provided tests array and run each test.
diff --git a/devtools/client/markupview/test/helper_outerhtml_test_runner.js b/devtools/client/markupview/test/helper_outerhtml_test_runner.js
--- a/devtools/client/markupview/test/helper_outerhtml_test_runner.js
+++ b/devtools/client/markupview/test/helper_outerhtml_test_runner.js
@@ -10,21 +10,21 @@
  * This test runner will wait for the mutation event to be fired and will check
  * a few things. Each test may also provide its own validate function to perform
  * assertions and verify that the new outer html is correct.
  * @param {Array} tests See runEditOuterHTMLTest for the structure
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * opened
  * @return a promise that resolves when the tests have run
  */
-function runEditOuterHTMLTests(tests, inspector) {
+function runEditOuterHTMLTests(tests, inspector, testActor) {
   info("Running " + tests.length + " edit-outer-html tests");
   return Task.spawn(function* () {
     for (let step of TEST_DATA) {
-      yield runEditOuterHTMLTest(step, inspector);
+      yield runEditOuterHTMLTest(step, inspector, testActor);
     }
   });
 }

 /**
  * Run a single edit-outer-html test.
  * See runEditOuterHTMLTests for a description.
  * @param {Object} test A test object should contain the following properties:
@@ -32,44 +32,48 @@ function runEditOuterHTMLTests(tests, in
  *        - oldHTML {String}
  *        - newHTML {String}
  *        - validate {Function} will be executed when the edition test is done,
  *        after the new outer-html has been inserted. Should be used to verify
  *        the actual DOM, see if it corresponds to the newHTML string provided
  * @param {InspectorPanel} inspector The instance of InspectorPanel currently
  * opened
  */
-function* runEditOuterHTMLTest(test, inspector) {
+function* runEditOuterHTMLTest(test, inspector, testActor) {
   info("Running an edit outerHTML test on '" + test.selector + "'");
   yield selectNode(test.selector, inspector);
   let oldNodeFront = inspector.selection.nodeFront;

   let onUpdated = inspector.once("inspector-updated");

   info("Listen for reselectedonremoved and edit the outerHTML");
   let onReselected = inspector.markup.once("reselectedonremoved");
   yield inspector.markup.updateNodeOuterHTML(inspector.selection.nodeFront,
                                              test.newHTML, test.oldHTML);
   yield onReselected;

-  // Typically selectedNode will === pageNode, but if a new element has been
-  // injected in front of it, this will not be the case. If this happens.
+  // Typically selectedNode will === node matched by selector,
+  // but if a new element has been injected in front of it,
+  // this will not be the case. If this happens.
   let selectedNodeFront = inspector.selection.nodeFront;
-  let pageNodeFront = yield inspector.walker.querySelector(inspector.walker.rootNode, test.selector);
-  let pageNode = getNode(test.selector);
+  let {walker} = inspector;
+  let pageNodeFront = yield walker.querySelector(walker.rootNode, test.selector);

   if (test.validate) {
-    yield test.validate(pageNode, pageNodeFront, selectedNodeFront, inspector);
+    let data = {selector: test.selector, pageNodeFront, selectedNodeFront};
+    yield test.validate(data, inspector, testActor);
   } else {
-    is(pageNodeFront, selectedNodeFront, "Original node (grabbed by selector) is selected");
+    is(pageNodeFront, selectedNodeFront,
+      "Original node (grabbed by selector) is selected");
     let {outerHTML} = yield getNodeInfo(test.selector);
     is(outerHTML, test.newHTML, "Outer HTML has been updated");
   }

   // Wait for the inspector to be fully updated to avoid causing errors by
   // abruptly closing hanging requests when the test ends
   yield onUpdated;

   let closeTagLine = inspector.markup.getContainer(pageNodeFront).closeTagLine;
   if (closeTagLine) {
-    is(closeTagLine.querySelectorAll(".theme-fg-contrast").length, 0, "No contrast class");
+    is(closeTagLine.querySelectorAll(".theme-fg-contrast").length, 0,
+      "No contrast class");
   }
 }
diff --git a/devtools/client/shared/test/test-actor.js b/devtools/client/shared/test/test-actor.js
--- a/devtools/client/shared/test/test-actor.js
+++ b/devtools/client/shared/test/test-actor.js
@@ -1,15 +1,15 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
  http://creativecommons.org/publicdomain/zero/1.0/ */

 "use strict";

-// A helper actor for brower/devtools/inspector tests.
+// A helper actor for inspector and markupview tests.

 var { Cc, Ci, Cu, Cr } = require("chrome");
 const {getRect, getElementFromPoint, getAdjustedQuads} = require("devtools/shared/layout/utils");
 const promise = require("promise");
 const {Task} = Cu.import("resource://gre/modules/Task.jsm", {});
 var DOMUtils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
 var loader = Cc["@mozilla.org/moz/jssubscript-loader;1"]
             .getService(Ci.mozIJSSubScriptLoader);
@@ -408,17 +408,17 @@ var TestActor = exports.TestActor = prot
     response: {
       value: RetVal("json")
     }
   }),

   /**
    * Set a JS property on a DOM Node.
    * @param {String} selector The node selector
-   * @param {String} attribute The attribute name
+   * @param {String} property The property name
    * @param {String} value The attribute value
    */
   setProperty: protocol.method(function (selector, property, value) {
     let node = this._querySelector(selector);
     node[property] = value;
   }, {
     request: {
       selector: Arg(0, "string"),
@@ -426,33 +426,156 @@ var TestActor = exports.TestActor = prot
       value: Arg(2, "string")
     },
     response: {}
   }),

   /**
    * Get a JS property on a DOM Node.
    * @param {String} selector The node selector
-   * @param {String} attribute The attribute name
-   * @return {String} value The attribute value
+   * @param {String} property The property name
+   * @return {String} value The property value
    */
   getProperty: protocol.method(function (selector, property) {
     let node = this._querySelector(selector);
     return node[property];
   }, {
     request: {
       selector: Arg(0, "string"),
       property: Arg(1, "string")
     },
     response: {
       value: RetVal("string")
     }
   }),

   /**
+   * Get an attribute on a DOM Node.
+   * @param {String} selector
+   * @param {String} attribute
+   * @return {String} value
+   */
+  getAttribute: protocol.method(function(selector, attribute) {
+    let node = this._querySelector(selector);
+    return node.getAttribute(attribute);
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+      attribute: Arg(1, "string")
+    },
+    response: {
+      value: RetVal("string")
+    }
+  }),
+
+  /**
+   * Get attributes on a DOM Node.
+   *
+   * @param  {String} selector
+   * @return {Array}
+   *         Array of attributes (e.g. [{name: "id", value: "value"}]).
+   */
+  getAttributes: protocol.method(function (selector) {
+    let node = this._querySelector(selector);
+    return [...node.attributes].map(attribute => {
+      return {
+        name: attribute.name,
+        value: attribute.value
+      }
+    });
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+    },
+    response: {
+      value: RetVal("json")
+    }
+  }),
+
+  /**
+   * Set an attribute on a DOM Node.
+   * @param {String} selector
+   * @param {String} attribute
+   * @param {String} value
+   */
+  setAttribute: protocol.method(function(selector, attribute, value) {
+    let node = this._querySelector(selector);
+    node.setAttribute(attribute, value);
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+      attribute: Arg(1, "string"),
+      value: Arg(2, "string")
+    },
+    response: {}
+  }),
+
+  /**
+   * Remove an attribute on a DOM Node.
+   * @param {String} selector
+   * @param {String} attribute
+   */
+  removeAttribute: protocol.method(function(selector, attribute) {
+    let node = this._querySelector(selector);
+    node.removeAttribute(attribute);
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+      attribute: Arg(1, "string")
+    },
+    response: {}
+  }),
+
+  /**
+   * Add class on a DOM Node.
+   * @param {String} selector
+   * @param {String} className
+   */
+  addClass: protocol.method(function(selector, className) {
+    let node = this._querySelector(selector);
+    node.classList.add(className);
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+      className: Arg(1, "string")
+    },
+    response: {}
+  }),
+
+  /**
+   * Remove class on a DOM Node.
+   * @param {String} selector
+   * @param {String} className
+   */
+  removeClass: protocol.method(function(selector, className) {
+    let node = this._querySelector(selector);
+    node.classList.remove(className);
+  }, {
+    request: {
+      selector: Arg(0, "string"),
+      className: Arg(1, "string")
+    },
+    response: {}
+  }),
+
+  /**
+   * Remove a DOM Node.
+   * @param {String} selector
+   */
+  removeNode: protocol.method(function(selector) {
+    let node = this._querySelector(selector);
+    node.remove();
+  }, {
+    request: {
+      selector: Arg(0, "string")
+    },
+    response: {}
+  }),
+
+  /**
    * Reload an iframe and wait for its load event.
    * @param {String} selector The node selector
    */
   reloadFrame: protocol.method(function (selector) {
     let node = this._querySelector(selector);

     let deferred = promise.defer();
